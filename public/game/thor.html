<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Thorspace</title>
  <!-- Supabase Client para modo multiplayer -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
body, html {
  height: 100%;
  margin: 0;
  padding: 0;
  background: #000;
}

button, .mode-btn, .end-btn {
  text-transform: uppercase;
}

canvas {
  display: block;
  margin: 0 auto;
  box-shadow: 0 0 60px #0ff4;
  border: 2px solid #0ff;
}

#galaxyBg {
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  z-index: 0; /* atrÃ¡s de tudo */
  background: url('images/galaxiaintro.png') center center / cover no-repeat;
  opacity: 0.18; /* ajuste a transparÃªncia aqui! */
  pointer-events: none; /* permite clicar em tudo acima normalmente */
    backdrop-filter: blur(54px);
  -webkit-backdrop-filter: blur(54px);
}


#startContainer {
  position: fixed;
  top: 0; left: 0; width: 100vw; height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  /* Troque justify-content: center; por: */
  justify-content: flex-start;
  padding-top: 7vh; /* Suba tudo ajustando aqui! */
  z-index: 1001;
  pointer-events: auto;
  background: transparent;
}


#thorspace-title {
  position: static;
  margin-bottom: 36px;
  font-family: 'Orbitron', sans-serif;
  font-size: 56px;
  color: #0ff;
  text-shadow: 0 4px 16px #000, 0 0 32px #0ff9;
  letter-spacing: 6px;
  font-weight: bold;
  user-select: none;
  pointer-events: none;
  text-transform: uppercase;
  text-align: center;
}

#startModal {
  position: static;
  width: auto;
  height: auto;
  display: flex; align-items: center; justify-content: center;
  z-index: 1002;
  border-radius: 32px;
}

#startModal .modal-content {
background: rgba(0, 165, 242, 0.04);
    border: 1px solid rgba(0, 165, 242, 1.42);
    box-shadow: 0 0 7px #00a5f2, 0 0 0.3px #0ff8 inset, 0 0 0px #000c;
    border-radius: 28px;
    padding: 48px 36px 36px 36px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 28px;
    backdrop-filter: blur(15px) brightness(1.6);
    -webkit-backdrop-filter: blur(49px) brightness(1.21);
}

#startModal label {
  color: #fff;
  font-family: 'Orbitron', sans-serif;
  font-size: 22px;
  letter-spacing: 2px;
  margin-bottom: 12px;
}

#playerNameInput {
  background: #0a1b2b;
  color: #00a5f2;
  border: 2px solid #00a5f2;
  border-radius: 6px;
  padding: 10px 20px;
  font-size: 20px;
  font-family: 'Orbitron', sans-serif;
  letter-spacing: 1.5px;
  text-transform: uppercase;
  outline: none;
  transition: border 0.2s;
  box-shadow: 0 2px 24px #00a5f2 inset;
}

#startBtn {
  margin-top: 14px;
  background: linear-gradient(90deg, #07d8ff, #005ea8 70%);
  color: #fff;
  font-family: 'Orbitron', sans-serif;
  font-size: 22px;
  border: none;
  border-radius: 8px;
  padding: 10px 44px;
  letter-spacing: 2px;
  box-shadow: 0 0 20px #0ff5, 0 2px 8px #000c inset;
  cursor: pointer;
  transition: background 0.3s;
}
#startBtn:hover {
  background: linear-gradient(90deg, #1ef3fc, #1e72ef 80%);
  color: #0ff;
}

/* HUD Superior */

#hudTop {
  width: 800px;
  min-width: 800px;
  max-width: 100vw;
  min-height: 64px;
  height: auto;
  display: flex;
  flex-direction: row;
  justify-content: flex-start;
  align-items: center;
  padding: 0 0 0 0;
  font-family: 'Orbitron', sans-serif;
  font-size: 18px;
  color: #fff;
  background: transparent;
  box-sizing: border-box;
  transition: opacity 0.2s;
  gap: 0;
}






#timerArea {
  width: 90px;
  min-width: 90px;
  max-width: 90px;
  text-align: left;
  font-family: 'Orbitron',sans-serif;
  font-size: 28px;
  color: #00a5f2;
  text-shadow: 0 0 14px #0ff8;
  flex-shrink: 0;
  margin-right: 18px;
  padding-left: 0;
}
#timerText {
  font-size:38px;
}
#bgm-mute-btn {
  position: absolute;
  right: 0;
  top: 50%;
  transform: translateY(-50%);
  z-index: 10;
  background: none;
  border: none;
  cursor: pointer;
  padding: 6px 4px;
  display: none;
  align-items: center;
  opacity: 0.75;
  transition: opacity 0.2s;
}
#bgm-mute-btn:hover { opacity: 1; }
#legendArea {
  flex: 1 1 0%;
  width: auto;
  min-width: 580px;
  max-width: 900px;
  min-height: 64px;
  margin: 0;
  text-align: left;
  color: #00a5f2;
  font-family: 'Orbitron', sans-serif;
  font-size: 16px;
  letter-spacing: 0.1px;
  text-shadow: 0 0 9px #0ff6;
  white-space: nowrap;
  word-break: keep-all;
  line-height: 1.18;
  padding-left: 0;
  padding-right: 0;
  box-sizing: border-box;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: flex-start;
  flex-wrap: nowrap;
  white-space: nowrap;
}

/* Telas finais */
.end-screen {
  position: fixed;
  top: 0; left: 0; width: 100vw; height: 100vh;
  z-index: 10010;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  opacity: 0;
  transition: opacity 0.5s;
  pointer-events: none;
}
.end-screen[style*="display: flex"] {
  opacity: 1;
  pointer-events: auto;
}
.bg-full {
  position: absolute;
  top: 0; left: 0; width: 100vw; height: 100vh;
  object-fit: cover;
  z-index: 1;
  pointer-events: none;
}
.end-label {
  position: relative;
  z-index: 2;
  max-width: 60vw;
  max-height: 35vh;
  margin-bottom: 32px;
  margin-top: 12vh;
  display: block;
}
.end-btn {
  z-index: 3;
  margin-top: 50px;
  padding: 8px 24px;
  font-size: 1rem;
  font-family: 'Orbitron', sans-serif;
  background: linear-gradient(90deg, #FFD700, #ff8400 90%);
  border: none;
  border-radius: 10px;
  color: #333;
  font-weight: bold;
  letter-spacing: 2px;
  box-shadow: 0 0 32px #FFD70044;
  cursor: pointer;
  transition: background 0.2s;
}
.end-btn:hover {
  background: linear-gradient(90deg, #fff5a1, #ffbc00 100%);
  color: #000;
}

/* Scoreboard */
.score-board {
  position: relative;
  z-index: 2;
  color: #ffffff;
  font-family: 'Orbitron', sans-serif;
  font-size: 2.1em;
  font-weight: bold;
  text-align: center;
  margin-bottom: -46px;
  text-shadow: 0 0 14px #0ff9, 0 6px 11px #000b;
  letter-spacing: 4px;
}

/* Game Wrapper */
#gameWrapper {
  position: fixed;
  top: 0; left: 0;
  width: 100vw;
  height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding-top: 40px;
  z-index: 1;
}

/* Restante dos estilos do seu jogo, se houver... */

/* Responsivo para telas pequenas */
/* @media (max-width: 900px) {
  #hudTop, #timerArea, #legendArea {
    // Responsivo: adicione regras se necessÃ¡rio
  }
} */
@media (max-width: 600px) {
  #thorspace-title {
    font-size: 32px;
    margin-bottom: 18px;
  }
  #startModal .modal-content {
    padding: 26px 12px 18px 12px;
    min-width: 180px;
    font-size: 15px;
  }
  .end-label {
    margin-top: 4vh;
    max-width: 94vw;
    max-height: 30vh;
  }
  .end-btn {
    padding: 12px 8vw;
    font-size: 1.2rem;
  }
}

@keyframes glow-pulse {
  0% {
    filter:
      drop-shadow(0 0 1px #0ff)
      drop-shadow(0 0 0px #0ff9)
      drop-shadow(0 0 0px #0ff8);
  }
  100% {
    filter:
      drop-shadow(0 0 0px #00f6ff)
      drop-shadow(0 0 0px #14ffff)
      drop-shadow(0 0 10px #1cfff7);
  }
}

#thorspace-logo {
    width: 550px;
    max-width: 80vw;
    height: auto;
    margin-bottom: -94px;
  filter: drop-shadow(0 0 28px #0ff5);
  /* Adapte outros efeitos se quiser */
}

.nave-card {
  background: rgba(0, 165, 242, 0.07);
  border: 2px solid #0ff;
  border-radius: 20px;
  padding: 24px;
  width: 200px;
  box-sizing: border-box;
  text-align: center;
  box-shadow: none;
  backdrop-filter: blur(14px);
  -webkit-backdrop-filter: blur(14px);
  cursor: pointer;
  transition: transform 0.3s, box-shadow 0.3s;
  position: relative; /* importante */
  overflow: visible; /* antes estava hidden */
  z-index: 1;
}
/* glow only when the card is actually visible in the carousel window */
.carousel-in-view .nave-card {
  box-shadow: 0 0 20px #0ff5;
}
.carousel-in-view .vip-nave-card {
  box-shadow: 0 0 20px rgba(255,215,0,0.3);
}
.nave-card {
  transform-origin: bottom center;
}
.nave-card:hover {
  transform: scale(1.06);
}
.nave-card:hover {
  z-index: 10;
  position: relative;
}
/* Lock carousel cards once all 3 preview slots are filled */
#naveCarouselTrack.carousel-all-selected .nave-card-slot {
  pointer-events: none;
  opacity: 0.45;
  filter: grayscale(30%);
  transition: opacity 0.2s, filter 0.2s;
}


.nave-img {
  width: 170px;
  margin-top: -70px; /* Subida sutil */
  margin-bottom: 12px;
  transition: transform 0.3s ease;
  z-index: 5;
  position: relative;
}

.nave-card:hover > .nave-img {
  transform: scale(1.12);
}




.bar-label {
  font-family: 'Orbitron', sans-serif;
  color: #fff;
  margin-top: 6px;
  font-size: 14px;
  letter-spacing: 1px;
}
.bar-container {
  background: rgba(255,255,255,0.08);
  border-radius: 6px;
  height: 10px;
  margin: 4px 0 12px;
  overflow: hidden;
}
.bar {
  height: 100%;
  background: linear-gradient(to right, #0ff, #14ffff);
}

/* â”€â”€ Ship Selection Carousel â”€â”€ */
#naveCarouselViewport {
  overflow-x: clip;
  overflow-y: visible;
  width: 730px;
  max-width: calc(100vw - 120px);
  padding: 0 18px;       /* breathing room for edge-card hover scale */
  box-sizing: content-box;
}
#naveCarouselTrack {
  display: flex;
  gap: 20px;
  transition: transform 0.35s cubic-bezier(0.4, 0, 0.2, 1);
  will-change: transform;
  padding-top: 80px;  /* room for nave-img negative margin */
  margin-top: -80px;  /* keep layout height the same */
}
.nave-card-slot {
  flex-shrink: 0;
  width: 230px;
}
.nave-card-slot .nave-card {
  width: 100%;
  box-sizing: border-box;
}
.carousel-arrow-btn {
  background: rgba(0,229,255,0.08);
  border: 2px solid rgba(0,229,255,0.4);
  color: #00E5FF;
  font-size: 26px;
  width: 52px;
  height: 52px;
  border-radius: 50%;
  cursor: pointer;
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background 0.2s, opacity 0.2s;
  font-family: sans-serif;
  line-height: 1;
  position: relative;
  z-index: 20;       /* always above cards */
}
.carousel-arrow-btn:hover {
  background: rgba(0,229,255,0.22);
}

@keyframes vipNaveShake {
  0%,100% { transform: translateX(0); }
  20%      { transform: translateX(-6px); }
  40%      { transform: translateX(6px); }
  60%      { transform: translateX(-4px); }
  80%      { transform: translateX(4px); }
}
.vip-nave-shake {
  animation: vipNaveShake 0.4s ease;
}
.vip-locked-tip {
  position: absolute;
  bottom: -32px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.85);
  border: 1px solid #FFD700;
  color: #FFD700;
  font-family: 'Orbitron', sans-serif;
  font-size: 11px;
  font-weight: 700;
  padding: 5px 12px;
  border-radius: 8px;
  white-space: nowrap;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.3s;
  z-index: 30;
}

.remove-icon {
  position: absolute;
  top: -10px;
  right: -10px;
  background: #0ff;
  color: #000;
  border-radius: 50%;
  width: 22px;
  height: 22px;
  text-align: center;
  line-height: 22px;
  font-size: 14px;
  font-weight: bold;
  cursor: pointer;
  display: none;
  box-shadow: 0 0 8px #0ff8;
}
#previewArea div img:not([src*="placeholder"]) + .remove-icon {
  display: block;
}

.nave-description {
  margin-top: 14px;
  color: #0ff;
  font-family: 'Orbitron', sans-serif;
  font-size: 14px;
  line-height: 1.4;
  opacity: 0;
  max-height: 0;
  overflow: hidden;
  transition: opacity 0.4s ease, max-height 0.4s ease;
}

.nave-description {
  pointer-events: none;
}

.vip-nave-card .nave-description {
  color: #FFD700;
}

.nave-card:hover .nave-description {
  opacity: 1;
  max-height: 120px;
  pointer-events: auto;
  position: relative;
  z-index: 2;
}

#loadingScreen {
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  background: #000;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 5000;
}

#loadingLogo {
  width: 340px;
  filter: drop-shadow(0 0 12px #0ff);
  margin-bottom: 32px;
}

#loadingBarWrapper {
  width: 60vw;
  max-width: 480px;
  height: 16px;
  background: #022b35;
  border: 1px solid #0ff4;
  border-radius: 20px;
  overflow: hidden;
  box-shadow: 0 0 20px #0ff3;
}

#loadingBar {
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg, #07d8ff, #005ea8);
  box-shadow: 0 0 12px #0ff;
  transition: width 0.2s ease-out;
}

#matchmakingScreen {
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  background: rgba(0, 0, 0, 0.85);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 3000;
  font-family: 'Orbitron', sans-serif;
  color: #0ff;
  backdrop-filter: blur(12px) brightness(1.3);
}

#matchmakingBox {
  background: rgba(0, 20, 30, 0.3);
  border: 2px solid #00a5f2;
  border-radius: 20px;
  padding: 40px 50px;
  box-shadow: 0 0 24px #0ff6;
  text-align: center;
  animation: pulse 2s infinite ease-in-out;
}

#searchStatus {
  font-size: 28px;
  margin-bottom: 32px;
  text-shadow: 0 0 8px #0ff8;
}

#rollingNames {
  font-size: 24px;
  color: #14ffff;
  opacity: 0.8;
  animation: scrollNames 3s linear infinite;
  white-space: nowrap;
  overflow: hidden;
  width: 320px;
  text-overflow: ellipsis;
  text-align: center;
}

@keyframes scrollNames {
  0% { transform: translateX(100%); }
  100% { transform: translateX(-100%); }
}

@keyframes pulse {
  0%, 100% {
    box-shadow: 0 0 20px #0ff2, 0 0 40px #0ff4 inset;
  }
  50% {
    box-shadow: 0 0 40px #14ffff, 0 0 60px #14ffff inset;
  }
}

@keyframes blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.3; }
}

@keyframes slideNames {
  0% { transform: translateX(100%); }
  100% { transform: translateX(-100%); }
}

#multiplayerBtn {
  padding: 12px 24px;
  font-size: 16px;
  margin-top: 14px;
  background: #021d33;
  color: #0ff;
  border: 2px solid #0ff6;
  cursor: pointer;
  border-radius: 12px;
  transition: 0.3s;
}
#multiplayerBtn:hover {
  background: #0ff2;
}


.mode-btn {
  padding: 12px 30px;
  font-family: 'Orbitron', sans-serif;
  font-size: 16px;
  border-radius: 10px;
  border: none;
  margin: 10px 0;
  box-shadow: 0 0 20px #0ff5;
  transition: background 0.3s, color 0.3s;
  width: 240px;
  text-align: center;
}
.mode-btn:disabled {
  background: #222;
  color: #666;
  border: 2px solid #444;
  cursor: not-allowed;
  box-shadow: 0 0 12px #0004;
}
#practiceBtn.mode-btn {
  background: linear-gradient(90deg, #07d8ff, #005ea8);
  color: #0ff;
}
#multiplayerBtn.mode-btn {
  background: linear-gradient(90deg, #ff0a94, #5f00ff);
  color: #0ff;
}

.match-vs-box {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 40px;
  height: 100vh;
  font-family: 'Orbitron', sans-serif;
  background: rgba(0,0,0,0.88);
  backdrop-filter: blur(16px);
}

.player-box, .opponent-box {
  width: 240px;
  height: 200px;
  padding: 20px;
  border-radius: 20px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  position: relative;
}

.player-box {
  background: linear-gradient(90deg, #002244, #005ea8);
  box-shadow: 0 0 16px #0ff8;
}

.opponent-box {
  background: linear-gradient(90deg, #440000, #880022);
  box-shadow: 0 0 16px #ff3866;
}

.team-label {
  color: #0ff;
  font-size: 18px;
  margin-bottom: 12px;
  text-shadow: 0 0 8px #0ff8;
}

.team-label.red {
  color: #ff5b6e;
  text-shadow: 0 0 8px #ff3866;
}

.team-score {
  font-size: 42px;
  font-weight: bold;
  color: #fff;
  text-shadow: 0 0 16px #0ff;
}

.slot-wrapper {
  width: 160px;
  height: 42px;
  overflow: hidden;
  position: relative;
  border: 2px solid #ff3866;
  border-radius: 8px;
  background: rgba(0,0,0,0.3);
}

.slot-names {
  display: flex;
  flex-direction: column;
  animation: spinNames 2s ease-in-out infinite;
}

.slot-names div {
  height: 42px;
  line-height: 42px;
  font-size: 22px;
  color: #fff;
  text-align: center;
}


@keyframes spinNames {
  0% { transform: translateY(0); }
  100% { transform: translateY(-294px); } /* 7 passos Ã— 42px = 294px */
}


.match-container {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 40px;
  background: rgba(0, 0, 0, 0.6);
  padding: 40px;
  border-radius: 20px;
  box-shadow: 0 0 40px #0ff4;
  z-index: 9999;
}

.player-slot {
  display: flex;
  flex-direction: column;
  align-items: center;
  min-width: 180px;
  padding: 24px;
  border-radius: 12px;
  font-family: 'Orbitron', sans-serif;
  text-align: center;
  box-shadow: 0 0 20px #0ff4;
}

.player1 {
  background: linear-gradient(90deg, #0ff, #0044ff);
  color: #000;
}

.player2 {
  background: linear-gradient(90deg, #ff0033, #8f0022);
  color: #fff;
}

.player-title {
  font-size: 18px;
  margin-bottom: 12px;
  text-shadow: 0 0 4px #000;
}

.player-name,
.opponent-names {
  font-size: 24px;
  height: 32px;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
}

.opponent-names > div {
  animation: spinNames 2s linear infinite;
}

@keyframes spinNames {
  0% { transform: translateY(0); }
  100% { transform: translateY(-100%); }
}

.vs-text {
  font-size: 40px;
  font-weight: bold;
  color: #fff;
  text-shadow: 0 0 10px #0ff, 0 0 20px #0ff;
}

.user-header-name,
.player-name,
#userHeaderName,
#playerSlot,
.opponent-names,
.slot-name,
.score-board
{
  text-transform: uppercase;
}

#userHeader {
    display: none;
    position: fixed;
    top: 20px;
    right: 12px;
    z-index: 9000;
    align-items: center;
    gap: 13px;
    background: rgba(12, 26, 48, 0.3);
    border-radius: 93px;
    box-shadow: 0 2px 65px #0ff6;
    padding: 10px 30px 10px 16px;
    font-family: 'Orbitron', sans-serif;
    font-size: 15px;
}

.user-header-ship {
  width: 36px;
  height: auto;
  margin-right: 7px;
}

.user-header-name {
  color: #0ff;
  font-weight: bold;
  text-transform: uppercase; /* MantÃ©m sempre em maiÃºsculo */
}

#modeSelectionScreen {
    position: fixed;
    flex-direction: column;
    justify-content: center;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: transparent;
    align-items: center;
    z-index: 99999;
}

/* ===== END SCORE (HEX GRID) ===== */
.end-content{
  position: relative;
  z-index: 2;
  width: 100%;
  height: 100%;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  padding-top: 0;
  gap: 35px;
}

.end-emblem{
  margin-top: 1vh;
  font-family: 'Orbitron', sans-serif;
  font-weight: 800;
  letter-spacing: 3px;
  font-size: 22px;
  color: #ffd34f;
  text-shadow: 0 0 20px rgba(255,211,79,.35);
}
.end-emblem.defeat{ color:#ff6b6b; text-shadow:0 0 20px rgba(255,107,107,.35); }
.end-emblem.draw{ color:#c7d2ff; text-shadow:0 0 20px rgba(199,210,255,.35); }

.score-board.big{
  margin-top: 0;
  font-size: 24px;
  color:#14ffff;
  text-shadow: 0 0 18px rgba(20,255,255,.55), 0 8px 20px rgba(0,0,0,.55);
  letter-spacing: 10px;
}

/* Grid dos hexÃ¡gonos (3 em cima, 3 embaixo) */
.score-grid{
  margin-top: 38px;
  display:grid;
  grid-template-columns: repeat(3, 137px);
  gap: 20px 22px;
  align-items:center;
  justify-content:center;
}

/* Hex shape */
.score-hex{
  width:137px;
  height:110px;
  position:relative;
  clip-path: polygon(25% 6%, 75% 6%, 98% 50%, 75% 94%, 25% 94%, 2% 50%);
  background: rgba(0,0,0,.30);
  border: 2px solid rgba(255,255,255,.10);
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  text-align:center;
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  box-shadow: 0 0 0 rgba(0,0,0,0);
}

.score-hex .hex-outline{
  position:absolute;
  inset: -2px;
  clip-path: polygon(25% 6%, 75% 6%, 98% 50%, 75% 94%, 25% 94%, 2% 50%);
  border: 2px solid rgba(255,255,255,.10);
  pointer-events:none;
}

.score-hex.active{
  border-color: rgba(20,255,255,.55);
  box-shadow: 0 0 28px rgba(20,255,255,.25);
}
.score-hex.active .hex-outline{
  border-color: rgba(20,255,255,.75);
  box-shadow: 0 0 26px rgba(20,255,255,.22) inset;
}

.score-hex.inactive{
  opacity:.38;
  filter: saturate(.75);
}

.hex-title{
  font-family:'Orbitron', sans-serif;
  font-size: 10px;
  line-height: 1.2;
  letter-spacing: 0.5px;
  color: rgba(255,255,255,.85);
  margin: 0 9px 5px 9px;
  text-shadow: 0 0 12px rgba(0,0,0,.55);
}

.hex-points{
  font-family:'Orbitron', sans-serif;
  font-size: 28px;
  letter-spacing: 1px;
  color:#ffffff;
  text-shadow: 0 0 18px rgba(20,255,255,.25);
}

.score-total{
  margin-top: 0;
  font-family:'Orbitron', sans-serif;
  font-size: 34px;
  letter-spacing: 3px;
  color:#14ffff;
  text-shadow: 0 0 18px rgba(20,255,255,.55);
}

.user-header-pts{
  margin-left: 10px;
  color:#14ffff;
  font-weight:700;
  letter-spacing:1px;
  text-shadow:0 0 12px rgba(20,255,255,.55);
}

.user-logout-btn {
  margin-left: 12px;
  background: transparent;
  border: 1px solid rgba(255,77,77,.85);
  color: #ff4d4d;
  padding: 6px 12px;
  border-radius: 18px;
  font-family: 'Orbitron', sans-serif;
  font-size: 13px;
  cursor: pointer;
  box-shadow: 0 0 12px rgba(255,77,77,.18);
  text-transform: uppercase;
}
.user-logout-btn:hover {
  box-shadow: 0 0 18px rgba(255,77,77,.35);
}

.shot-type-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(0,229,255,0.5) !important;
  border-color: #00E5FF !important;
}


    </style>
    <link href="https://fonts.googleapis.com/css?family=Orbitron:wght@700" rel="stylesheet" />
  
  <!-- Banner central de round -->
  <div id="roundBanner" style="
    display: none;
    position: fixed;
    top: 0; left: 0; width: 100vw; height: 100vh;
    z-index: 20000;
    align-items: center; justify-content: center;
    pointer-events: none;
  ">
    <div style="
      margin: auto;
      font-family: 'Orbitron', sans-serif;
      font-size: 54px;
      color: #FFD34F;
      text-shadow: 0 0 32px #0ffb, 0 0 18px #FFD700, 0 0 8px #000;
      background: rgba(0,0,0,0.72);
      border-radius: 24px;
      padding: 38px 64px;
      box-shadow: 0 0 44px #FFD70044;
      letter-spacing: 2.5px;
      text-align: center;
      min-width: 340px;
      max-width: 90vw;
      user-select: none;
    " id="roundBannerText"></div>
  </div>


</head>
<body>
    <!-- Header removed: parent app renders a single UserHeader in the protected layout -->

  <!-- ðŸŒŒ FUNDO DA GALÃXIA (sempre no topo e no fundo visual) -->
  <div id="galaxyBg"></div>

  <!-- â³ TELA DE LOADING -->
  <div id="loadingScreen" style="display:flex;">
    <img src="images/thorspace.png" id="loadingLogo" alt="Logo" />
    <div id="loadingBarWrapper">
      <div id="loadingBar"></div>
    </div>
  </div>

  <!-- ðŸ” TELA DE LOGIN -->
  <div id="startContainer" style="display:none;">
    <img id="thorspace-logo" src="images/thorspace.png" alt="ThorSpace Logo" />
    
    <div id="startModal">
      <div class="modal-content">
        <label for="playerNameInput">Enter your name:</label>
        <input type="text" id="playerNameInput" maxlength="16" autocomplete="off" />
        <button id="startBtn">Login</button>
      </div>
    </div>
  </div> <!-- âœ… AQUI FECHA o startContainer -->

  <!-- ðŸŽ® TELA DE MODOS DE JOGO â€“ FORA do startContainer -->
  <div id="modeSelectionScreen" style="display:none;">
    <h2 style="font-family:'Orbitron',sans-serif; color:#0ff; font-size:32px; text-shadow:0 0 16px #0ff9; margin-bottom:50px;">Escolha o modo de jogo</h2>

    <div style="display: flex; flex-direction: column; align-items: center; gap: 20px;">
    <button id="practiceBtn" class="mode-btn">Praticar</button>
    <button id="multiplayerBtn" class="mode-btn">Multiplayer</button>
    <button id="campaignBtn" class="mode-btn" disabled>Modo Campanha</button>

    </div>
  </div>

<div id="matchmakingScreen" style="display: none;">
  <div class="match-container">
    <div class="player-slot player1">
      <div class="player-name" id="playerSlot">Player 1</div>
    </div>
    <div class="vs-text">VS</div>
    <div class="player-slot player2">
      <div class="opponent-names" id="opponentNames"></div>
    </div>
  </div>
  <!-- Legenda dinÃ¢mica -->
  <div id="matchLegend" style="margin-top:32px; font-family:'Orbitron',sans-serif; color:#0ff; font-size:1.4em; letter-spacing:1.5px; text-align:center; text-shadow:0 0 12px #00e7ffb9;"></div>
</div>



<!-- Tela de VitÃ³ria -->
<div id="victoryScreen" class="end-screen" style="display: none;">
  <img src="images/bg_victory.png" class="bg-full" alt="Victory Background">
  <div class="end-content">
    <div class="end-emblem" id="victoryText">VICTORY</div>

    <div class="score-board big"></div>

    <div class="score-details"></div>

    <div class="score-total"></div>

    <button id="restartVictory" class="end-btn">Return to Lobby</button>
  </div>
</div>

<!-- Tela de Derrota -->
<div id="defeatScreen" class="end-screen" style="display: none;">
  <img src="images/bg_defeat.png" class="bg-full" alt="Defeat Background">
  <div class="end-content">
    <div class="end-emblem defeat" id="defeatText">DEFEAT</div>

    <div class="score-board big"></div>

    <div class="score-details"></div>

    <div class="score-total"></div>

    <button id="restartDefeat" class="end-btn">Return to Lobby</button>
  </div>
</div>

<!-- Tela de Empate -->
<div id="drawScreen" class="end-screen" style="display: none;">
  <img src="images/bg_draw.png" class="bg-full" alt="Draw Background">
  <div class="end-content">
    <div class="end-emblem draw" id="drawText">DRAW</div>

    <div class="score-board big"></div>

    <div class="score-details"></div>

    <div class="score-total"></div>

    <button id="restartDraw" class="end-btn">Return to Lobby</button>
  </div>
</div>



<!-- HUD Superior: Timer e Legenda -->
<div id="gameWrapper">
 <div style="display: flex; flex-direction: column; align-items: center; gap: 0;">
  
  <!-- HUD row wrapper: hudTop + mute button side by side, button always visible -->
  <div style="position: relative; width: 800px; margin: 0 auto 8px; flex-shrink: 0;">
    <div id="hudTop" style="width: 800px; margin: 0; position: relative; z-index: 3; user-select:none; display: flex; visibility: hidden; opacity: 0;">
      <div id="hudLine" style="display: flex; flex-direction: row; align-items: center; width: 100%;">
        <div id="timerArea">
          <span id="timerText">10</span>
        </div>
        <div id="legendArea"></div>
      </div>
    </div>
    <!-- Mute button: outside hudTop so never hidden with it -->
    <button id="bgm-mute-btn" title="Mute / Unmute" onclick="toggleBgmMute()">
      <svg id="bgm-icon-on" xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="#00e5ff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>
        <path d="M15.54 8.46a5 5 0 0 1 0 7.07"/>
        <path d="M19.07 4.93a10 10 0 0 1 0 14.14"/>
      </svg>
      <svg id="bgm-icon-off" xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="#ff3a34" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display:none">
        <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>
        <line x1="23" y1="9" x2="17" y2="15"/>
        <line x1="17" y1="9" x2="23" y2="15"/>
      </svg>
    </button>
  </div>
  <div id="shipTypeArea"
    style="width:800px; margin-top:10px; text-align:center; color:#fff; font-family:'Orbitron',sans-serif; font-size:18px; letter-spacing:1px; text-shadow:0 0 9px #0ff8;">
  </div>
    
  </div>
  
  <div style="position: relative; width: 800px; height: 600px;">
   <canvas id="gameCanvas" width="800" height="600"
     style="display: none; clip-path: polygon(24px 0%, 776px 0%, 800px 24px, 800px 576px, 776px 600px, 24px 600px, 0px 576px, 0px 24px);"></canvas>
   
   <!-- Frame decorativo do jogo -->
   <img id="gameContour" src="/game/images/frame_game.png" width="1120" height="750" style="position: absolute; top: -120px; left: -40px; pointer-events: none; visibility: hidden; user-select: none;" alt="" draggable="false" />
  </div>

  <!-- Banner de Matchup (apenas em multiplayer) -->
  <div id="matchupBanner" style="display: none; width: 100%; max-width: 800px; margin-top: 16px; padding: 12px 24px; border-radius: 12px; text-align: center; font-family: 'Orbitron', sans-serif; backdrop-filter: blur(10px);">
    <div style="display: flex; align-items: center; justify-content: center; gap: 16px;">
      <span id="playerNameDisplay" style="font-size: 18px; font-weight: 700; color: #00E5FF; text-shadow: 0 0 10px rgba(0, 229, 255, 0.6); letter-spacing: 1px;">Player</span>
      <span style="font-size: 14px; font-weight: 400; color: rgba(255, 255, 255, 0.5); text-transform: lowercase; letter-spacing: 2px;">vs</span>
      <span id="opponentNameDisplay" style="font-size: 18px; font-weight: 700; color: #FF4444; text-shadow: 0 0 10px rgba(255, 68, 68, 0.6); letter-spacing: 1px;">Opponent</span>
    </div>
  </div>
 </div>
</div>




<!-- Sons -->
<audio id="sfx-hit" src="sounds/sfx-hit.mp3"></audio>
<audio id="sfx-hit2" src="sounds/sfx-hit2.mp3"></audio>
<audio id="sfx-shot" src="sounds/sfx-shot.mp3"></audio>
<audio id="sfx-explode" src="sounds/sfx-explode.mp3"></audio>
<audio id="sfx-winner" src="sounds/sfx-winner.mp3"></audio>
<audio id="sfx-loss" src="sounds/sfx-loss.mp3"></audio>
<audio id="bgm-battle" loop></audio>



<!-- Tela de SeleÃ§Ã£o de Naves -->
<div id="naveSelectScreen" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0); backdrop-filter: blur(0px); z-index:3000; flex-direction:column; align-items:center; justify-content:center;">

  <!-- ===== Tutorial Modal: shown on first visit per session ===== -->
  <div id="shipSelectTutorial" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.55); z-index:4000; align-items:center; justify-content:center; padding:20px;">
    <div style="max-width:420px; width:100%; background:rgba(0,0,20,0.97); border:1px solid rgba(0,229,255,0.4); border-radius:20px; padding:36px 32px; text-align:center; box-shadow:0 0 40px rgba(0,229,255,0.15);">
      <div style="margin-bottom:16px;">
        <img src="images/spaceschip.png" style="width:64px; height:auto; filter:drop-shadow(0 0 12px rgba(0,229,255,0.55));">
      </div>
      <h2 style="margin:0 0 14px; color:#00E5FF; font-family:'Orbitron',sans-serif; font-size:20px; letter-spacing:1px; text-transform:uppercase;">Monte sua Esquadrilha</h2>
      <p style="margin:0 0 10px; color:#ccc; font-size:15px; line-height:1.7; font-family:sans-serif;">VocÃª precisa escolher <strong style="color:#00E5FF;">3 naves</strong> para entrar na batalha.</p>
      <p style="margin:0 0 28px; color:#aaa; font-size:13px; line-height:1.6; font-family:sans-serif;">Clique nas naves que deseja adicionar Ã  sua esquadrilha. Para remover uma nave, clique no preview acima.</p>
      <button onclick="closeShipTutorial();" style="padding:14px 44px; border-radius:10px; background:transparent; border:2px solid #00E5FF; color:#00E5FF; font-size:16px; font-weight:700; font-family:'Orbitron',sans-serif; cursor:pointer; letter-spacing:1px;">Entendi!</button>
    </div>
  </div>
  <!-- ============================================================ -->

  <!-- Squad header: title + subtitle -->
  <div style="text-align:center; margin-bottom:18px;">
    <div style="font-family:'Orbitron',sans-serif; font-size:15px; color:#00E5FF; letter-spacing:3px; font-weight:700;">FORMAÃ‡ÃƒO DE ESQUADRÃƒO</div>
    <div style="font-size:13px; color:#777; margin-top:5px; font-family:sans-serif;">Escolha 3 naves para o campo de batalha.</div>
  </div>

  <div id="previewArea" style="display:flex; gap:38px; justify-content:center; align-items:center; margin-bottom:50px;">
    <div style="position:relative;" onclick="removeNave(0)">
      <img id="preview1" src="images/placeholder_nave.png" alt="PosiÃ§Ã£o 1" style="width:90px; height:auto; opacity:0.4; transition:opacity 0.3s;">
      <span class="remove-icon">âœ•</span>
      <img id="shotIcon1" src="images/shots/plasma.png" style="position:absolute; bottom:4px; left:4px; width:18px; height:18px; opacity:0; transition:opacity 0.3s; pointer-events:none; filter: drop-shadow(0 0 3px rgba(0,229,255,0.6));">
    </div>
    <div style="position:relative;" onclick="removeNave(1)">
      <img id="preview2" src="images/placeholder_nave.png" alt="PosiÃ§Ã£o 2" style="width:90px; height:auto; opacity:0.4; transition:opacity 0.3s;">
      <span class="remove-icon">âœ•</span>
      <img id="shotIcon2" src="images/shots/plasma.png" style="position:absolute; bottom:4px; left:4px; width:18px; height:18px; opacity:0; transition:opacity 0.3s; pointer-events:none; filter: drop-shadow(0 0 3px rgba(0,229,255,0.6));">
    </div>
    <div style="position:relative;" onclick="removeNave(2)">
      <img id="preview3" src="images/placeholder_nave.png" alt="PosiÃ§Ã£o 3" style="width:90px; height:auto; opacity:0.4; transition:opacity 0.3s;">
      <span class="remove-icon">âœ•</span>
      <img id="shotIcon3" src="images/shots/plasma.png" style="position:absolute; bottom:4px; left:4px; width:18px; height:18px; opacity:0; transition:opacity 0.3s; pointer-events:none; filter: drop-shadow(0 0 3px rgba(0,229,255,0.6));">
    </div>
    <!-- Help button: re-open tutorial -->
    <button onclick="openShipTutorial();" title="Como funciona?" style="margin-left:16px; width:30px; height:30px; border-radius:50%; background:transparent; border:2px solid rgba(0,229,255,0.45); color:#00E5FF; font-family:'Orbitron',sans-serif; font-size:13px; font-weight:700; cursor:pointer; display:flex; align-items:center; justify-content:center; flex-shrink:0; transition:border-color 0.2s;">?</button>
  </div>
  <!-- Ship Selection Carousel -->
  <div id="naveCarouselOuter" style="display:flex; align-items:center; justify-content:center; gap:28px; width:100%; margin-bottom:16px;">
    <button id="carouselPrevBtn" onclick="naveCarouselMove(-1)" class="carousel-arrow-btn">&#8592;</button>

    <div id="naveCarouselViewport">
      <div id="naveCarouselTrack">

        <!-- Slot 1: Maya V1 (Alcance) -->
        <div class="nave-card-slot">
          <div class="nave-card" data-nave="1">
            <img src="images/nave_alcance.png" class="nave-img" alt="Nave 1">
            <div class="bar-label ship-label-range">Alcance</div>
            <div class="bar-container"><div class="bar" style="width: 95%;"></div></div>
            <div class="bar-label ship-label-protection">ProteÃ§Ã£o</div>
            <div class="bar-container"><div class="bar" style="width: 33%;"></div></div>
            <div class="nave-description">
              <strong>Maya V1</strong><br>
              <span class="ship-desc-text" data-ship="1">Especialista em ataques de longa distÃ¢ncia. Ideal para surpreender inimigos fora do alcance deles.</span>
            </div>

          </div>
        </div>

        <!-- Slot 2: Aegis JK-05 (ProteÃ§Ã£o) -->
        <div class="nave-card-slot">
          <div class="nave-card" data-nave="2">
            <img src="images/nave_protecao.png" class="nave-img" alt="Nave 2">
            <div class="bar-label ship-label-range">Alcance</div>
            <div class="bar-container"><div class="bar" style="width: 45%;"></div></div>
            <div class="bar-label ship-label-protection">ProteÃ§Ã£o</div>
            <div class="bar-container"><div class="bar" style="width: 95%;"></div></div>
            <div class="nave-description">
              <strong>Aegis JK-05</strong><br>
              <span class="ship-desc-text" data-ship="2">Blindagem reforÃ§ada e resistÃªncia extrema. Perfeita para absorver dano e proteger sua frota.</span>
            </div>

          </div>
        </div>

        <!-- Slot 3: Orion-7 (Normal) -->
        <div class="nave-card-slot">
          <div class="nave-card" data-nave="3">
            <img src="images/spaceschip.png" class="nave-img" alt="Nave 3">
            <div class="bar-label ship-label-range">Alcance</div>
            <div class="bar-container"><div class="bar" style="width: 75%;"></div></div>
            <div class="bar-label ship-label-protection">ProteÃ§Ã£o</div>
            <div class="bar-container"><div class="bar" style="width: 75%;"></div></div>
            <div class="nave-description">
              <strong>Orion-7</strong><br>
              <span class="ship-desc-text" data-ship="3">EquilÃ­brio entre mobilidade e defesa. VersÃ¡til em qualquer situaÃ§Ã£o de combate.</span>
            </div>

          </div>
        </div>

        <!-- Slot 4: Phoenix VIP (Vermelha) - P2 only -->
        <div class="nave-card-slot" id="naveSlot4">
          <div class="nave-card vip-nave-card" data-nave="4" style="border-color: #FFD700;">
            <div class="vip-nave-badge" style="display:none; position:absolute; top:10px; right:10px; font-size:9px; font-weight:900; padding:2px 7px; border-radius:20px; background:rgba(255,215,0,0.18); border:1px solid rgba(255,215,0,0.55); color:#FFD700; font-family:'Orbitron',sans-serif; letter-spacing:1px; z-index:6;">ðŸ’Ž VIP</div>
            <div class="vip-nave-lock" style="display:none; position:absolute; inset:0; border-radius:18px; background:rgba(0,0,0,0.65); z-index:5; flex-direction:column; align-items:center; justify-content:center; gap:8px; pointer-events:none;">
              <svg width="32" height="32" viewBox="0 0 24 24" fill="none"><rect x="5" y="11" width="14" height="10" rx="2" stroke="#FFD700" stroke-width="2"/><path d="M8 11V7a4 4 0 118 0v4" stroke="#FFD700" stroke-width="2" stroke-linecap="round"/></svg>
              <span style="font-size:10px; font-weight:900; color:#FFD700; font-family:'Orbitron',sans-serif; letter-spacing:1px;">ðŸ’Ž EXCLUSIVO VIP</span>
            </div>
            <img src="images/nave_alcance_red_vip.png" class="nave-img" alt="Phoenix VIP">
            <div class="bar-label ship-label-range">Alcance</div>
            <div class="bar-container"><div class="bar" style="width: 95%; background: linear-gradient(to right, #ff8c00, #ffd700);"></div></div>
            <div class="bar-label ship-label-protection">ProteÃ§Ã£o</div>
            <div class="bar-container"><div class="bar" style="width: 33%; background: linear-gradient(to right, #ff8c00, #ffd700);"></div></div>
            <div class="nave-description">
              <strong>Phoenix VIP</strong><br>
              <span>Nave VIP exclusiva. Alcance devastador.</span>
            </div>

          </div>
        </div>

        <!-- Slot 5: Maya VIP (Azul) - P1 + solo only -->
        <div class="nave-card-slot" id="naveSlot5">
          <div class="nave-card vip-nave-card" data-nave="5" style="border-color: #FFD700;">
            <div class="vip-nave-badge" style="display:none; position:absolute; top:10px; right:10px; font-size:9px; font-weight:900; padding:2px 7px; border-radius:20px; background:rgba(255,215,0,0.18); border:1px solid rgba(255,215,0,0.55); color:#FFD700; font-family:'Orbitron',sans-serif; letter-spacing:1px; z-index:6;">ðŸ’Ž VIP</div>
            <div class="vip-nave-lock" style="display:none; position:absolute; inset:0; border-radius:18px; background:rgba(0,0,0,0.65); z-index:5; flex-direction:column; align-items:center; justify-content:center; gap:8px; pointer-events:none;">
              <svg width="32" height="32" viewBox="0 0 24 24" fill="none"><rect x="5" y="11" width="14" height="10" rx="2" stroke="#FFD700" stroke-width="2"/><path d="M8 11V7a4 4 0 118 0v4" stroke="#FFD700" stroke-width="2" stroke-linecap="round"/></svg>
              <span style="font-size:10px; font-weight:900; color:#FFD700; font-family:'Orbitron',sans-serif; letter-spacing:1px;">ðŸ’Ž EXCLUSIVO VIP</span>
            </div>
            <img src="images/nave_alcance_vip.png" class="nave-img" alt="Maya VIP">
            <div class="bar-label ship-label-range">Alcance</div>
            <div class="bar-container"><div class="bar" style="width: 95%; background: linear-gradient(to right, #ff8c00, #ffd700);"></div></div>
            <div class="bar-label ship-label-protection">ProteÃ§Ã£o</div>
            <div class="bar-container"><div class="bar" style="width: 33%; background: linear-gradient(to right, #ff8c00, #ffd700);"></div></div>
            <div class="nave-description">
              <strong>Maya VIP</strong><br>
              <span>Nave VIP exclusiva. Alcance mÃ¡ximo.</span>
            </div>

          </div>
        </div>

        <!-- Slot 6: Vanguard VIP (ProteÃ§Ã£o Azul) - P1 + solo only -->
        <div class="nave-card-slot" id="naveSlot6">
          <div class="nave-card vip-nave-card" data-nave="6" style="border-color: #FFD700;">
            <div class="vip-nave-badge" style="display:none; position:absolute; top:10px; right:10px; font-size:9px; font-weight:900; padding:2px 7px; border-radius:20px; background:rgba(255,215,0,0.18); border:1px solid rgba(255,215,0,0.55); color:#FFD700; font-family:'Orbitron',sans-serif; letter-spacing:1px; z-index:6;">ðŸ’Ž VIP</div>
            <div class="vip-nave-lock" style="display:none; position:absolute; inset:0; border-radius:18px; background:rgba(0,0,0,0.65); z-index:5; flex-direction:column; align-items:center; justify-content:center; gap:8px; pointer-events:none;">
              <svg width="32" height="32" viewBox="0 0 24 24" fill="none"><rect x="5" y="11" width="14" height="10" rx="2" stroke="#FFD700" stroke-width="2"/><path d="M8 11V7a4 4 0 118 0v4" stroke="#FFD700" stroke-width="2" stroke-linecap="round"/></svg>
              <span style="font-size:10px; font-weight:900; color:#FFD700; font-family:'Orbitron',sans-serif; letter-spacing:1px;">ðŸ’Ž EXCLUSIVO VIP</span>
            </div>
            <img src="images/nave_protecao_vip.png" class="nave-img" alt="Vanguard VIP">
            <div class="bar-label ship-label-range">Alcance</div>
            <div class="bar-container"><div class="bar" style="width: 30%; background: linear-gradient(to right, #ff8c00, #ffd700);"></div></div>
            <div class="bar-label ship-label-protection">ProteÃ§Ã£o</div>
            <div class="bar-container"><div class="bar" style="width: 90%; background: linear-gradient(to right, #ff8c00, #ffd700);"></div></div>
            <div class="nave-description">
              <strong>Vanguard VIP</strong><br>
              <span>Nave VIP exclusiva. ProteÃ§Ã£o mÃ¡xima.</span>
            </div>

          </div>
        </div>

        <!-- Slot 7: Vanguard VIP (ProteÃ§Ã£o Vermelha) - P2 only -->
        <div class="nave-card-slot" id="naveSlot7">
          <div class="nave-card vip-nave-card" data-nave="7" style="border-color: #FFD700;">
            <div class="vip-nave-badge" style="display:none; position:absolute; top:10px; right:10px; font-size:9px; font-weight:900; padding:2px 7px; border-radius:20px; background:rgba(255,215,0,0.18); border:1px solid rgba(255,215,0,0.55); color:#FFD700; font-family:'Orbitron',sans-serif; letter-spacing:1px; z-index:6;">ðŸ’Ž VIP</div>
            <div class="vip-nave-lock" style="display:none; position:absolute; inset:0; border-radius:18px; background:rgba(0,0,0,0.65); z-index:5; flex-direction:column; align-items:center; justify-content:center; gap:8px; pointer-events:none;">
              <svg width="32" height="32" viewBox="0 0 24 24" fill="none"><rect x="5" y="11" width="14" height="10" rx="2" stroke="#FFD700" stroke-width="2"/><path d="M8 11V7a4 4 0 118 0v4" stroke="#FFD700" stroke-width="2" stroke-linecap="round"/></svg>
              <span style="font-size:10px; font-weight:900; color:#FFD700; font-family:'Orbitron',sans-serif; letter-spacing:1px;">ðŸ’Ž EXCLUSIVO VIP</span>
            </div>
            <img src="images/nave_protecao_red_vip.png" class="nave-img" alt="Vanguard VIP Red">
            <div class="bar-label ship-label-range">Alcance</div>
            <div class="bar-container"><div class="bar" style="width: 30%; background: linear-gradient(to right, #ff8c00, #ffd700);"></div></div>
            <div class="bar-label ship-label-protection">ProteÃ§Ã£o</div>
            <div class="bar-container"><div class="bar" style="width: 90%; background: linear-gradient(to right, #ff8c00, #ffd700);"></div></div>
            <div class="nave-description">
              <strong>Vanguard VIP</strong><br>
              <span>Nave VIP exclusiva. ProteÃ§Ã£o mÃ¡xima.</span>
            </div>

          </div>
        </div>

        <!-- Slot 8: Titan VIP (Normal Azul) - P1 + solo only -->
        <div class="nave-card-slot" id="naveSlot8">
          <div class="nave-card vip-nave-card" data-nave="8" style="border-color: #FFD700;">
            <div class="vip-nave-badge" style="display:none; position:absolute; top:10px; right:10px; font-size:9px; font-weight:900; padding:2px 7px; border-radius:20px; background:rgba(255,215,0,0.18); border:1px solid rgba(255,215,0,0.55); color:#FFD700; font-family:'Orbitron',sans-serif; letter-spacing:1px; z-index:6;">ðŸ’Ž VIP</div>
            <div class="vip-nave-lock" style="display:none; position:absolute; inset:0; border-radius:18px; background:rgba(0,0,0,0.65); z-index:5; flex-direction:column; align-items:center; justify-content:center; gap:8px; pointer-events:none;">
              <svg width="32" height="32" viewBox="0 0 24 24" fill="none"><rect x="5" y="11" width="14" height="10" rx="2" stroke="#FFD700" stroke-width="2"/><path d="M8 11V7a4 4 0 118 0v4" stroke="#FFD700" stroke-width="2" stroke-linecap="round"/></svg>
              <span style="font-size:10px; font-weight:900; color:#FFD700; font-family:'Orbitron',sans-serif; letter-spacing:1px;">ðŸ’Ž EXCLUSIVO VIP</span>
            </div>
            <img src="images/nave_normal_vip.png" class="nave-img" alt="Titan VIP">
            <div class="bar-label ship-label-range">Alcance</div>
            <div class="bar-container"><div class="bar" style="width: 65%; background: linear-gradient(to right, #ff8c00, #ffd700);"></div></div>
            <div class="bar-label ship-label-protection">ProteÃ§Ã£o</div>
            <div class="bar-container"><div class="bar" style="width: 55%; background: linear-gradient(to right, #ff8c00, #ffd700);"></div></div>
            <div class="nave-description">
              <strong>Titan VIP</strong><br>
              <span>Nave VIP exclusiva. EquilÃ­brio perfeito.</span>
            </div>

          </div>
        </div>

        <!-- Slot 9: Titan VIP (Normal Vermelho) - P2 only -->
        <div class="nave-card-slot" id="naveSlot9">
          <div class="nave-card vip-nave-card" data-nave="9" style="border-color: #FFD700;">
            <div class="vip-nave-badge" style="display:none; position:absolute; top:10px; right:10px; font-size:9px; font-weight:900; padding:2px 7px; border-radius:20px; background:rgba(255,215,0,0.18); border:1px solid rgba(255,215,0,0.55); color:#FFD700; font-family:'Orbitron',sans-serif; letter-spacing:1px; z-index:6;">ðŸ’Ž VIP</div>
            <div class="vip-nave-lock" style="display:none; position:absolute; inset:0; border-radius:18px; background:rgba(0,0,0,0.65); z-index:5; flex-direction:column; align-items:center; justify-content:center; gap:8px; pointer-events:none;">
              <svg width="32" height="32" viewBox="0 0 24 24" fill="none"><rect x="5" y="11" width="14" height="10" rx="2" stroke="#FFD700" stroke-width="2"/><path d="M8 11V7a4 4 0 118 0v4" stroke="#FFD700" stroke-width="2" stroke-linecap="round"/></svg>
              <span style="font-size:10px; font-weight:900; color:#FFD700; font-family:'Orbitron',sans-serif; letter-spacing:1px;">ðŸ’Ž EXCLUSIVO VIP</span>
            </div>
            <img src="images/nave_normal_red_vip.png" class="nave-img" alt="Titan VIP Red">
            <div class="bar-label ship-label-range">Alcance</div>
            <div class="bar-container"><div class="bar" style="width: 65%; background: linear-gradient(to right, #ff8c00, #ffd700);"></div></div>
            <div class="bar-label ship-label-protection">ProteÃ§Ã£o</div>
            <div class="bar-container"><div class="bar" style="width: 55%; background: linear-gradient(to right, #ff8c00, #ffd700);"></div></div>
            <div class="nave-description">
              <strong>Titan VIP</strong><br>
              <span>Nave VIP exclusiva. EquilÃ­brio perfeito.</span>
            </div>

          </div>
        </div>

      </div><!-- end #naveCarouselTrack -->
    </div><!-- end #naveCarouselViewport -->

    <button id="carouselNextBtn" onclick="naveCarouselMove(1)" class="carousel-arrow-btn">&#8594;</button>
  </div><!-- end #naveCarouselOuter -->

  <button id="startGameBtn" onclick="startGameAfterSelection()" style="display:none; margin-top:34px; background: linear-gradient(90deg, #07d8ff, #005ea8 70%); color: #fff; font-family: 'Orbitron', sans-serif; font-size: 22px; border: none; border-radius: 8px; padding: 10px 44px; letter-spacing: 2px; box-shadow: 0 0 20px #0ff5; cursor: pointer; transition: background 0.3s;">Iniciar Jogo</button>

  <!-- Timer de seleÃ§Ã£o multiplayer -->
  <div id="selectionTimerWrapper" style="display:flex; align-items:center; justify-content:center; gap:10px; margin-top:10px;">
    <span id="selectionTimerText" style="font-family:'Orbitron',sans-serif; font-size:22px; color:#FFB84D; min-width:32px; text-align:center; letter-spacing:1px; display:inline-block; visibility:hidden;"></span>
  </div>
</div>


<script>
// ========================================
// ðŸŽ¯ SISTEMA DE LOGGING CONDICIONAL
// ========================================
// true = logs ativos (desenvolvimento)
// false = logs desativados (produÃ§Ã£o - MELHOR PERFORMANCE)
const DEBUG_MODE = false; // âœ… Desativado apÃ³s correÃ§Ã£o do bug de stats duplicadas

// FunÃ§Ãµes de log que sÃ³ executam se DEBUG_MODE = true
const debug = {
  warn: (...args) => DEBUG_MODE && console.warn(...args),
  error: (...args) => console.error(...args), // Erros sempre aparecem
  log: (...args) => DEBUG_MODE && console.log(...args),
  pvp: (...args) => DEBUG_MODE && console.log('[PVP]', ...args),
  timer: (...args) => DEBUG_MODE && console.log('[TIMER]', ...args),
  sync: (...args) => DEBUG_MODE && console.log('[SYNC]', ...args),
  xp: (...args) => DEBUG_MODE && console.log('[XP]', ...args),
  realtime: (...args) => DEBUG_MODE && console.log('[REALTIME]', ...args),
  win: (...args) => DEBUG_MODE && console.log('[WIN]', ...args),
  
  // Logs especÃ­ficos por categoria (podem ser controlados individualmente)
};

// âš ï¸ Para ativar logs em produÃ§Ã£o, abra o console e execute:
// ========================================

// ============================================
// ðŸŽ¨ SISTEMA DE BACKGROUNDS RANDOMIZADOS
// ============================================
// Para adicionar novos fundos:
// 1. Coloque o arquivo em: public/game/images/backgrounds/
// 2. Adicione o nome do arquivo no array abaixo
// 3. Pronto! O fundo entrarÃ¡ automaticamente no sistema aleatÃ³rio
const GAME_BACKGROUNDS = [
  'galaxia.png',
  'galaxia2.png',
  'galaxia3.png',
  'galaxia4.png',
  'galaxia5.png',
  // Adicione mais fundos aqui conforme necessÃ¡rio
];

// Aplica um fundo aleatÃ³rio ao canvas a cada nova partida
function applyGameBackground() {
  // Escolhe um fundo aleatÃ³rio A CADA PARTIDA
  const randomBackground = GAME_BACKGROUNDS[Math.floor(Math.random() * GAME_BACKGROUNDS.length)];
  // Atualiza a imagem de fundo que Ã© desenhada no canvas
  if (window.backgroundGalaxy) {
    window.backgroundGalaxy.src = `images/backgrounds/${randomBackground}`;
  }
}

// Detecta se o jogo estÃ¡ embedado num iframe

// UtilitÃ¡rio AAA: Controle centralizado do HUD do jogo
function showGameHUD(timerValue, legendText) {
  const hudTop = document.getElementById('hudTop');
  const timerText = document.getElementById('timerText');
  const legendArea = document.getElementById('legendArea');
  // SÃ³ mostra se a seleÃ§Ã£o de naves NÃƒO estÃ¡ ativa
  const naveSelectScreen = document.getElementById('naveSelectScreen');
  if (naveSelectScreen && naveSelectScreen.style.display !== 'none') {
    hideGameHUD();
    return;
  }
  // LOG AAA: identificar montagem do HUD
  if (hudTop && timerText && legendArea) {
    hudTop.style.display = 'flex';
    hudTop.style.visibility = 'visible';
    hudTop.style.opacity = '1';
    timerText.textContent = timerValue || '';
    legendArea.textContent = legendText || '';
  }
}
function hideGameHUD() {
  const hudTop = document.getElementById('hudTop');
  const timerText = document.getElementById('timerText');
  const legendArea = document.getElementById('legendArea');
  if (hudTop) {
    hudTop.style.display = 'none';
    hudTop.style.visibility = 'hidden';
    hudTop.style.opacity = '0';
  }
  if (timerText) timerText.textContent = '';
  if (legendArea) legendArea.textContent = '';
}
// --- TIMER DE SELEÃ‡ÃƒO DE NAVES AAA ---
let selectionTimer = null;
let selectionTimerInterval = null;
let selectionTimeRemaining = 15;
let selectionTimerStarted = false;
let pendingNaveSelection = null; // ship type waiting for shot-type confirmation

function openShipTutorial() {
  const tut = document.getElementById('shipSelectTutorial');
  if (tut) tut.style.display = 'flex';
  // Pause solo selection timer while modal is open
  if (!multiplayerMode && selectionTimerStarted) {
    if (selectionTimerInterval) { clearInterval(selectionTimerInterval); selectionTimerInterval = null; }
    if (selectionTimer) { clearTimeout(selectionTimer); selectionTimer = null; }
  }
}

function closeShipTutorial() {
  const tut = document.getElementById('shipSelectTutorial');
  if (tut) tut.style.display = 'none';
  sessionStorage.setItem('shipTutorialSeen', '1');
  // Resume solo selection timer from remaining time
  if (!multiplayerMode && selectionTimerStarted && selectionTimeRemaining > 0) {
    showSelectionTimer(selectionTimeRemaining);
    selectionTimerInterval = setInterval(() => {
      selectionTimeRemaining--;
      showSelectionTimer(selectionTimeRemaining);
      if (selectionTimeRemaining <= 0) {
        clearInterval(selectionTimerInterval);
        selectionTimerInterval = null;
      }
    }, 1000);
    selectionTimer = setTimeout(async () => {
      if (!window.selectedNaves || window.selectedNaves.length < 3) {
        window.selectedNaves = [1, 1, 1];
        updatePreviews();
      }
      await saveShipSelection();
      updatePhaseAndStartBattle();
    }, selectionTimeRemaining * 1000);
  }
}
// AAA: Sempre sincronizar timer multiplayer via handleMatchUpdate
// O startSelectionTimer sÃ³ Ã© chamado localmente em modo solo

function showSelectionTimer(seconds) {
  debug.timer('[TIMER] showSelectionTimer:', seconds);
  const selectionTimerText = document.getElementById('selectionTimerText');
  if (selectionTimerText) {
    selectionTimerText.textContent = seconds > 0 ? seconds : 0;
    selectionTimerText.style.color = seconds <= 5 ? '#FF4444' : '#FFB84D';
    selectionTimerText.style.visibility = 'visible';
  } else {
    console.warn('[TIMER] selectionTimerText nÃ£o encontrado no DOM');
  }
}
function hideSelectionTimer() {
  debug.timer('[TIMER] hideSelectionTimer');
  const selectionTimerText = document.getElementById('selectionTimerText');
  if (selectionTimerText) {
    selectionTimerText.textContent = '';
    selectionTimerText.style.visibility = 'hidden';
  } else {
    console.warn('[TIMER] selectionTimerText nÃ£o encontrado no DOM');
  }
}

// Fluxo de ROUND_READY: chamado tanto por cleanupAfterRound (animaÃ§Ã£o concluÃ­da)
// quanto por handleMatchUpdate (novo deadline chegou depois da animaÃ§Ã£o).
// SÃ³ startTurnWindow desbloqueia os inputs â€” ships ficam locked atÃ© aqui completar.
// _doRoundReadyFlow foi removido â€” round 2+ chama startTurnWindow(deadline) direto,
// idÃªntico ao round 1 via startBattleFromSelection. startTurnWindow jÃ¡ cuida de:
//   banner condicional por round, delay atÃ© banner fechar, timer 20s, reset de estado.

function startSelectionTimer() {
  if (!multiplayerMode || !matchData) {
    // Solo: fallback para timer local
    debug.timer('[TIMER][SOLO] startSelectionTimer called');
    cancelSelectionTimer();
    selectionTimerStarted = true;
    selectionTimeRemaining = 15;
    showSelectionTimer(selectionTimeRemaining);
    selectionTimerInterval = setInterval(() => {
      selectionTimeRemaining--;
      showSelectionTimer(selectionTimeRemaining);
      if (selectionTimeRemaining <= 0) {
        clearInterval(selectionTimerInterval);
        selectionTimerInterval = null;
      }
    }, 1000);
    selectionTimer = setTimeout(async () => {
      if (!window.selectedNaves || window.selectedNaves.length < 3) {
        window.selectedNaves = [1, 1, 1];
        updatePreviews();
      }
      await saveShipSelection();
      updatePhaseAndStartBattle();
    }, 15000);
    return;
  }
  // Multiplayer: sempre iniciar 15s local ao receber evento.
  // NÃ£o usar Date.now() vs timestamp do servidor â€” relÃ³gios de Windows/Mac podem diferir.
  const secondsLeft = 15;
  cancelSelectionTimer();
  selectionTimerStarted = true;
  selectionTimeRemaining = secondsLeft;
  showSelectionTimer(secondsLeft);
  if (selectionTimerInterval) clearInterval(selectionTimerInterval);
  selectionTimerInterval = setInterval(() => {
    selectionTimeRemaining--;
    showSelectionTimer(selectionTimeRemaining);
    if (selectionTimeRemaining <= 0) {
      clearInterval(selectionTimerInterval);
      selectionTimerInterval = null;
    }
  }, 1000);
  if (selectionTimer) clearTimeout(selectionTimer);
  selectionTimer = setTimeout(async () => {
    if (!window.selectedNaves || window.selectedNaves.length < 3) {
      window.selectedNaves = [1, 1, 1];
      updatePreviews();
    }
    // saveShipSelection() already calls updatePhaseAndStartBattle() when both players are ready.
    // Do NOT call it here unconditionally â€” that would force battle start before opponent is ready.
    await saveShipSelection();
  }, secondsLeft * 1000);
}

function cancelSelectionTimer() {
  debug.timer('[TIMER] cancelSelectionTimer called');
  if (selectionTimer) {
    clearTimeout(selectionTimer);
    selectionTimer = null;
    debug.timer('[TIMER] selectionTimer timeout limpo');
  }
  if (selectionTimerInterval) {
    clearInterval(selectionTimerInterval);
    selectionTimerInterval = null;
    debug.timer('[TIMER] selectionTimerInterval limpo');
  }
  hideSelectionTimer();
  selectionTimerStarted = false;
}

// FunÃ§Ã£o para mostrar o banner central de round
function showRoundBanner(roundNumber) {
  const banner = document.getElementById('roundBanner');
  const bannerText = document.getElementById('roundBannerText');
  if (!banner || !bannerText) return;
  // Always reset to the original style for every round (canvas style)
  banner.style.display = 'flex';
  banner.style.position = 'fixed';
  banner.style.top = '0';
  banner.style.left = '0';
  banner.style.width = '100vw';
  banner.style.height = '100vh';
  banner.style.zIndex = '20000';
  banner.style.alignItems = 'center';
  banner.style.justifyContent = 'center';
  banner.style.pointerEvents = 'none';

  // Remove all extra background, border, shadow, gold, yellow, etc.
  bannerText.style.margin = 'auto';
  bannerText.style.fontFamily = "'Orbitron', sans-serif";
  bannerText.style.fontWeight = 'bold';
  bannerText.style.fontSize = '60px';
  bannerText.style.color = '#fff';
  bannerText.style.textShadow = '0 0 0 #000, 0 0 0 #FFD700, 0 0 0 #0ffb';
  bannerText.style.background = 'none';
  bannerText.style.borderRadius = '0';
  bannerText.style.padding = '0';
  bannerText.style.boxShadow = 'none';
  bannerText.style.letterSpacing = '0px';
  bannerText.style.textAlign = 'center';
  bannerText.style.minWidth = '0';
  bannerText.style.maxWidth = '100vw';
  bannerText.style.userSelect = 'none';

  // Add blue outline to match canvas stroke
  bannerText.style.webkitTextStroke = '4px #0ff';
  bannerText.style.textStroke = '4px #0ff';

  bannerText.innerHTML = `Round ${roundNumber}`;
  roundBannerForRound = roundNumber;
  roundBannerShownAt = Date.now();
  setTimeout(() => {
    banner.style.display = 'none';
  }, ROUND_BANNER_MS);
}

function showSelectionTimer(seconds) {
  debug.timer('[TIMER] showSelectionTimer:', seconds);
  const selectionTimerText = document.getElementById('selectionTimerText');
  if (selectionTimerText) {
    selectionTimerText.textContent = seconds > 0 ? seconds : 0;
    selectionTimerText.style.color = seconds <= 5 ? '#FF4444' : '#FFB84D';
    selectionTimerText.style.visibility = 'visible';
  } else {
    console.warn('[TIMER] selectionTimerText nÃ£o encontrado no DOM');
  }
}
function hideSelectionTimer() {
  debug.timer('[TIMER] hideSelectionTimer');
  const selectionTimerText = document.getElementById('selectionTimerText');
  if (selectionTimerText) {
    selectionTimerText.textContent = '';
    selectionTimerText.style.visibility = 'hidden';
  } else {
    console.warn('[TIMER] selectionTimerText nÃ£o encontrado no DOM');
  }
}

function cancelSelectionTimer() {
  debug.timer('[TIMER] cancelSelectionTimer called');
  if (selectionTimer) {
    clearTimeout(selectionTimer);
    selectionTimer = null;
    debug.timer('[TIMER] selectionTimer timeout limpo');
  }
  if (selectionTimerInterval) {
    clearInterval(selectionTimerInterval);
    selectionTimerInterval = null;
    debug.timer('[TIMER] selectionTimerInterval limpo');
  }
  hideSelectionTimer();
  selectionTimerStarted = false;
}

// Helper: verificar se um userId estÃ¡ presente no canal.
// presenceState() retorna { "chave-aleatÃ³ria": [{ user_id, ... }], ... }
// Os VALORES (arrays de objetos) contÃªm o user_id que foi passado no track().
function isUserInPresence(state, userId) {
  if (!state || !userId) return false;
  return Object.values(state).flat().some(p => p.user_id === userId);
}

// Atualizar estado do botÃ£o Pronto baseado na presenÃ§a do oponente
function updateReadyBtnState() {
  if (!multiplayerMode) return;
  const btn = document.getElementById('startGameBtn');
  if (!btn) return;
  const has3Ships = window.selectedNaves && window.selectedNaves.length === 3;
  if (!has3Ships) return; // botÃ£o ainda oculto, nada a fazer

  // Consulta presenÃ§a ao vivo usando helper correto
  if (!opponentInGame && matchStateChannel && opponentUserId) {
    try {
      const presenceState = matchStateChannel.presenceState();
      if (isUserInPresence(presenceState, opponentUserId)) {
        opponentInGame = true;
      }
    } catch(e) {}
  }

  if (opponentInGame && !PVP.hasSavedSelection) {
    btn.disabled = false;
    btn.style.opacity = '1';
    btn.style.cursor = 'pointer';
    btn.textContent = t('ready');
  } else if (!opponentInGame && !PVP.hasSavedSelection) {
    btn.disabled = true;
    btn.style.opacity = '0.55';
    btn.style.cursor = 'default';
    btn.textContent = t('waitingOpponentShort');
  }
}

// Atualizar traduÃ§Ãµes e iniciar/cancelar timer ao mostrar/esconder seleÃ§Ã£o
const originalShowNaveSelect = showOnly;
window.showOnly = function(screenName) {
  originalShowNaveSelect(screenName);
  if (screenName === 'naveSelectScreen') {
    // Show ship selection tutorial on first visit per session
    if (!sessionStorage.getItem('shipTutorialSeen')) {
      openShipTutorial();
    }
    // AAA: Resetar locks/ready das naves do jogador ao mostrar seleÃ§Ã£o (sempre, inclusive round 1)
    if (Array.isArray(playerNaves)) {
      playerNaves.forEach((ship, i) => {
        ship.locked = false;
        ship.ready = false;
        ship.hasOrder = false;
        if (multiplayerMode && currentTurnNumber === 1) {
        } else {
        }
      });
    }
    setTimeout(() => {
      updateUITranslations();
      // Apply VIP lock/badge to VIP nave cards
      const isVip = localStorage.getItem('thor_is_vip') === 'true';
      document.querySelectorAll('.vip-nave-card').forEach(card => {
        const lock = card.querySelector('.vip-nave-lock');
        const badge = card.querySelector('.vip-nave-badge');
        if (isVip) {
          card.style.opacity = '1';
          card.style.cursor = 'pointer';
          if (lock) lock.style.display = 'none';
          if (badge) badge.style.display = 'block';
        } else {
          card.style.opacity = '0.6';
          card.style.cursor = 'not-allowed';
          if (lock) lock.style.display = 'flex';
          if (badge) badge.style.display = 'none';
        }
      });
      if (!multiplayerMode) {
        startSelectionTimer();
      } else {
        cancelSelectionTimer();
        // Poll presenÃ§a a cada 500ms atÃ© confirmar oponente â€” cobre o caso em que
        // ambos chegaram juntos e os eventos join/sync jÃ¡ dispararam antes de
        // opponentUserId estar definido.
        const presencePollInterval = setInterval(() => {
          if (opponentInGame) { clearInterval(presencePollInterval); return; }
          updateReadyBtnState();
          // Para o poll assim que confirmar
          if (opponentInGame) clearInterval(presencePollInterval);
        }, 500);
        // Limite de 2 minutos
        setTimeout(() => clearInterval(presencePollInterval), 120000);
      }
      // Init carousel (applies team filter + arrow state)
      initNaveCarousel();
    }, 100);
  } else {
    cancelSelectionTimer();
  }
};

const isEmbedded = (window.self !== window.top);

// Se embedado, remove completamente o header antigo do DOM para o Next.js controlar o header
if (isEmbedded) {
  const oldHeader = document.getElementById('userHeader');
  if (oldHeader) oldHeader.remove();
}

// ============================================
// TRADUÃ‡Ã•ES (i18n)
// ============================================
const translations = {
  pt: {
    selectShips: 'Escolha as suas naves:',
    range: 'Alcance',
    protection: 'ProteÃ§Ã£o',
    ready: 'Pronto!',
    startGame: 'Iniciar Jogo',
    waitingSync: 'Aguardando sincronizaÃ§Ã£oâ€¦',
    ship1Desc: 'Especialista em ataques de longa distÃ¢ncia. Ideal para surpreender inimigos fora do alcance deles.',
    ship2Desc: 'Blindagem reforÃ§ada e resistÃªncia extrema. Perfeita para absorver dano e proteger sua frota.',
    ship3Desc: 'EquilÃ­brio entre mobilidade e defesa. VersÃ¡til em qualquer situaÃ§Ã£o de combate.',
    victory: 'VITÃ“RIA',
    defeat: 'DERROTA',
    draw: 'EMPATE',
    practiceXpWarning: 'XP ganho neste modo nÃ£o afeta Ranking ou Level competitivo',
    returnToLobby: 'Retornar ao Lobby',
    buildYourTurn: 'Monte sua jogada! VocÃª tem',
    seconds: 'segundos',
    chooseDestination: 'Escolha o destino para mover esta nave.',
    chooseTarget: 'Agora, clique para escolher o alvo do disparo.',
    attentionCommander: 'AtenÃ§Ã£o, comandante: batalha espacial em curso!',
    preparingNextRound: 'Preparando para o prÃ³ximo round...',
    enemyShips: 'Naves inimigas<br>neutralizadas',
    enemyCollision: 'Auto-colisÃ£o<br>inimiga',
    ownCollision: 'ColisÃ£o na<br>prÃ³pria frota',
    shipsDestroyed: 'Naves<br>destruÃ­das',
    tripleElimination: 'Tripla<br>eliminaÃ§Ã£o',
    victoryNoLoss: 'VitÃ³ria sem<br>perdas',
    waitingOpponent: 'Aguardando',
    finishTurn: 'finalizar a jogada...',
    yourTurn: 'ðŸš€ Sua vez! Clique em uma nave para mover e atirar.',
    waitingOpponentShort: 'â³ Aguardando oponente...',
    clickShipToMove: 'Selecione uma nave',
    selectAnotherShip: 'Selecione outra nave para mover.',
    nextTurn: 'Selecione uma nave',
    logout: 'Sair',
    searchingOpponent: 'Procurando oponente...',
    opponentFound: 'Oponente encontrado, prepare-se para a batalha!',
    won: 'Venceu!'
  },
  en: {
    selectShips: 'Select your ships:',
    range: 'Range',
    protection: 'Protection',
    ready: 'Ready!',
    startGame: 'Start Game',
    waitingSync: 'Waiting for syncâ€¦',
    ship1Desc: 'Long-range attack specialist. Ideal for surprising enemies out of their reach.',
    ship2Desc: 'Reinforced armor and extreme endurance. Perfect for absorbing damage and protecting your fleet.',
    ship3Desc: 'Balance between mobility and defense. Versatile in any combat situation.',
    victory: 'VICTORY',
    defeat: 'DEFEAT',
    draw: 'DRAW',
    practiceXpWarning: 'XP earned in this mode does not affect Ranking or Competitive Level',
    returnToLobby: 'Return to Lobby',
    buildYourTurn: 'Build your turn! You have',
    seconds: 'seconds',
    chooseDestination: 'Choose the destination to move this ship.',
    chooseTarget: 'Now, click to choose the firing target.',
    attentionCommander: 'Attention, commander: space battle in progress!',
    preparingNextRound: 'Preparing for next round...',
    enemyShips: 'Enemy ships<br>neutralized',
    enemyCollision: 'Enemy<br>self-collision',
    ownCollision: 'Collision in<br>own fleet',
    shipsDestroyed: 'Ships<br>destroyed',
    tripleElimination: 'Triple<br>elimination',
    victoryNoLoss: 'Victory without<br>losses',
    waitingOpponent: 'Waiting for',
    finishTurn: 'to finish turn...',
    yourTurn: 'ðŸš€ Your turn! Click a ship to move and fire.',
    waitingOpponentShort: 'â³ Waiting for opponent...',
    clickShipToMove: 'Select a ship',
    selectAnotherShip: 'Select another ship to move.',
    nextTurn: 'Select a ship',
    logout: 'Logout',
    searchingOpponent: 'Searching for opponent...',
    opponentFound: 'Opponent found, prepare for battle!',
    won: 'Won!'
  },
  es: {
    selectShips: 'Elige tus naves:',
    range: 'Alcance',
    protection: 'ProtecciÃ³n',
    ready: 'Â¡Listo!',
    startGame: 'Iniciar Juego',
    waitingSync: 'Esperando sincronizaciÃ³nâ€¦',
    ship1Desc: 'Especialista en ataques de largo alcance. Ideal para sorprender enemigos fuera de su alcance.',
    ship2Desc: 'Blindaje reforzado y resistencia extrema. Perfecta para absorber daÃ±o y proteger tu flota.',
    ship3Desc: 'Equilibrio entre movilidad y defensa. VersÃ¡til en cualquier situaciÃ³n de combate.',
    victory: 'VICTORIA',
    defeat: 'DERROTA',
    draw: 'EMPATE',
    practiceXpWarning: 'El XP ganado en este modo no afecta el Ranking ni el Nivel competitivo',
    returnToLobby: 'Volver al Lobby',
    buildYourTurn: 'Â¡Construye tu turno! Tienes',
    seconds: 'segundos',
    chooseDestination: 'Elige el destino para mover esta nave.',
    chooseTarget: 'Ahora, haz clic para elegir el objetivo de disparo.',
    attentionCommander: 'Â¡AtenciÃ³n, comandante: batalla espacial en curso!',
    preparingNextRound: 'Preparando para el prÃ³ximo round...',
    enemyShips: 'Naves enemigas<br>neutralizadas',
    enemyCollision: 'Auto-colisiÃ³n<br>enemiga',
    ownCollision: 'ColisiÃ³n en<br>propia flota',
    shipsDestroyed: 'Naves<br>destruidas',
    tripleElimination: 'Triple<br>eliminaciÃ³n',
    victoryNoLoss: 'Victoria sin<br>pÃ©rdidas',
    waitingOpponent: 'Esperando a',
    finishTurn: 'que termine su turno...',
    yourTurn: 'ðŸš€ Â¡Tu turno! Haz clic en una nave para mover y disparar.',
    waitingOpponentShort: 'â³ Esperando al oponente...',
    clickShipToMove: 'Selecciona una nave',
    yourTurn: 'Selecciona una nave',
    selectAnotherShip: 'Selecciona otra nave para mover.',
    nextTurn: 'Selecciona una nave',
    logout: 'Cerrar sesiÃ³n',
    searchingOpponent: 'Buscando oponente...',
    opponentFound: 'Â¡Oponente encontrado, prepÃ¡rate para la batalla!',
    won: 'Â¡GanÃ³!'
  }
};

function getLanguage() {
  try {
    const settings = localStorage.getItem('thor_settings_v1');
    if (settings) {
      return JSON.parse(settings)?.ui?.language || 'pt';
    }
  } catch (e) {
    return 'pt';
  }
  return 'pt';
}

function t(key) {
  const lang = getLanguage();
  return translations[lang]?.[key] || translations.pt[key] || key;
}

// ============================================
// PLAYER DATA (recebido via postMessage)
// ============================================
window.THOR_PLAYER = null; // { userId, username, matchId }

// ============================================
// MULTIPLAYER REAL (PVP) - ConfiguraÃ§Ã£o
// ============================================
let multiplayerMode = false; // true se for PVP real
let myTeam = null; // 'blue' ou 'red'
let myUserId = null;
let opponentUserId = null;
let opponentInGame = false; // true quando oponente jÃ¡ entrou no jogo (presenÃ§a confirmada)
let opponentUsername = "Oponente";
let opponentShotPreferences = {}; // Shot preferences do oponente (ex: {"1": "pulse", "2": "energy", "3": "plasma"})
let matchData = null;

// ðŸ›¡ï¸ AAA GUARD: Prevenir processamento duplo de fim de jogo
let matchEndProcessed = false;

// Sistema de Turnos
let matchStateChannel = null;
let matchEventsChannel = null; // Canal para eventos de aÃ§Ãµes (tiros/movimento)
let currentPhase = 'select'; // select | battle | finished
let isMyTurn = false;
let waitingForOpponent = false;
let supabaseClient = null;

// Sistema de heartbeat para detectar desconexÃ£o
let heartbeatInterval = null;
let opponentLastSeenCheck = null;

// IDs dos jogadores (determinÃ­stico via DB)
let player1_id = null; // UUID do player 1 (BLUE)
let player2_id = null; // UUID do player 2 (RED)

// Turnos baseados em user_id (determinÃ­stico)
let currentTurnNumber = 1;
let turnUserId = null; // UUID de quem tem o turno atual
let turnDeadline = null; // Date object do deadline do turno
let turnTimer = null; // setTimeout para deadline
let turnTimerInterval = null; // setInterval para countdown visual
let isResolvingTurn = false; // Guard para evitar resoluÃ§Ã£o duplicada
let turnTimeRemaining = 15; // segundos restantes
let myActionSubmitted = false; // se eu jÃ¡ enviei minha aÃ§Ã£o
let myPendingAction = null; // aÃ§Ã£o que estou montando localmente
let turnWindowActive = false; // se a janela de 15s estÃ¡ ativa
let waitingForTurnResolution = false; // se estou aguardando resoluÃ§Ã£o apÃ³s enviar
// AAA SYNC BARRIER: garante que ambos os clientes animam simultaneamente
let pendingAnimActions = null;   // acoes pendentes ate ambos ACKarem
let selfAnimReady = false;        // eu ja recebi turn_resolved_at
let opponentAnimReady = false;    // oponente ja enviou ANIM_READY
let animReadyTimeout = null;      // fallback se oponente nao responde
// AAA BARRIER 2: ROUND_READY â€” ambos terminaram animaÃ§Ã£o antes do prÃ³ximo round
let roundReadySent = false;       // eu jÃ¡ enviei ROUND_READY neste cleanup
let roundReadyReceived = false;   // oponente jÃ¡ enviou ROUND_READY
let roundReadyTimeout = null;     // fallback se oponente nÃ£o responde
let roundReadyPending = null;     // deadline guardada atÃ© sync completar
let pendingTurnDeadline = null;   // deadline do prÃ³ximo turno chegado via Realtime (handleMatchUpdate)
let awaitingRoundReady = false;   // animaÃ§Ã£o jÃ¡ terminou mas deadline ainda nÃ£o chegou
// Round banner tracking â€” para delay do unlock de ships atÃ© banner fechar
let roundBannerShownAt = 0;
let roundBannerForRound = 0; // qual round jÃ¡ teve o banner exibido (evita duplo-banner)
const ROUND_BANNER_MS = 2500;
function getRoundBannerRemainingMs() {
  if (!roundBannerShownAt) return 0;
  return Math.max(0, ROUND_BANNER_MS - (Date.now() - roundBannerShownAt));
}
// Early-submit buffer: guard para nÃ£o agendar mÃºltiplos resolve
let earlySubmitBufferScheduled = false;

// ========================================
// AAA MULTIPLAYER: Event Sourcing System
// ========================================
let eventSequence = 0; // Sequence number para garantir ordem de eventos
let eventQueue = []; // Fila de eventos pendentes (ordenados)
let lastProcessedSequence = -1; // Ãšltimo evento processado
let isPlayer1Host = false; // Se sou P1 (authoritative host)
let projectileIdCounter = 0; // ID Ãºnico para cada projÃ©til
let projectileHitRegistry = new Set(); // Registrar hits jÃ¡ processados

// ========================================
// AAA COMBAT PHASE SYSTEM
// ========================================
let combatPhase = 'idle'; // idle | combat | cleanup (movimento + tiros em paralelo)
let movementComplete = false; // Todas as naves completaram movimento?
let shootingComplete = false; // Todos os projÃ©teis terminaram?

// PVP State Object (evita duplicaÃ§Ãµes de variÃ¡veis)
const PVP = {
  hasInitialized: false,
  hasSavedSelection: false,
  battleStarted: false,
  selectionTimer: null,
  selectionTimerStarted: false,
  selectionTimerInterval: null,
  selectionTimeRemaining: 15,
  opponentUsernameCache: new Map(),
  usernameErrorLogged: new Set()
};

// Backward compatibility aliases (deprecated - use PVP.* instead)
const usernameCache = PVP.opponentUsernameCache;
const usernameErrorLogged = PVP.usernameErrorLogged;

// SincronizaÃ§Ã£o Realtime (broadcast - deprecated, usar match state)
let syncChannel = null;
let lastSyncTime = 0;
const SYNC_INTERVAL = 100; // ms
let remotePlayerLastSeen = 0;
let remotePlayerConnected = true;

// =====================================================================
// AAA STATE MACHINE â€” canonical multiplayer phase tracker
// Every client must advance through states in this exact order:
//   SHIP_SELECT â†’ ROUND_BANNER â†’ PLANNING â†’ RESOLVING â†’ ANIMATING
//                     â†‘__________________________|  (loop)
// Guards below use this variable to block cross-state leaks.
// =====================================================================
let mpPhase = 'SHIP_SELECT'; // SHIP_SELECT|ROUND_BANNER|PLANNING|RESOLVING|ANIMATING

// ===============================
// AAA: Multiplayer Interactive Phase Guard
// ===============================
function ensurePvpInteractivePhase(context) {
  try {
    if (!multiplayerMode) return;
    // Only force phase to 'select' if it's not already interactive
    if (typeof phase !== 'undefined' && phase !== 'select') {
      debug.pvp('[PVP][PHASE][GUARD] ForÃ§ando phase="select" no inÃ­cio do turno multiplayer. Contexto:', context, '| phase antes:', phase);
      phase = 'select';
    }
    if (typeof currentPhase !== 'undefined' && currentPhase !== 'select') {
      debug.pvp('[PVP][PHASE][GUARD] ForÃ§ando currentPhase="select" no inÃ­cio do turno multiplayer. Contexto:', context, '| currentPhase antes:', currentPhase);
      currentPhase = 'select';
    }
  } catch (err) {
    console.error('[PVP][PHASE][GUARD] Erro ao garantir phase select:', err);
  }
}

// Iniciar janela de turno (15s simultÃ¢neos)
function startTurnWindow(deadlineISO) {
  // roundLocked serÃ¡ desbloqueado APÃ“S o banner fechar (dentro do setTimeout abaixo).
  // NÃ£o desbloquear aqui para manter naves bloqueadas durante o banner de round.
  // AAA: Garantir fase interativa no multiplayer
  ensurePvpInteractivePhase('startTurnWindow');

  if (!multiplayerMode) {
    return;
  }

  // GUARD: Se Ã© o mesmo deadline, ignorar (jÃ¡ estÃ¡ rodando)
  if (window.__currentTurnDeadline === deadlineISO) {
    return;
  }
  
  // GUARD FORTE: Prevenir mÃºltiplas chamadas simultÃ¢neas com debounce
  const _stw_now = Date.now();
  if (window.__lastTurnWindowStart && (_stw_now - window.__lastTurnWindowStart) < 1000) {
    return;
  }
  window.__lastTurnWindowStart = _stw_now;
  
  // Armazenar deadline atual
  window.__currentTurnDeadline = deadlineISO;

  // =========================
  // AAA: RESET DO NOVO ROUND
  // =========================

  // 1) Destravar input do setup do round
  inputLocked = false;

  // ðŸ”¥ Performance: limpar destroÃ§os do round anterior (wrecks cresce indefinidamente se nÃ£o limpar)
  wrecks = [];

  // 2) MUITO IMPORTANTE: zerar seleÃ§Ã£o do round (senÃ£o Round 2 fica travado)
  window.selectedNaves = [];
  // Resetando locks/ready das naves do jogador
  if (Array.isArray(playerNaves)) {
    playerNaves.forEach((ship, i) => {
      ship.locked = false;
      ship.ready = false;
      ship.hasOrder = false;
    });
  }

  // 3) Resetar flags relacionadas ao setup (se existirem)
  if (window.PVP) {
    PVP.selectionComplete = false;

    // Se vocÃª tiver essas flags no seu PVP, Ã© seguro resetar aqui:
    if ("localTurnSubmitted" in PVP) PVP.localTurnSubmitted = false;
    if ("waitingOpponent" in PVP) PVP.waitingOpponent = false;
  }
  
  // Limpar timer global se existir
  if (window.__activeTurnTimer) {
    clearInterval(window.__activeTurnTimer);
    window.__activeTurnTimer = null;
  }
  
  // GUARD: Se jÃ¡ existe um timer ativo, limpar antes de criar novo
  if (turnTimerInterval) {
    clearInterval(turnTimerInterval);
    turnTimerInterval = null;
  }
  
  if (turnTimer) {
    clearTimeout(turnTimer);
    turnTimer = null;
  }
  
  // Resetar flags do turno anterior
  myActionSubmitted = false;
  waitingForTurnResolution = false;
  window.__lastAppliedTurnKey = null; // Limpar guard de aplicaÃ§Ã£o
  // Resetar barreira de animacao sincronizada
  selfAnimReady = false;
  opponentAnimReady = false;
  pendingAnimActions = null;
  if (animReadyTimeout) { clearTimeout(animReadyTimeout); animReadyTimeout = null; }
  // Resetar barreira ROUND_READY
  roundReadySent = false;
  roundReadyReceived = false;
  roundReadyPending = null;
  earlySubmitBufferScheduled = false;
  if (roundReadyTimeout) { clearTimeout(roundReadyTimeout); roundReadyTimeout = null; }
  // Limpar flags de sincronizaÃ§Ã£o entre rounds (garantir estado limpo)
  awaitingRoundReady = false;
  pendingTurnDeadline = null;

  // Canonical state: entering planning window
  mpPhase = 'PLANNING';
  
  // Parse deadline do servidor (mantido para referÃªncia, mas NÃƒO usado para calcular tempo do cliente)
  turnDeadline = deadlineISO ? new Date(deadlineISO) : new Date(Date.now() + 20000);
  turnWindowActive = true;
  myActionSubmitted = false;
  myPendingAction = null;
  waitingForTurnResolution = false;

  // Exibir banner de round somente se ainda nÃ£o foi mostrado para este round.
  if (roundBannerForRound !== currentTurnNumber) {
    if (typeof showRoundBanner === 'function') {
      showRoundBanner(currentTurnNumber);
    }
  }

  // Aguardar o banner fechar antes de ativar o timer e liberar as naves.
  // Garante que: "Round N" aparece â†’ banner some â†’ legenda mostra "Selecione uma nave".
  const _bannerWait = getRoundBannerRemainingMs();
  setTimeout(() => {
    // âš ï¸ CLOCK SKEW FIX: Nunca calcular tempo restante de Date.now() vs deadline do servidor.
    // RelÃ³gios de Windows/Mac podem diferir fazendo P2 receber 0s ou 67s.
    // Ambos os clientes sempre recebem 20s locais a partir do momento que recebem o evento.
    const TURN_DURATION_S = 20;
    turnTimeRemaining = TURN_DURATION_S;
    
    // Mostrar timer visual
    const timerText = document.getElementById('timerText');
    const legendArea = document.getElementById('legendArea');
    const hudTop = document.getElementById('hudTop');

    // Banner fechou: desbloquear naves e mostrar instruÃ§Ã£o
    roundLocked = false;
    if (legendArea) {
      legendArea.textContent = t('nextTurn');
      legendArea.style.color = '';
    }
    
    const timerArea = document.getElementById('timerArea');
    if (timerArea) { timerArea.style.visibility = 'visible'; }
    if (timerText && hudTop) {
      hudTop.style.display = 'flex';
      hudTop.style.visibility = 'visible';
      hudTop.style.opacity = '1';
      timerText.textContent = turnTimeRemaining;
      timerText.style.color = '#00D4FF';
    }
    
    // GUARD FORTE: Garantir que sÃ³ um interval estÃ¡ ativo por vez
    if (window.__activeTurnTimer) {
      clearInterval(window.__activeTurnTimer);
      window.__activeTurnTimer = null;
    }
    
    // Countdown visual: decrementar localmente (sem recalcular de Date.now() â€” evita clock skew)
    turnTimerInterval = setInterval(() => {
      turnTimeRemaining = Math.max(0, turnTimeRemaining - 1);
      
      if (timerText) {
        timerText.textContent = turnTimeRemaining;
        
        // Mudar cor nos Ãºltimos 5s
        if (turnTimeRemaining <= 5) {
          timerText.style.color = '#FF4444';
        }
      }
      
      if (turnTimeRemaining <= 0) {
        clearInterval(turnTimerInterval);
        turnTimerInterval = null;
        window.__activeTurnTimer = null;
      }
    }, 1000);
    
    // Registrar o timer globalmente
    window.__activeTurnTimer = turnTimerInterval;
    
    // Timer principal: sempre 20s locais â€” evita clock skew de zerar o turno do P2
    const timeoutMs = TURN_DURATION_S * 1000;
    turnTimer = setTimeout(() => {
      const isPlayer1 = myUserId === matchData?.player1_id;
      
      // Limpar seleÃ§Ã£o de nave quando tempo acaba
      selectedNave = null;
      isInteracting = false;
      // Se ainda nÃ£o enviei, submeter: naves configuradas mantÃªm ordens,
      // naves sem ordens recebem NOOP (target=null, shot=null â†’ ficam paradas).
      if (!myActionSubmitted) {
        const timerShips = playerNaves.map((n, idx) => ({
          index: idx,
          x: n.x,
          y: n.y,
          target: n.target ? { x: n.target.x, y: n.target.y } : null,
          shot:   n.shot   ? { x: n.shot.x,   y: n.shot.y   } : null,
          hp:     n.hp,
          angle:  n.angle,
          shotType: (typeof ShotTypeManager !== 'undefined')
            ? ShotTypeManager.getShotType(n.tipo)
            : 'plasma'
        }));
        submitMyAction({ type: 'play', ships: timerShips });
      }
      // Tentar resolver turno repetidamente atÃ© sucesso (mÃ¡x 5 tentativas)
      // APENAS Player 1 (host) resolve turnos (variÃ¡vel jÃ¡ declarada acima)
      if (isPlayer1) {
        let resolveAttempts = 0;
        function tryResolveLoop() {
          resolveAttempts++;
          maybeResolveTurn();
          if (resolveAttempts < 5 && phase !== 'wait') {
            setTimeout(tryResolveLoop, 700);
          } else if (phase === 'wait') {
            // Turno jÃ¡ foi resolvido
          } else {
            console.warn('[TURN] [TIMEOUT] Player 1 nÃ£o conseguiu resolver turno apÃ³s 5 tentativas.');
          }
        }
        tryResolveLoop();
      }
    }, timeoutMs + 500);
  }, _bannerWait + 50);
  
}

// Enviar minha aÃ§Ã£o do turno
async function submitMyAction(actionPayload) {
  if (!multiplayerMode || !supabaseClient || !matchData || myActionSubmitted) {
    return false;
  }
  
  try {
    const updateData = {};
    
    if (myTeam === 'blue') {
      updateData.action_blue = actionPayload;
      updateData.submitted_blue = true;
    } else {
      updateData.action_red = actionPayload;
      updateData.submitted_red = true;
    }
    
    
    const { error } = await supabaseClient
      .from('matches')
      .update(updateData)
      .eq('id', matchData.id);
    
    if (error) {
      console.error('[TURN] âŒ Erro ao enviar aÃ§Ã£o:', error);
      return false;
    }
    
    
    myActionSubmitted = true;
    waitingForTurnResolution = true;
    mpPhase = 'RESOLVING'; // canonical state: waiting for DB to resolve turn

    // Travar todas as naves atÃ© o prÃ³ximo round
    if (playerNaves) playerNaves.forEach(n => n.locked = true);


    // Travar UI e mostrar "Aguardando oponente..."
    const legendArea = document.getElementById('legendArea');
    if (legendArea) {
      legendArea.textContent = t('waitingOpponent') + ' ' + opponentUsername + ' ' + t('finishTurn');
      legendArea.style.color = '#FFB84D';
    }

    // Removido: banner central de aguarde. SÃ³ usar legendArea no HUD.

    // NÃƒO cancelar turnTimerInterval: precisa continuar para disparar maybeResolveTurn() no deadline
    // caso o oponente submeta depois do nosso 300ms check inicial.

    // Tentar resolver turno agora (se ambos jÃ¡ enviaram)
    setTimeout(() => maybeResolveTurn(), 300);

    return true;
  } catch (err) {
    console.error('[TURN] âŒ ExceÃ§Ã£o ao enviar aÃ§Ã£o:', err);
    return false;
  }
}

// Tentar resolver o turno (se ambos enviaram OU deadline passou)
async function maybeResolveTurn() {
  if (!multiplayerMode || !supabaseClient || !matchData) {
    return;
  }
  
  // Guard: evitar mÃºltiplas tentativas simultÃ¢neas de resoluÃ§Ã£o
  if (isResolvingTurn) {
    return;
  }
  
  isResolvingTurn = true;
  
  
  try {
    // Buscar estado atual do match
    const { data: match, error } = await supabaseClient
      .from('matches')
      .select('*')
      .eq('id', matchData.id)
      .maybeSingle();
    
    if (error || !match) {
      console.error('[TURN] Erro ao buscar match:', error);
      isResolvingTurn = false;
      return;
    }
    
    // âœ… ETAPA 1: APENAS player1_id resolve turnos (evita race condition)
    // player2_id aguarda o Realtime detectar turn_resolved_at
    const isPlayer1 = myUserId === match.player1_id;
    if (!isPlayer1) {
      isResolvingTurn = false;
      return;
    }
    
    // Ler aÃ§Ãµes de action_blue/action_red
    const action_blue = match.action_blue;
    const action_red = match.action_red;
    const submitted_blue = match.submitted_blue;
    const submitted_red = match.submitted_red;
    
    
    const turn_resolved_at = match.turn_resolved_at;
    const turn_deadline_at = match.turn_deadline_at;
    const currentTurnInDb = match.turn_number || 1;
    
    
    // IMPORTANTE: turn_resolved_at pode referir-se ao TURNO ANTERIOR (pois incrementamos turn_number).
    // Portanto, nÃ£o usar turn_resolved_at como guard de "turno jÃ¡ resolvido".
    
    // Verificar se ambos enviaram
    const bothSubmitted = submitted_blue && submitted_red;
    
    // Verificar se deadline passou
    const now = new Date();
    const deadline = turn_deadline_at ? new Date(turn_deadline_at) : null;
    const deadlinePassed = deadline && now >= deadline;
    
    
    // SÃ³ resolver se ambos enviaram OU deadline passou
    if (!bothSubmitted && !deadlinePassed) {
      isResolvingTurn = false;
      return;
    }

    // Early-submit buffer: se ambos enviaram ANTES do deadline com >2.5s restantes,
    // aguardar 2.5s para sincronizaÃ§Ã£o de rede antes de resolver
    if (bothSubmitted && !deadlinePassed && deadline) {
      const msRemaining = deadline.getTime() - Date.now();
      if (msRemaining > 2500 && !earlySubmitBufferScheduled) {
        earlySubmitBufferScheduled = true;
        isResolvingTurn = false;
        setTimeout(() => { earlySubmitBufferScheduled = false; maybeResolveTurn(); }, 2500);
        return;
      }
    }
    
    
    // Usar aÃ§Ãµes diretamente ou idle se nÃ£o submetido
    const final_action_blue = submitted_blue ? action_blue : { type: 'idle' };
    const final_action_red = submitted_red ? action_red : { type: 'idle' };
    
    
    // Marcar como resolvido e avanÃ§ar turno
    const nextTurnNumber = currentTurnInDb + 1;
    const newDeadline = new Date(Date.now() + 20000).toISOString();
    
    // IMPORTANTE: Salvar as aÃ§Ãµes em last_action_* ANTES de limpar
    // para que o Realtime UPDATE possa ler elas
    let updateQuery = supabaseClient
      .from('matches')
      .update({
        turn_resolved_at: new Date().toISOString(),
        turn_number: nextTurnNumber,
        turn_deadline_at: newDeadline,
        last_action_blue: final_action_blue,
        last_action_red: final_action_red,
        action_blue: null,
        action_red: null,
        submitted_blue: false,
        submitted_red: false
      })
      .eq('id', matchData.id)
      // Guard atÃ´mico por turno: sÃ³ um cliente consegue avanÃ§ar ESTE turn_number
      .eq('turn_number', currentTurnInDb);

    const { data: updateData, error: updateError } = await updateQuery.select();
    
    if (updateError) {
      console.error('[TURN] Erro ao atualizar match:', updateError);
      isResolvingTurn = false;
      return;
    }
    
    // Se nÃ£o retornou dados, outro cliente jÃ¡ resolveu (ou o turno jÃ¡ avanÃ§ou)
    if (!updateData || updateData.length === 0) {
      isResolvingTurn = false;
      return;
    }
    
    
    // NÃƒO aplicar aÃ§Ãµes aqui - o Realtime vai detectar turn_resolved_at
    // e chamar applyResolvedTurn em AMBOS os clientes

    // AAA: Removido fallback local. A animaÃ§Ã£o e tela de resultado sÃ³ devem ser disparadas via evento do backend (phase=finished) pelo Realtime.

    // NÃƒO atualizar currentTurnNumber aqui - deixar o Realtime detectar e iniciar novo turno

    isResolvingTurn = false;
  } catch (err) {
    console.error('[TURN] âŒ ExceÃ§Ã£o ao resolver turno:', err);
    isResolvingTurn = false;
  }
}

// Aplicar turno resolvido (executar aÃ§Ãµes de ambos simultaneamente)
function applyResolvedTurn(actions) {
  if (!multiplayerMode) return;
  
  // Guard: prevenir mÃºltiplas aplicaÃ§Ãµes do mesmo turno
  const turnKey = JSON.stringify(actions);
  if (window.__lastAppliedTurnKey === turnKey) {
    return;
  }
  window.__lastAppliedTurnKey = turnKey;
  mpPhase = 'ANIMATING'; // canonical state: deterministic playback in progress
  
  turnWindowActive = false;
  waitingForTurnResolution = false;
  phase = 'wait';
  
  
  // Determinar quais sÃ£o minhas aÃ§Ãµes e quais sÃ£o do oponente
  const myAction = (myTeam === 'blue') ? actions.action_blue : actions.action_red;
  const oppAction = (myTeam === 'blue') ? actions.action_red : actions.action_blue;
  
  
  // Aplicar MINHAS aÃ§Ãµes em playerNaves
  if (myAction && myAction.type === 'play' && myAction.ships) {
    myAction.ships.forEach(shipData => {
      const nave = playerNaves[shipData.index];
      if (nave && nave.hp > 0) {
        nave.target = shipData.target;
        nave.shot = shipData.shot;
        // Usar shotType do payload (fonte Ãºnica de verdade)
        if (shipData.shotType) nave.shotType = shipData.shotType;
      }
    });
  } else {
  }
  
  // Aplicar aÃ§Ãµes do OPONENTE em cpuNaves
  if (oppAction && oppAction.type === 'play' && oppAction.ships) {
    oppAction.ships.forEach(shipData => {
      const nave = cpuNaves[shipData.index];
      if (nave && nave.hp > 0) {
        nave.target = shipData.target;
        nave.shot = shipData.shot;
        // Usar shotType do payload (fonte Ãºnica de verdade)
        if (shipData.shotType) nave.shotType = shipData.shotType;
        // Aplicar Ã¢ngulo salvo pelo oponente (sem recalcular)
        if (shipData.angle !== undefined) {
          nave.angle = shipData.angle;
        }
        // ðŸ”¥ AAA: Snap posiÃ§Ã£o canÃ´nica â€” garante animaÃ§Ã£o determinÃ­stica em ambas as telas
        // Sem isso, o lerp do realtime_state pode deixar posiÃ§Ãµes divergentes em cada cliente
        // resultando em colisÃµes diferentes (P1 vÃª acerto, P2 vÃª erro)
        if (shipData.x !== undefined) nave.x = shipData.x;
        if (shipData.y !== undefined) nave.y = shipData.y;
      } else {
        console.warn('[TURN]   - âš ï¸ cpuNave #' + shipData.index + ' nÃ£o existe ou HP=0');
      }
    });
  } else {
    console.warn('[TURN] âš ï¸ AÃ§Ã£o do oponente invÃ¡lida ou idle:', oppAction);
  }
  
  // Iniciar animaÃ§Ã£o simultÃ¢nea (movimento + tiros)
  
  // ðŸ”¥ AAA: Limpar registro de hits do turno anterior
  projectileHitRegistry.clear();
  // Registro de hits limpo para novo turno
  
  // ðŸ”¥ AAA: MOVIMENTO E TIROS SIMULTÃ‚NEOS (AAA Quality)
  combatPhase = 'combat'; // Fase Ãºnica: movimento + tiros ao mesmo tempo
  movementComplete = false;
  shootingComplete = false;
  // Iniciando COMBATE (movimento + tiros SIMULTÃ‚NEOS)
  
  // Disparar projÃ©teis IMEDIATAMENTE
  fireProjectiles();
  
  // Ocultar apenas o timerArea (nÃ£o o hudTop inteiro) â€” legendArea precisa continuar visÃ­vel durante animaÃ§Ã£o
  const _timerAnim = document.getElementById('timerArea');
  if (_timerAnim) { _timerAnim.style.visibility = 'hidden'; }
  const _hudAnim = document.getElementById('hudTop');
  if (_hudAnim) { _hudAnim.style.visibility = 'visible'; _hudAnim.style.opacity = '1'; }

  // Legenda durante animaÃ§Ã£o
  const legendArea = document.getElementById('legendArea');
  if (legendArea) {
    legendArea.textContent = t('attentionCommander');
    legendArea.style.color = '#FFB84D';
  }

}

// Sincronizar HP das naves no banco apÃ³s combate
async function syncShipsHP() {
  if (!multiplayerMode || !supabaseClient || !matchData) return;
  
  try {
    debug.sync('[SYNC] Sincronizando HP das naves...');
    
    // Coletar HP das minhas naves
    const myShipsHP = playerNaves.map(n => n.hp);
    
    debug.sync('[SYNC] Meu HP:', myShipsHP);
    debug.sync('[SYNC] Meu time:', myTeam);
    
    // âœ… AAA: Calcular checksum para validaÃ§Ã£o de integridade
    const checksum = myShipsHP.reduce((a, b) => a + b, 0);
    debug.sync('[SYNC] Checksum HP:', checksum);
    
    // Atualizar no banco baseado no meu time
    const updateData = {};
    if (myTeam === 'blue') {
      updateData.player1_hp = myShipsHP;
    } else {
      updateData.player2_hp = myShipsHP;
    }
    
    const { error } = await supabaseClient
      .from('matches')
      .update(updateData)
      .eq('id', matchData.id);
    
    if (error) {
      console.error('[SYNC] Erro ao sincronizar HP:', error);
      return;
    }
    
    debug.sync('[SYNC] âœ… HP sincronizado com sucesso');
    
    // âœ… AAA: Verificar se hÃ¡ divergÃªncia com o oponente
    const { data: freshMatch } = await supabaseClient
      .from('matches')
      .select('player1_hp, player2_hp')
      .eq('id', matchData.id)
      .single();
    
    if (freshMatch) {
      const oppHP = (myTeam === 'blue') ? freshMatch.player2_hp : freshMatch.player1_hp;
      if (oppHP && oppHP.length === 3) {
        debug.sync('[SYNC] HP do oponente no banco:', oppHP);
        // Aplicar HP do oponente em cpuNaves para garantir consistÃªncia
        cpuNaves.forEach((nave, idx) => {
          if (nave.initialized && oppHP[idx] !== undefined && nave.hp !== oppHP[idx]) {
            const oldHp = nave.hp;
            nave.hp = oppHP[idx];
            console.warn(`[SYNC] âš ï¸ CORREÃ‡ÃƒO: cpuNaves[${idx}].hp divergente! ${oldHp} â†’ ${nave.hp}`);
          }
        });
      }
    }
  } catch (err) {
    console.error('[SYNC] ExceÃ§Ã£o ao sincronizar HP:', err);
  }
}

// ========================================
// SISTEMA OFICIAL DE XP
// ========================================

// DefiniÃ§Ã£o dos eventos de XP
const XP_EVENTS = {
  // Eventos positivos
  DESTROY_ENEMY_SHIP: { name: 'Nave inimiga destruÃ­da', xp: 25 },
  PRECISION_HIT_STREAK: { name: 'PrecisÃ£o absoluta', xp: 20 },
  DOUBLE_KILL_ROUND: { name: 'Double Kill', xp: 40 },
  TRIPLE_KILL_ROUND: { name: 'Triple Kill', xp: 80 },
  PERFECT_ROUND: { name: 'VitÃ³ria Perfeita', xp: 30 },
  CLUTCH_KILL: { name: 'Clutch', xp: 25 },
  COMEBACK_WIN: { name: 'Virada Ã©pica', xp: 20 },
  MATCH_VICTORY: { name: 'VitÃ³ria', xp: 30 },
  MATCH_DRAW: { name: 'Empate', xp: 20 },
  MATCH_DEFEAT: { name: 'Derrota', xp: 0 },
  
  // Eventos negativos (agora valem 0 - nÃ£o subtraem XP)
  FRIENDLY_COLLISION: { name: 'ColisÃ£o com nave aliada', xp: 0 },
  ENEMY_COLLISION: { name: 'ColisÃ£o com nave inimiga', xp: 0 },
  LOSE_ONE_SHIP: { name: 'Nave perdida', xp: 0 },
  LOSE_TWO_SHIPS_ROUND: { name: 'Perda dupla', xp: 0 },
  LOSE_THREE_SHIPS_ROUND: { name: 'Derrota crÃ­tica', xp: 0 }
};

// Tracking de eventos por round e partida
let xpEvents = [];
let xpTotalMatch = 0;
let finalXpForChat = 0; // ðŸŽ¯ XP final para enviar ao chat (salvo no fim do jogo)
let xpAlreadyApplied = false; // ðŸ”’ Flag para evitar aplicar XP mÃºltiplas vezes
let roundKills = 0;
let roundLosses = 0;
let roundCollisionLosses = 0; // Perdas por colisÃ£o (nÃ£o contar para LOSE_X_SHIPS_ROUND)
let roundHitStreaks = {}; // { naveIndex: consecutiveHits }
let wasLosingBeforeRound = false;

// Registrar evento de XP
function registerXPEvent(eventKey) {
  const event = XP_EVENTS[eventKey];
  if (!event) {
    console.warn('[XP] Evento desconhecido:', eventKey);
    return;
  }
  
  xpEvents.push({ key: eventKey, name: event.name, xp: event.xp });
  xpTotalMatch += event.xp;
  
}

// Resetar contadores de round
function resetRoundXPTracking() {
  roundKills = 0;
  roundLosses = 0;
  roundCollisionLosses = 0;
  roundHitStreaks = {};
  wasLosingBeforeRound = (cpuDestroyed - playerDestroyed) < 0;
}

// Processar eventos de round (chamado no final do round)
function processRoundXPEvents() {
  // Verificar multi-kills
  if (roundKills === 2) {
    registerXPEvent('DOUBLE_KILL_ROUND');
  } else if (roundKills === 3) {
    registerXPEvent('TRIPLE_KILL_ROUND');
  }
  
  // Verificar mÃºltiplas perdas - valores TOTAIS, nÃ£o cumulativos
  if (roundLosses === 3) {
    registerXPEvent('LOSE_THREE_SHIPS_ROUND');
  } else if (roundLosses === 2) {
    registerXPEvent('LOSE_TWO_SHIPS_ROUND');
  } else if (roundLosses === 1) {
    registerXPEvent('LOSE_ONE_SHIP');
  }
  // Se roundLosses === 0, nÃ£o registrar nada
}

// Processar eventos de fim de partida
function processMatchEndXPEvents(result) {
  debug.xp('[XP] ðŸ“Š processMatchEndXPEvents chamada com result:', result);
  debug.xp('[XP] ðŸ“Š xpEvents ANTES:', JSON.parse(JSON.stringify(xpEvents)));
  debug.xp('[XP] ðŸ“Š xpTotalMatch ANTES:', xpTotalMatch);
  
  // ðŸ”’ Guard: Se eventos de fim jÃ¡ foram processados, nÃ£o processar novamente
  // (usa variÃ¡vel separada para permitir que applyMatchXP tenha seu prÃ³prio guard)
  if (window.__matchEndEventsProcessed) {
    debug.xp('[XP] âš ï¸ processMatchEndXPEvents jÃ¡ foi chamado, ignorando duplicata');
    return;
  }
  window.__matchEndEventsProcessed = true;
  
  // Resultado da partida
  if (result === 'win') {
    registerXPEvent('MATCH_VICTORY');
    
    // Verificar vitÃ³ria sem perdas (Perfect Round)
    if (playerNaves.every(n => n.hp > 0)) {
      registerXPEvent('PERFECT_ROUND');
    }
    
    // Verificar comeback
    if (wasLosingBeforeRound) {
      registerXPEvent('COMEBACK_WIN');
    }
  } else if (result === 'draw') {
    registerXPEvent('MATCH_DRAW');
  } else if (result === 'defeat') {
    registerXPEvent('MATCH_DEFEAT');
    // âŒ DERROTA: Zerar todo o XP acumulado
    debug.xp('[XP] ðŸ’€ DERROTA: Zerando XP total (era:', xpTotalMatch, ')');
    xpTotalMatch = 0;
  }
  
  debug.xp('[XP] ðŸ“Š xpEvents DEPOIS:', JSON.parse(JSON.stringify(xpEvents)));
  debug.xp('[XP] ðŸ“Š xpTotalMatch ANTES do CAP:', xpTotalMatch);
  
  // Aplicar CAP HARD de 450 XP e garantir que nunca seja negativo (apenas se nÃ£o for derrota)
  if (result !== 'defeat') {
    xpTotalMatch = Math.min(450, Math.max(0, xpTotalMatch));
  }
  debug.xp('[XP] ðŸ“Š xpTotalMatch DEPOIS do CAP:', xpTotalMatch);
}

// Aplicar XP total ao jogador
async function applyMatchXP() {
  // ðŸ”’ Bloqueia XP, vitÃ³rias e progresso no modo prÃ¡tica
  if (!multiplayerMode) {
    debug.xp('[XP] âš ï¸ Modo prÃ¡tica: nÃ£o aplica XP, vitÃ³rias ou progresso.');
    return;
  }
  // ðŸ”’ Evitar mÃºltiplas execuÃ§Ãµes
  if (xpAlreadyApplied) {
    debug.xp('[XP] âš ï¸ XP jÃ¡ foi aplicado nesta partida, ignorando duplicata');
    return;
  }
  if (!supabaseClient || !myUserId) {
    console.warn('[XP] NÃ£o Ã© possÃ­vel aplicar XP - sem cliente ou userId');
    return;
  }
  if (xpTotalMatch === 0) {
    debug.xp('[XP] Nenhum XP para aplicar');
    return;
  }
  
  // ðŸ”’ Marcar como aplicado ANTES de qualquer operaÃ§Ã£o async
  xpAlreadyApplied = true;
  
  try {
    debug.xp('[XP] ðŸš€ INÃCIO applyMatchXP');
    debug.xp('[XP] ðŸš€ xpTotalMatch:', xpTotalMatch);
    debug.xp('[XP] ðŸš€ xpEvents.length:', xpEvents.length);
    debug.xp('[XP] ðŸš€ xpEvents:', JSON.parse(JSON.stringify(xpEvents)));
    
    // Buscar progresso atual
    let { data: progress, error: fetchError } = await supabaseClient
      .from('player_progress')
      .select('level, xp, xp_to_next')
      .eq('user_id', myUserId)
      .maybeSingle();
    
    if (fetchError) {
      console.error('[XP] Erro ao buscar progresso:', fetchError);
      return;
    }
    
    // Se nÃ£o existe progresso, criar
    if (!progress) {
      const defaultProgress = {
        user_id: myUserId,
        level: 1,
        xp: 0,
        xp_to_next: 300,
        total_xp: 0
      };
      const { error: insertError } = await supabaseClient
        .from('player_progress')
        .insert(defaultProgress);
      if (insertError) {
        console.error('[XP] Erro ao criar progresso:', insertError);
        return;
      }
      progress = defaultProgress;
    }
    
    // Calcular novo XP e nÃ­vel
    debug.xp('[XP] ðŸ” progress recebido do DB:', JSON.parse(JSON.stringify(progress)));
    let level = progress.level || 1;
    debug.xp('[XP] ðŸ” progress.xp:', progress.xp);
    debug.xp('[XP] ðŸ” xpTotalMatch neste momento:', xpTotalMatch);
    let xp = (progress.xp || 0) + xpTotalMatch;
    debug.xp('[XP] ðŸ” XP CALCULADO (progress.xp + xpTotalMatch):', xp);
    let xp_to_next = progress.xp_to_next || 300;
    let levelUps = 0;
    
    // XP curve: 300 * (1.25 ^ (level - 1))
    const computeXpToNext = (lvl) => Math.round(300 * Math.pow(1.25, lvl - 1));
    
    // Calcular level ups
    while (xp >= xp_to_next) {
      xp -= xp_to_next;
      level++;
      levelUps++;
      xp_to_next = computeXpToNext(level);
    }
    
    // Atualizar no banco
    const { error: updateError } = await supabaseClient
      .from('player_progress')
      .update({ level, xp, xp_to_next })
      .eq('user_id', myUserId);
    
    if (updateError) {
      console.error('[XP] Erro ao atualizar progresso:', updateError);
      return;
    }
    
    // âœ… INCREMENTAR TOTAL_XP (sistema de ranks)
    debug.xp('[XP] ðŸ“Š Incrementando total_xp via RPC:', xpTotalMatch);
    
    // ðŸ” DEBUG: Buscar total_xp atual ANTES do incremento
    const { data: beforeData } = await supabaseClient
      .from('player_progress')
      .select('total_xp')
      .eq('user_id', myUserId)
      .single();
    debug.xp('[XP] ðŸ” total_xp no DB ANTES do RPC:', beforeData?.total_xp ?? 0);
    
    try {
      const { error: rpcError } = await supabaseClient.rpc('increment_total_xp', {
        p_user_id: myUserId,
        p_xp_gain: Math.max(0, Math.floor(xpTotalMatch))
      });
      
      if (rpcError) {
        console.warn('[XP] âš ï¸ Erro ao incrementar total_xp (nÃ£o crÃ­tico):', rpcError);
      } else {
        debug.xp('[XP] âœ… total_xp incrementado com sucesso!');
        
        // ðŸ” DEBUG: Buscar total_xp atual DEPOIS do incremento
        const { data: afterData } = await supabaseClient
          .from('player_progress')
          .select('total_xp')
          .eq('user_id', myUserId)
          .single();
        debug.xp('[XP] ðŸ” total_xp no DB DEPOIS do RPC:', afterData?.total_xp ?? 0);
      }
    } catch (rpcErr) {
      console.warn('[XP] âš ï¸ ExceÃ§Ã£o ao incrementar total_xp:', rpcErr);
    }
    
    debug.xp('[XP] âœ… XP aplicado:', { level, xp, xp_to_next, levelUps, xpGain: xpTotalMatch });
    
    // Disparar eventos para atualizar o header
    window.dispatchEvent(new CustomEvent('thor_progress_updated', {
      detail: { level, xp, xp_to_next }
    }));
    window.dispatchEvent(new Event('thor_match_finalized'));
    window.dispatchEvent(new Event('thor_stats_updated')); // âœ… ForÃ§a refresh do UserHeader
    
    // Atualizar header disparando evento (legado)
    window.dispatchEvent(new CustomEvent('thor_xp_updated', {
      detail: { 
        userId: myUserId, 
        xpGain: xpTotalMatch,
        level,
        xp,
        xp_to_next,
        levelUps
      }
    }));
    
    // Postar eventos de XP no chat
    await postXPEventsToChat();
    
  } catch (err) {
    console.error('[XP] ExceÃ§Ã£o ao aplicar XP:', err);
  }
}

// Postar eventos de XP no chat
async function postXPEventsToChat() {
  if (!supabaseClient || !myUserId || xpEvents.length === 0) return;
  
  try {
    const username = localStorage.getItem('thor_username') || 'Player';
    
    // Agrupar eventos por positivos e negativos
    const positiveEvents = xpEvents.filter(e => e.xp > 0);
    const negativeEvents = xpEvents.filter(e => e.xp < 0);
    
    // Mensagem de eventos positivos
    if (positiveEvents.length > 0) {
      const eventsList = positiveEvents.map(e => `+${e.xp} ${e.name}`).join(', ');
      const totalPositive = positiveEvents.reduce((sum, e) => sum + e.xp, 0);
      
      await supabaseClient.from('chat_messages').insert({
        user_id: myUserId,
        username: username,
        message: `ðŸ’« ${eventsList} (Total: +${totalPositive} XP)`,
        type: 'system_xp',
        avatar: null,
        meta: {}
      });
    }
    
    // Mensagem de eventos negativos
    if (negativeEvents.length > 0) {
      const eventsList = negativeEvents.map(e => `${e.xp} ${e.name}`).join(', ');
      const totalNegative = negativeEvents.reduce((sum, e) => sum + e.xp, 0);
      
      await supabaseClient.from('chat_messages').insert({
        user_id: myUserId,
        username: username,
        message: `âš ï¸ ${eventsList} (Total: ${totalNegative} XP)`,
        type: 'system_xp',
        avatar: null,
        meta: {}
      });
    }
    
    debug.xp('[XP] Eventos postados no chat');
  } catch (err) {
    console.error('[XP] Erro ao postar no chat:', err);
  }
}

// Resetar sistema de XP para nova partida
function resetMatchXP() {
  xpEvents = [];
  xpTotalMatch = 0;
  xpAlreadyApplied = false; // ðŸ”“ Resetar flag para nova partida
  window.__matchEndEventsProcessed = false; // ðŸ”“ Resetar flag de eventos de fim
  resetRoundXPTracking();
}

// Buscar username do oponente (com cache)
async function getOpponentUsername(opponentId) {
  // Verificar cache primeiro
  if (usernameCache.has(opponentId)) {
    return usernameCache.get(opponentId);
  }
  
  try {
    const { data, error } = await supabaseClient
      .from('profiles')
      .select('username')
      .eq('id', opponentId)
      .maybeSingle();
    
    if (error) {
      // Logar erro apenas UMA vez
      if (!usernameErrorLogged.has(opponentId)) {
        console.warn('[PVP] âš ï¸ Erro ao buscar username do oponente:', error.message);
        usernameErrorLogged.add(opponentId);
      }
      usernameCache.set(opponentId, 'Opponent');
      return 'Opponent';
    }
    
    const username = data?.username ?? 'Opponent';
    usernameCache.set(opponentId, username);
    return username;
  } catch (err) {
    if (!usernameErrorLogged.has(opponentId)) {
      console.warn('[PVP] âš ï¸ ExceÃ§Ã£o ao buscar username:', err.message);
      usernameErrorLogged.add(opponentId);
    }
    usernameCache.set(opponentId, 'Opponent');
    return 'Opponent';
  }
}

// Buscar shot preferences do oponente
async function getOpponentShotPreferences(opponentId) {
  try {
    const { data, error } = await supabaseClient
      .from('profiles')
      .select('shot_preferences')
      .eq('id', opponentId)
      .maybeSingle();
    
    
    if (error) {
      console.warn('[PVP] âš ï¸ Erro ao buscar shot_preferences do oponente:', error.message);
      return {}; // Default: todos plasma
    }
    
    const prefs = data?.shot_preferences || {};
    debug.pvp('[PVP] âœ“ Shot preferences do oponente carregadas:', prefs);
    return prefs;
  } catch (err) {
    console.error('[PVP] âŒ ExceÃ§Ã£o ao buscar shot preferences:', err);
    return {};
  }
}

// Ler parÃ¢metros da URL com validaÃ§Ã£o
function getUrlParams() {
  const params = new URLSearchParams(window.location.search);
  
  // UUID regex (8-4-4-4-12)
  const UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
  
  const mode = params.get('mode')?.trim() || null;
  const matchId = params.get('matchId')?.trim() || null;
  const supabaseUrl = params.get('supabaseUrl') ? decodeURIComponent(params.get('supabaseUrl')).trim() : null;
  const supabaseKey = params.get('supabaseKey') ? decodeURIComponent(params.get('supabaseKey')).trim() : null;
  const access_token = params.get('access_token') ? decodeURIComponent(params.get('access_token')).trim() : null;
  const refresh_token = params.get('refresh_token') ? decodeURIComponent(params.get('refresh_token')).trim() : null;
  const userId = params.get('userId') ? decodeURIComponent(params.get('userId')).trim() : null;
  
  // Validar matchId como UUID (ignorar fake matchIds usados em modo treino)
  if (matchId && !UUID_REGEX.test(matchId) && !matchId.startsWith('fake-')) {
    console.error('[URL] âŒ matchId invÃ¡lido (nÃ£o Ã© UUID):', matchId);
    return { mode, matchId: null, supabaseUrl, supabaseKey, access_token, refresh_token, userId, error: 'matchId invÃ¡lido' };
  }
  
  // Validar userId como UUID (se presente)
  if (userId && !UUID_REGEX.test(userId)) {
    console.error('[URL] âŒ userId invÃ¡lido (nÃ£o Ã© UUID):', userId);
    return { mode, matchId, supabaseUrl, supabaseKey, access_token, refresh_token, userId: null, error: 'userId invÃ¡lido' };
  }
  
  return { mode, matchId, supabaseUrl, supabaseKey, access_token, refresh_token, userId };
}

// Inicializar modo multiplayer real
async function initMultiplayerMode(matchId) {
  // âœ… XP: Resetar sistema de XP para nova partida
  resetMatchXP();
  debug.pvp('[PVP] âœ… Sistema de XP resetado para nova partida');
  
  // (A1) GUARD: NÃ£o inicializar duas vezes para o mesmo match
  if (window.__pvpInitializedForMatchId === matchId) {
    debug.pvp('[PVP] âš ï¸ JÃ¡ inicializado para matchId:', matchId, '- ignorando');
    return true;
  }
  
  // (A2) Limpar channels anteriores antes de criar novos
  if (window.__pvpChannel) {
    debug.pvp('[PVP] Limpando channel anterior...');
    try {
      await window.__pvpChannel.unsubscribe();
      window.__pvpChannel = null;
    } catch (err) {
      console.warn('[PVP] Erro ao limpar channel anterior:', err);
    }
  }
  
  try {
    debug.pvp('[PVP] ========================================');
    debug.pvp('[PVP] Inicializando modo multiplayer');
    debug.pvp('[PVP] matchId recebido:', matchId);
    
    // STEP 1: Ler parÃ¢metros da URL
    const urlParams = getUrlParams();
    
    // Validar params crÃ­ticos
    if (urlParams.error) {
      console.error('[PVP] âŒ Erro nos parÃ¢metros da URL:', urlParams.error);
      alert('Erro: ' + urlParams.error);
      multiplayerMode = false;
      return;
    }
    
    if (!urlParams.matchId) {
      console.error('[PVP] âŒ matchId ausente ou invÃ¡lido');
      alert('Erro: matchId nÃ£o fornecido na URL');
      multiplayerMode = false;
      return;
    }
    
    if (!urlParams.supabaseUrl || !urlParams.supabaseKey) {
      console.error('[PVP] âŒ supabaseUrl ou supabaseKey ausente');
      alert('Erro: ConfiguraÃ§Ã£o do Supabase ausente');
      multiplayerMode = false;
      return;
    }
    
    // STEP 2: Criar Supabase client com tokens
    
    if (typeof supabase === 'undefined') {
      throw new Error('Supabase SDK nÃ£o carregado');
    }
    
    const { createClient } = supabase;
    if (!createClient) {
      throw new Error('supabase.createClient nÃ£o encontrado');
    }
    
    // Criar client sem persist session
    supabaseClient = createClient(urlParams.supabaseUrl, urlParams.supabaseKey, {
      auth: {
        persistSession: false,
        autoRefreshToken: false
      }
    });
    debug.pvp('[PVP] âœ“ Supabase client criado');
    
    // STEP 3: Autenticar via tokens (se disponÃ­veis) - ANTES de qualquer query
    let authenticatedUser = null;
    
    if (urlParams.access_token && urlParams.refresh_token) {
      
      try {
        const { data: sessionData, error: sessionError } = await supabaseClient.auth.setSession({
          access_token: urlParams.access_token,
          refresh_token: urlParams.refresh_token
        });
        
        if (sessionError) {
          console.warn('[PVP] âš ï¸ setSession falhou (token expirado?):', sessionError.message);
          // Continuar com userId da URL mesmo se setSession falhar
          myUserId = urlParams.userId;
        } else if (!sessionData?.session) {
          console.warn('[PVP] âš ï¸ setSession nÃ£o retornou sessÃ£o');
          myUserId = urlParams.userId;
        } else {
          debug.pvp('[PVP] âœ“ SessÃ£o estabelecida');
          
          const { data: userData, error: userError } = await supabaseClient.auth.getUser();
          
          if (!userError && userData?.user) {
            authenticatedUser = userData.user;
            myUserId = authenticatedUser.id;
            debug.pvp('[PVP] âœ“ Autenticado como:', myUserId);
          } else {
            console.warn('[PVP] âš ï¸ getUser falhou:', userError?.message);
            myUserId = urlParams.userId;
          }
        }
        
        // Limpar tokens da URL (manter sÃ³ mode e matchId)
        const cleanUrl = new URL(window.location.href);
        cleanUrl.searchParams.delete('access_token');
        cleanUrl.searchParams.delete('refresh_token');
        window.history.replaceState({}, document.title, cleanUrl.toString());
        
      } catch (authErr) {
        console.warn('[PVP] âš ï¸ ExceÃ§Ã£o ao autenticar (usando userId da URL):', authErr.message);
        myUserId = urlParams.userId;
      }
    } else {
      myUserId = urlParams.userId || window.THOR_PLAYER?.userId;
    }
    
    if (!myUserId) {
      console.error('[PVP] âŒ userId nÃ£o disponÃ­vel');
      alert('Erro: NÃ£o foi possÃ­vel identificar o usuÃ¡rio');
      multiplayerMode = false;
      return;
    }
    
    debug.pvp('[PVP] âœ“ userId final:', myUserId);
    
    // Salvar userId no localStorage para ShotTypeManager
    localStorage.setItem('thor_user_id', myUserId);
    debug.pvp('[PVP] âœ“ thor_user_id salvo no localStorage');
    
    // STEP 4: Buscar dados do match via supabase-js
    
    const { data: match, error: matchError } = await supabaseClient
      .from('matches')
      .select('*')
      .eq('id', matchId)
      .maybeSingle();
    
    if (matchError) {
      console.error('[PVP] âŒ Erro ao buscar match:', matchError);
      alert('Erro ao carregar partida: ' + (matchError.message || 'Erro desconhecido'));
      multiplayerMode = false;
      return false;
    }
    
    if (!match) {
      console.error('[PVP] âŒ Match nÃ£o encontrado (id: ' + matchId + ')');
      console.error('[PVP] PossÃ­vel problema: match foi deletado ou RLS bloqueando acesso');
      alert('Partida nÃ£o encontrada. Ela pode ter sido cancelada ou vocÃª nÃ£o tem permissÃ£o para acessÃ¡-la.');
      multiplayerMode = false;
      return false;
    }
    
    debug.pvp('[PVP] âœ“ Match carregado:', {
      id: match.id,
      player1_id: match.player1_id,
      player2_id: match.player2_id,
      state: match.state,
      phase: match.phase,
      turn_user_id: match.turn_user_id,
      turn_number: match.turn_number
    });
    
    matchData = match;
    currentPhase = match.phase || 'select';
    currentTurn = match.turn || 'blue';
    
    // STEP 5: Determinar meu time DETERMINISTICAMENTE via player1_id/player2_id
    
    // Usar EXCLUSIVAMENTE player1_id e player2_id (ignorar invite_from/invite_to)
    player1_id = match.player1_id || match.player1;
    player2_id = match.player2_id || match.player2;
    
    if (!player1_id || !player2_id) {
      throw new Error(`Match sem player1_id ou player2_id definidos (player1_id: ${player1_id}, player2_id: ${player2_id})`);
    }
    
    // ValidaÃ§Ã£o de permissÃ£o - BLOQUEAR se nÃ£o for participante
    if (myUserId !== player1_id && myUserId !== player2_id) {
      throw new Error(`âŒ ACESSO NEGADO: VocÃª nÃ£o Ã© participante deste match\nmyUserId: ${myUserId}\nplayer1_id: ${player1_id}\nplayer2_id: ${player2_id}`);
    }
    
    // Determinar time deterministicamente
    if (myUserId === player1_id) {
      myTeam = 'blue';
      opponentUserId = player2_id;
      debug.pvp('[PVP] âœ“ EU SOU BLUE (player1_id)');
    } else if (myUserId === player2_id) {
      myTeam = 'red';
      opponentUserId = player1_id;
      debug.pvp('[PVP] âœ“ EU SOU RED (player2_id)');
    }
    
    // Determinar turno baseado em turn_user_id (nÃ£o turn_team)
    turnUserId = match.turn_user_id || player1_id; // Default: player1 comeÃ§a
    isMyTurn = (turnUserId === myUserId);
    
    debug.pvp('[PVP] âœ“ Meu time:', myTeam.toUpperCase());
    debug.pvp('[PVP] âœ“ player1_id (BLUE):', player1_id);
    debug.pvp('[PVP] âœ“ player2_id (RED):', player2_id);
    debug.pvp('[PVP] âœ“ turn_user_id:', turnUserId);
    debug.pvp('[PVP] âœ“ isMyTurn:', isMyTurn);
    
    // STEP 6: Buscar username do oponente (com cache e maybeSingle)
    opponentUsername = await getOpponentUsername(opponentUserId);
    debug.pvp('[PVP] âœ“ Oponente:', opponentUsername);
    
    // STEP 6.5: Buscar shot preferences do oponente
    opponentShotPreferences = await getOpponentShotPreferences(opponentUserId);
    
    // STEP 6.6: Garantir que minhas prÃ³prias preferÃªncias estejam salvas no banco
    // (caso o usuÃ¡rio nÃ£o tenha aberto o modal de shot type)
    await ShotTypeManager.saveToSupabase();
    
    // STEP 7: Ativar modo multiplayer
    multiplayerMode = true;
    PVP.hasInitialized = true;
    debug.pvp('[PVP] âœ“âœ“âœ“ MODO MULTIPLAYER ATIVADO (DETERMINÃSTICO) âœ“âœ“âœ“');
    debug.pvp('[PVP] Resumo:');
    debug.pvp('[PVP]   - Meu time:', myTeam.toUpperCase());
    debug.pvp('[PVP]   - Meu ID:', myUserId);
    debug.pvp('[PVP]   - Oponente:', opponentUsername, '('+opponentUserId+')');
    debug.pvp('[PVP]   - player1_id (BLUE):', player1_id);
    debug.pvp('[PVP]   - player2_id (RED):', player2_id);
    debug.pvp('[PVP]   - Fase:', currentPhase);
    debug.pvp('[PVP]   - turn_user_id:', turnUserId);
    debug.pvp('[PVP]   - Ã‰ meu turno?', isMyTurn);
    debug.pvp('[PVP] CPU DESABILITADA - PVP REAL');
    debug.pvp('[PVP] ========================================');
    
    // Salvar no localStorage
    localStorage.setItem('thor_match_opponent_name', opponentUsername);
    
    // Configurar realtime para sincronizaÃ§Ã£o de estado e eventos
    setupMatchStateSync(matchId);
    
    setupMatchEventsSync(matchId);
    
    // Iniciar sistema de heartbeat para detectar desconexÃ£o
    startHeartbeat();
    
    // F) Se jÃ¡ estiver em battle (recarga de pÃ¡gina), iniciar sync de movimento
    if (currentPhase === 'battle') {
      debug.pvp('[PVP] Match jÃ¡ em battle, inicializando syncChannel...');
      setupMultiplayerSync(matchId);
    }
    
    // (A3) Marcar como inicializado para este matchId
    window.__pvpInitializedForMatchId = matchId;
    debug.pvp('[PVP] âœ… InicializaÃ§Ã£o completa para matchId:', matchId);
    
    return true;
  } catch (err) {
    console.error('[PVP] ========================================');
    console.error('[PVP] âŒ EXCEÃ‡ÃƒO FATAL na inicializaÃ§Ã£o do multiplayer:');
    console.error('[PVP]', err);
    console.error('[PVP] Stack:', err.stack);
    console.error('[PVP] ========================================');
    return false;
  }
}

// ============================================
// SISTEMA DE HEARTBEAT (detectar desconexÃ£o)
// ============================================

// Enviar heartbeat a cada 3 segundos
function startHeartbeat() {
  if (!multiplayerMode || !supabaseClient || !matchData) return;
  
  debug.log('[HEARTBEAT] Iniciando sistema de heartbeat');
  
  // Enviar heartbeat imediatamente
  sendHeartbeat();
  
  // Enviar heartbeat a cada 3s
  heartbeatInterval = setInterval(() => {
    sendHeartbeat();
  }, 3000);
  // NOTA: WO via heartbeat removido. WO sÃ³ ocorre via presence leave (ao sair da pÃ¡gina).
}

// Enviar meu heartbeat
async function sendHeartbeat() {
  if (!supabaseClient || !matchData || currentPhase === 'finished') return;
  
  try {
    const isPlayer1 = myUserId === matchData.player1_id;
    const field = isPlayer1 ? 'player1_last_seen' : 'player2_last_seen';
    
    await supabaseClient
      .from('matches')
      .update({ [field]: new Date().toISOString() })
      .eq('id', matchData.id);
    
    debug.log('[HEARTBEAT] â¤ï¸ Enviado');
  } catch (err) {
    console.error('[HEARTBEAT] Erro ao enviar:', err);
  }
}

// checkOpponentHeartbeat desativado â€” WO sÃ³ ocorre quando o oponente sai da pÃ¡gina (beforeunload / presence leave).
// Manter funÃ§Ã£o stub para evitar erros de referÃªncia em outros lugares.
function checkOpponentHeartbeat() {}

// Parar heartbeat
function stopHeartbeat() {
  if (heartbeatInterval) {
    clearInterval(heartbeatInterval);
    heartbeatInterval = null;
    debug.log('[HEARTBEAT] Parando envio de heartbeat');
  }
  if (opponentLastSeenCheck) {
    clearInterval(opponentLastSeenCheck);
    opponentLastSeenCheck = null;
    debug.log('[HEARTBEAT] Parando verificaÃ§Ã£o de oponente');
  }
}

// ============================================
// REALTIME SYNC
// ============================================

// Configurar sincronizaÃ§Ã£o de estado do match via Realtime
function setupMatchStateSync(matchId) {
  if (!supabaseClient) {
    console.error('[REALTIME] supabaseClient nÃ£o existe');
    return;
  }
  
  if (matchStateChannel) {
    debug.realtime('[REALTIME] âš ï¸ matchStateChannel jÃ¡ existe, nÃ£o criar duplicado');
    return;
  }
  
  try {
    debug.realtime('[REALTIME] ðŸ”— Criando canal de estado para match:', matchId);
    matchStateChannel = supabaseClient.channel(`match-state:${matchId}`)
      .on('postgres_changes', {
        event: 'UPDATE',
        schema: 'public',
        table: 'matches',
        filter: `id=eq.${matchId}`
      }, (payload) => {
        debug.realtime('[REALTIME] ðŸ“¨ UPDATE recebido no match:', payload);
        handleMatchUpdate(payload);
      })
      .on('presence', { event: 'sync' }, () => {
        const presenceState = matchStateChannel.presenceState();
        debug.log('[PRESENCE] Estado sincronizado:', presenceState);
        
        // Verificar presenÃ§a do oponente e atualizar botÃ£o Pronto
        if (multiplayerMode && matchData) {
          const amIOnline = isUserInPresence(presenceState, myUserId);
          const isOpponentOnline = isUserInPresence(presenceState, opponentUserId);
          
          debug.log('[PRESENCE] Eu online?', amIOnline);
          debug.log('[PRESENCE] Oponente online?', isOpponentOnline);

          // Detectar entrada do oponente para habilitar botÃ£o Pronto
          if (isOpponentOnline && !opponentInGame) {
            opponentInGame = true;
            debug.log('[PRESENCE] âœ… Oponente entrou no jogo! Habilitando botÃ£o Pronto.');
            updateReadyBtnState();
          }

          // WO apenas durante batalha â€” nunca durante seleÃ§Ã£o/loading
          if (currentPhase === 'battle' && amIOnline && !isOpponentOnline) {
            debug.log('[PRESENCE] ðŸšª Oponente desconectou durante batalha! Aplicando WO em 3s...');
            setTimeout(() => {
              const stateAfterDelay = matchStateChannel.presenceState();
              if (!isUserInPresence(stateAfterDelay, opponentUserId) && currentPhase === 'battle') {
                debug.log('[PRESENCE] Confirmado: oponente desconectado. Aplicando WO...');
                applyWalkover();
              }
            }, 3000);
          }
        }
      })
      .on('presence', { event: 'join' }, ({ key, newPresences }) => {
        debug.log('[PRESENCE] Jogador entrou:', key, newPresences);
        // newPresences Ã© array de objetos com user_id
        const joinedUserId = newPresences && newPresences[0]?.user_id;
        if (joinedUserId === opponentUserId && multiplayerMode) {
          opponentInGame = true;
          debug.log('[PRESENCE] âœ… Oponente entrou! Habilitando botÃ£o Pronto.');
          updateReadyBtnState();
        }
      })
      .on('presence', { event: 'leave' }, ({ key, leftPresences }) => {
        debug.log('[PRESENCE] Jogador saiu:', key, leftPresences);
        
        // Se o oponente saiu â€” WO apenas durante batalha, nunca durante seleÃ§Ã£o
        const leftUserId = leftPresences && leftPresences[0]?.user_id;
        if (leftUserId === opponentUserId && multiplayerMode && matchData) {
          opponentInGame = false;
          updateReadyBtnState();
          if (currentPhase === 'battle') {
            debug.log('[PRESENCE] ðŸšª Oponente saiu durante batalha! Aplicando WO em 2s...');
            setTimeout(() => {
              if (currentPhase === 'battle') {
                applyWalkover();
              }
            }, 2000);
          }
        }
      })
      .subscribe(async (status) => {
        debug.realtime('[REALTIME] ðŸ”” Status da conexÃ£o:', status);
        if (status === 'SUBSCRIBED') {
          debug.realtime('[REALTIME] âœ… Canal de estado SUBSCRIBED');
          window.__pvpChannel = matchStateChannel;
          
          // Registrar minha presenÃ§a com track
          const trackStatus = await matchStateChannel.track({
            user_id: myUserId,
            username: localStorage.getItem('thor_username') || 'Player',
            online_at: new Date().toISOString()
          });
          
          debug.log('[PRESENCE] âœ… Track status:', trackStatus);
          debug.log('[PRESENCE] Minha presenÃ§a registrada como:', myUserId);
          
          // Log estado inicial
          setTimeout(() => {
            const initialState = matchStateChannel.presenceState();
            debug.log('[PRESENCE] Estado inicial:', initialState);
          }, 1000);
        } else if (status === 'CHANNEL_ERROR') {
          console.error('[REALTIME] âŒ Erro no canal');
        } else if (status === 'TIMED_OUT') {
          console.error('[REALTIME] â° Timeout na conexÃ£o');
        }
      });
  } catch (err) {
    console.error('[REALTIME] Erro ao configurar sync de estado:', err);
  }
}

// Aplicar walkover quando oponente desconecta
async function applyWalkover() {
  if (!supabaseClient || !matchData || currentPhase === 'finished') {
    return;
  }
  
  
  try {
    const { error } = await supabaseClient
      .from('matches')
      .update({
        phase: 'finished',
        winner_id: myUserId,
        wo: true,
        finished_at: new Date().toISOString()
      })
      .eq('id', matchData.id)
      .eq('phase', 'battle'); // Apenas se ainda estiver em battle
    
    if (error) {
      console.error('[WO] Erro ao aplicar WO:', error);
    } else {
    }
  } catch (err) {
    console.error('[WO] ExceÃ§Ã£o ao aplicar WO:', err);
  }
}

// Configurar sincronizaÃ§Ã£o de eventos do match (tiros/movimentos) via Realtime
function setupMatchEventsSync(matchId) {
  
  if (!supabaseClient || matchEventsChannel) {
    console.warn('[AAA-EVENTS] âš ï¸ Saindo early - supabaseClient:', !!supabaseClient, 'matchEventsChannel:', !!matchEventsChannel);
    return;
  }
  
  try {
    
    matchEventsChannel = supabaseClient.channel(`match-events:${matchId}`)
      .on('postgres_changes', {
        event: 'INSERT',
        schema: 'public',
        table: 'match_events',
        filter: `match_id=eq.${matchId}`
      }, handleMatchEventAAA) // ðŸ”¥ AAA: Usar handler com event queue
      .subscribe((status) => {
        
        if (status === 'SUBSCRIBED') {
        } else if (status === 'CHANNEL_ERROR') {
          console.error('[AAA-EVENTS] âŒ Erro no canal');
        } else if (status === 'TIMED_OUT') {
          console.error('[AAA-EVENTS] â±ï¸ Timeout na conexÃ£o');
        }
      });
  } catch (err) {
    console.error('[AAA-EVENTS] âŒ Erro ao configurar sync:', err);
  }
}

// Handler para eventos do match (tiros, movimentos, etc)
function handleMatchEvent(payload) {
  const event = payload.new;
  
  
  // Ignorar meus prÃ³prios eventos (jÃ¡ executei localmente)
  if (event.user_id === myUserId) {
    return;
  }
  
  // Reproduzir evento do oponente
  try {
    switch (event.type) {
      case 'move':
        applyOpponentMove(event.payload);
        break;
      
      case 'shoot':
        applyOpponentShoot(event.payload);
        break;
      
      case 'damage':
        applyDamage(event.payload);
        break;
      
      default:
        console.warn('[EVENTS] âš ï¸ Tipo de evento desconhecido:', event.type);
    }
  } catch (err) {
    console.error('[EVENTS] âŒ Erro ao processar evento:', err);
  }
}

// Enviar evento de aÃ§Ã£o para o match
async function sendMatchEvent(type, payload) {
  if (!supabaseClient || !matchData) {
    console.error('[EVENTS] âŒ NÃ£o Ã© possÃ­vel enviar evento sem supabaseClient ou matchData');
    return false;
  }
  
  try {
    const event = {
      match_id: matchData.id,
      user_id: myUserId,
      turn_number: currentTurnNumber,
      type: type,
      payload: payload
    };
    
    
    const { error } = await supabaseClient
      .from('match_events')
      .insert([event]);
    
    if (error) {
      console.error('[EVENTS] âŒ Erro ao enviar evento:', error);
      return false;
    }
    
    return true;
  } catch (err) {
    console.error('[EVENTS] âŒ ExceÃ§Ã£o ao enviar evento:', err);
    return false;
  }
}

// ========================================
// AAA MULTIPLAYER: Authoritative Event System
// ========================================

// P1 (HOST): Enviar evento de hit (authoritative)
// ðŸ“¸ AAA PHASE 2: Snapshots periÃ³dicos (self-healing)
let snapshotInterval = null;
let lastSnapshotTime = 0;
const SNAPSHOT_INTERVAL_MS = 3000; // 3 segundos

// Enviar snapshot completo do estado do jogo
async function sendSnapshot() {
  if (!isPlayer1Host || !multiplayerMode) return;
  // ðŸ”’ PosiÃ§Ãµes sÃ£o determinÃ­sticas via applyResolvedTurn â€” snapshots durante planejamento
  // causam ghost/drift no oponente. Desabilitado: posiÃ§Ãµes canÃ´nicas vÃªm do payload do turno.
  return;
  
  try {
    const snapshot = {
      match_id: matchData.id,
      sequence_number: eventSequence++,
      type: 'STATE_SNAPSHOT',
      user_id: myUserId,
      payload: {
        player_naves: playerNaves.map(n => ({
          x: n.x,
          y: n.y,
          hp: n.hp,
          tipo: n.tipo
        })),
        cpu_naves: cpuNaves.map(n => ({
          x: n.x,
          y: n.y,
          hp: n.hp,
          tipo: n.tipo
        })),
        player_destroyed: playerDestroyed,
        cpu_destroyed: cpuDestroyed,
        timestamp: Date.now()
      },
      timestamp: new Date().toISOString()
    };
    
    const { error } = await supabaseClient
      .from('match_events')
      .insert([snapshot]);
    
    if (error) {
      console.error('[AAA-SNAPSHOT] âŒ Erro ao enviar:', error);
      return false;
    }
    
    lastSnapshotTime = Date.now();
    return true;
  } catch (err) {
    console.error('[AAA-SNAPSHOT] âŒ ExceÃ§Ã£o:', err);
    return false;
  }
}

async function sendHitEvent(hitData) {
  if (!isPlayer1Host || !multiplayerMode) return;
  
  try {
    // ðŸ”¥ PHASE 2: Enviar HP_UPDATE ao invÃ©s de PROJECTILE_HIT
    const event = {
      match_id: matchData.id,
      sequence_number: eventSequence++,
      type: 'HP_UPDATE',
      user_id: myUserId,
      payload: {
        hit_id: hitData.hitId,
        projectile_id: hitData.projectileId,
        target_team: hitData.targetTeam,
        target_index: hitData.targetIndex,
        hp_final: hitData.hpAfter, // HP FINAL (nÃ£o delta)
        destroyed: hitData.destroyed,
        position: hitData.position,
        timestamp: Date.now()
      },
      timestamp: new Date().toISOString()
    };
    
    const { data, error } = await supabaseClient
      .from('match_events')
      .insert([event])
      .select();
    
    if (error) {
      console.error('[AAA-HIT] âŒ Erro ao enviar hit:', error);
      return false;
    }
    
    return true;
  } catch (err) {
    console.error('[AAA-HIT] âŒ ExceÃ§Ã£o:', err);
    return false;
  }
}

// ðŸ”¥ PHASE 3: Client-Side Prediction + Dead Reckoning
// Armazenar velocidades para prediÃ§Ã£o de movimento
const shipVelocities = new Map(); // shipId -> {vx, vy}

// ðŸ”¥ PHASE 2: Processar snapshot de estado completo
function processSnapshot(event) {
  const payload = event.payload;
  
  // P1 perspective: playerNaves = blue, cpuNaves = red
  // P2 perspective: playerNaves = red, cpuNaves = blue
  // Inverter arrays ao aplicar snapshot
  const p1PlayerNaves = payload.player_naves; // blue (P1)
  const p1CpuNaves = payload.cpu_naves; // red (P2)
  
  // Do ponto de vista do P2:
  // - p1PlayerNaves (blue) = minhas cpuNaves
  // - p1CpuNaves (red) = minhas playerNaves
  
  // âš ï¸ Durante combate (phase='wait'), posiÃ§Ãµes sÃ£o determinÃ­sticas em ambos os clientes.
  // Snapshots sÃ³ devem corrigir posiÃ§Ã£o na fase de seleÃ§Ã£o, nunca durante a animaÃ§Ã£o.
  const inCombat = (phase === 'wait');

  // Aplicar HP autoritativo (com reconciliaÃ§Ã£o suave para posiÃ§Ãµes)
  for (let i = 0; i < p1PlayerNaves.length && i < cpuNaves.length; i++) {
    const serverState = p1PlayerNaves[i];
    const localShip = cpuNaves[i];
    
    // HP: sempre sincronizar
    if (localShip.hp !== serverState.hp) {
      localShip.hp = serverState.hp;
    }
    
    // PosiÃ§Ã£o: apenas fora do combate (durante seleÃ§Ã£o/espera)
    if (!inCombat) {
      const shipId = `cpu_${i}`;
      const oldPos = shipVelocities.get(shipId) || { x: localShip.x, y: localShip.y };
      const vx = serverState.x - oldPos.x;
      const vy = serverState.y - oldPos.y;
      shipVelocities.set(shipId, { x: serverState.x, y: serverState.y, vx, vy });
      
      const dx = serverState.x - localShip.x;
      const dy = serverState.y - localShip.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      if (distance > 15) {
        const lerpFactor = Math.min(0.2, distance / 100);
        localShip.x += dx * lerpFactor;
        localShip.y += dy * lerpFactor;
      }
    }
  }
  
  for (let i = 0; i < p1CpuNaves.length && i < playerNaves.length; i++) {
    const serverState = p1CpuNaves[i];
    const localShip = playerNaves[i];
    
    // HP: sempre sincronizar
    if (localShip.hp !== serverState.hp) {
      localShip.hp = serverState.hp;
    }
    
    // PosiÃ§Ã£o: apenas fora do combate
    if (!inCombat) {
      const shipId = `player_${i}`;
      const oldPos = shipVelocities.get(shipId) || { x: localShip.x, y: localShip.y };
      const vx = serverState.x - oldPos.x;
      const vy = serverState.y - oldPos.y;
      shipVelocities.set(shipId, { x: serverState.x, y: serverState.y, vx, vy });
      
      const dx = serverState.x - localShip.x;
      const dy = serverState.y - localShip.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      if (distance > 15) {
        const lerpFactor = Math.min(0.2, distance / 100);
        localShip.x += dx * lerpFactor;
        localShip.y += dy * lerpFactor;
      }
    }
  }
  
  // Atualizar placar
  cpuDestroyed = payload.player_destroyed;
  playerDestroyed = payload.cpu_destroyed;
}

// P2 (CLIENT): Processar evento de HP update
function processHitEvent(event) {
  const payload = event.payload;
  
  // Verificar se jÃ¡ processamos este hit (evitar duplicatas)
  if (projectileHitRegistry.has(payload.hit_id)) {
    return;
  }
  projectileHitRegistry.add(payload.hit_id);
  
  // ðŸ”¥ IMPORTANTE: Inverter perspectiva!
  // P1 envia "cpu" quando atira nas naves vermelhas (do P2)
  // Mas do ponto de vista do P2, essas sÃ£o suas naves "player"
  // EntÃ£o invertemos: cpu â†” player
  const targetTeamInverted = payload.target_team === 'player' ? 'cpu' : 'player';
  const targets = targetTeamInverted === 'player' ? playerNaves : cpuNaves;
  const target = targets[payload.target_index];
  
  if (!target) {
    return;
  }
  
  // ðŸ”¥ PHASE 2: Aplicar HP FINAL (nÃ£o delta)
  const oldHp = target.hp;
  target.hp = payload.hp_final; // HP autoritativo do P1
  
  // Remover projÃ©til correspondente se existir
  const projectileIndex = projectiles.findIndex(p => p.id === payload.projectile_id);
  if (projectileIndex >= 0) {
    projectiles.splice(projectileIndex, 1);
  }
  
  // ðŸ”¥ AAA: Efeitos visuais APENAS se projÃ©til ainda existia
  // Se jÃ¡ foi removido visualmente, nÃ£o duplicar efeitos
  if (projectileIndex >= 0) {
    explosions.push({ x: payload.position.x, y: payload.position.y, radius: 1 });
    try {
      playHit();
    } catch (e) {}
  }
  
  if (payload.destroyed) {
    try {
      if (!sfxMuted) sfxExplode.play().catch(e => {});
    } catch (e) {}
    wrecks.push({ x: target.x, y: target.y });
    
    const teamColor = payload.target_team === 'cpu' ? '#ff6600' : '#0ff';
    spawnExplosionParticles(target.x, target.y, teamColor);
    
    screenShake = 10;
    
    // Atualizar placar (usar team INVERTIDA)
    if (targetTeamInverted === 'cpu') {
      cpuDestroyed++;
      playerScore += 100;
    } else {
      playerDestroyed++;
      navesPerdidas++;
    }
  }
}

// Processar fila de eventos em ordem
function processEventQueue() {
  if (eventQueue.length === 0) return;
  
  // Ordenar por sequence_number e processar todos de uma vez.
  // HP_UPDATE Ã© idempotente (hp_final absoluto) â€” projectileHitRegistry garante sem duplicatas.
  // Remover stall sequencial: se um evento chegar fora de ordem, nÃ£o travar a fila.
  eventQueue.sort((a, b) => a.sequence_number - b.sequence_number);
  
  while (eventQueue.length > 0) {
    const event = eventQueue.shift();
    
    // Ignorar duplicatas jÃ¡ processadas
    if (event.sequence_number <= lastProcessedSequence) continue;
    
    if (event.type === 'HP_UPDATE' || event.type === 'PROJECTILE_HIT') {
      processHitEvent(event);
    } else if (event.type === 'STATE_SNAPSHOT') {
      processSnapshot(event);
    }
    
    lastProcessedSequence = event.sequence_number;
  }
}

// Handler melhorado para eventos do match (com queue)
function handleMatchEventAAA(payload) {
  const event = payload.new;
  
  // Ignorar meus prÃ³prios eventos (jÃ¡ executei localmente)
  if (event.user_id === myUserId) {
    return;
  }
  
  // Adicionar Ã  fila
  eventQueue.push(event);
  
  // Processar fila
  processEventQueue();
}

// Aplicar movimento do oponente (placeholder - implementar lÃ³gica real)
function applyOpponentMove(payload) {
  // TODO: Implementar lÃ³gica de movimento baseada em payload
  // payload deve conter: { shipIndex, fromX, fromY, toX, toY }
}

// Aplicar tiro do oponente (placeholder - implementar lÃ³gica real)
function applyOpponentShoot(payload) {
  // TODO: Implementar lÃ³gica de tiro baseada em payload
  // payload deve conter: { shipIndex, targetX, targetY, weaponType }
}

// Aplicar dano (placeholder - implementar lÃ³gica real)
function applyDamage(payload) {
  // TODO: Implementar lÃ³gica de dano baseada em payload
  // payload deve conter: { targetShipIndex, damage, isDestroyed }
}

// (A) Turn transition guard global - evita aplicar transiÃ§Ã£o mÃºltiplas vezes
let lastAppliedTurnIndex = null;
let lastAppliedTurnUserId = null;
let isApplyingTurnTransition = false;
let lastResolvedAt = null; // Rastrear Ãºltimo turno resolvido

// (A) Battle start guards - evita iniciar batalha mÃºltiplas vezes
let battleStartApplied = false;
let lastPhase = null;
let isFetchingMatchFallback = false;

// (C) Fallback: buscar match via REST quando payload vier incompleto
async function fetchMatchRow(matchId) {
  if (isFetchingMatchFallback) {
    return null;
  }
  
  isFetchingMatchFallback = true;
  try {
    const { data, error } = await supabaseClient
      .from('matches')
      .select('*')
      .eq('id', matchId)
      .single();
    
    if (error) throw error;
    
    const phase = data?.phase ?? data?.match_phase ?? data?.game_phase ?? data?.state?.phase ?? null;
    
    return data;
  } catch (e) {
    console.warn('âŒ [MATCH] Fallback REST falhou:', e);
    return null;
  } finally {
    isFetchingMatchFallback = false;
  }
}

// Handler para updates do match
async function handleMatchUpdate(payload) {
  // (B) Extrair row com fallbacks
  const row = payload?.new || {};
  // (B) Ler phase com mÃºltiplos fallbacks
  const phase = row.phase ?? row.match_phase ?? row.game_phase ?? row.state?.phase ?? null;
  const state = row.state ?? null;

  // --- TIMER DE SELEÃ‡ÃƒO MULTIPLAYER SYNC ---
  // Se estamos na fase de seleÃ§Ã£o e countdown_started_at foi definido, iniciar timer sincronizado
  if (phase === 'select' && multiplayerMode && row.countdown_started_at) {
    // Sempre dar 15s locais ao receber countdown_started_at â€” evita clock skew entre plataformas.
    const secondsLeft = 15;
    if (!selectionTimerStarted) {
      debug.timer('[TIMER][SYNC] Iniciando timer local 15s para seleÃ§Ã£o de naves (multiplayer):', { secondsLeft });
      cancelSelectionTimer();
      selectionTimeRemaining = secondsLeft;
      selectionTimerStarted = true;
      showSelectionTimer(secondsLeft);
      if (selectionTimerInterval) clearInterval(selectionTimerInterval);
      selectionTimerInterval = setInterval(() => {
        selectionTimeRemaining--;
        showSelectionTimer(selectionTimeRemaining);
        if (selectionTimeRemaining <= 0) {
          clearInterval(selectionTimerInterval);
          selectionTimerInterval = null;
        }
      }, 1000);
      if (selectionTimer) clearTimeout(selectionTimer);
      selectionTimer = setTimeout(async () => {
        debug.timer('[TIMER][SYNC] Timeout de seleÃ§Ã£o atingido (multiplayer sync)');
        if (!window.selectedNaves || window.selectedNaves.length < 3) {
          window.selectedNaves = [1, 1, 1];
          updatePreviews();
        }
        // saveShipSelection() already calls updatePhaseAndStartBattle() when both players are ready.
        // Do NOT call it here unconditionally â€” that would force battle start before opponent is ready.
        await saveShipSelection();
      }, secondsLeft * 1000);
    }
  }
  
  // (D) Detectar mudanÃ§a de phase
  const phaseChanged = phase != null && phase !== lastPhase;
  if (phaseChanged) {
    
    // âœ… AAA: Sincronizar HP do oponente quando houver mudanÃ§a de phase ou HP atualizado
    if (multiplayerMode && (row.player1_hp || row.player2_hp)) {
      const oppHP = (myTeam === 'blue') ? row.player2_hp : row.player1_hp;
      if (oppHP && oppHP.length === 3) {
        debug.sync('[HP-SYNC] Atualizando HP do oponente do banco:', oppHP);
        cpuNaves.forEach((nave, idx) => {
          if (idx < oppHP.length && nave.hp !== oppHP[idx]) {
            const oldHp = nave.hp;
            nave.hp = oppHP[idx];
          }
        });
      }
    }
    
    // Se phase mudou para 'finished', mostrar tela de resultado
    if (phase === 'finished') {
      debug.win('[WIN] ðŸ Match finalizado via Realtime!');
      
      // â›” CRÃTICO: Prevenir processamento mÃºltiplo de finalizaÃ§Ã£o
      if (matchFinalizationProcessed) {
        debug.win('[WIN] â­ï¸ FinalizaÃ§Ã£o jÃ¡ foi processada, ignorando evento Realtime duplicado');
        return;
      }
      matchFinalizationProcessed = true;
      debug.win('[WIN] âœ… Primeira finalizaÃ§Ã£o, processando...');
      
      // Parar heartbeat quando jogo terminar
      stopHeartbeat();
      
      const winner_id = row.winner_id;
      const isWO = row.wo === true;
      
      if (isWO) {
        // ForÃ§ar placar 3x0 para WO
        if (winner_id === myUserId) {
          // Eu ganhei por WO - oponente destruÃ­do 3x0
          cpuNaves.forEach(nave => nave.hp = 0);
          playerNaves.forEach(nave => nave.hp = nave.maxHp || 100);
        } else {
          // Eu perdi por WO - minhas naves destruÃ­das 3x0
          playerNaves.forEach(nave => nave.hp = 0);
          cpuNaves.forEach(nave => nave.hp = nave.maxHp || 100);
        }
      } else {
        // IMPORTANTE: Sincronizar HP do oponente ANTES de mostrar resultado
        // âœ… BUSCAR HP ATUALIZADO DO BANCO PARA GARANTIR SINCRONIZAÃ‡ÃƒO
        debug.win('[WIN] ðŸ”„ Buscando HP atualizado do banco antes de mostrar resultado...');
        
        try {
          const { data: freshMatch, error: fetchError } = await supabaseClient
            .from('matches')
            .select('player1_hp, player2_hp')
            .eq('id', matchData.id)
            .single();
          
          if (!fetchError && freshMatch) {
            const oppHP = (myTeam === 'blue') ? freshMatch.player2_hp : freshMatch.player1_hp;
            if (oppHP && Array.isArray(oppHP) && oppHP.length === 3) {
              debug.win('[WIN] ðŸ“¥ Sincronizando HP final do oponente (do banco):', oppHP);
              cpuNaves.forEach((nave, idx) => {
                if (oppHP[idx] !== undefined) {
                  nave.hp = oppHP[idx];
                }
              });
            } else {
              debug.win('[WIN] âš ï¸ HP do oponente nÃ£o encontrado no banco, usando do payload:', row.player2_hp, row.player1_hp);
              // Fallback: usar HP do payload
              const fallbackHP = (myTeam === 'blue') ? row.player2_hp : row.player1_hp;
              if (fallbackHP && Array.isArray(fallbackHP) && fallbackHP.length === 3) {
                cpuNaves.forEach((nave, idx) => {
                  if (fallbackHP[idx] !== undefined) {
                    nave.hp = fallbackHP[idx];
                  }
                });
              }
            }
          } else {
            debug.win('[WIN] âš ï¸ Erro ao buscar HP do banco:', fetchError);
          }
        } catch (hpSyncErr) {
          console.error('[WIN] ExceÃ§Ã£o ao sincronizar HP:', hpSyncErr);
        }
      }
      
      // Parar o jogo COMPLETAMENTE
      gameActive = false;
      
      // Limpar timers
      if (turnTimerInterval) {
        clearInterval(turnTimerInterval);
        turnTimerInterval = null;
      }
      if (turnTimer) {
        clearTimeout(turnTimer);
        turnTimer = null;
      }
      
      // Calcular finalScoreSaved a partir do HP autoritativo (DB jÃ¡ foi sincronizado acima).
      // checkWinCondition pode nÃ£o ter rodado no P2 se o Realtime chegou antes do game loop terminar.
      // Aqui as cpuNaves jÃ¡ tÃªm HP do banco (linhas acima), entÃ£o o cÃ¡lculo Ã© correto.
      finalScoreSaved = {
        myLost: playerNaves.filter(n => n.hp <= 0).length,
        oppLost: cpuNaves.filter(n => n.hp <= 0).length
      };
      debug.win('[WIN] ðŸ’¾ finalScoreSaved calculado no handler Realtime (apÃ³s HP sync do banco):', finalScoreSaved);
      
      // ðŸŽ® ARQUITETURA AAA: Client-side apenas renderiza
      // Stats sÃ£o atualizadas APENAS pelo HOST via updateMatchAsAuthority
      // Aqui sÃ³ processamos XP local e mostramos resultado

      // Determinar se eu ganhei ou perdi
      let matchResult = null;
      if (winner_id === myUserId) {
        debug.win('[WIN] ðŸŽ‰ EU GANHEI!');
        winner = "VICTORY";
        matchResult = 'win';
        // âœ… XP: Processar eventos de vitÃ³ria
        processMatchEndXPEvents('win');
        applyMatchXP();
        finalXpForChat = xpTotalMatch; // ðŸŽ¯ Salvar XP para chat
        debug.realtime('[REALTIME] ðŸ’¾ finalXpForChat salvo (vitÃ³ria):', finalXpForChat);
        debug.win('[WIN] ðŸ‘¥ Stats atualizadas pelo HOST com autoridade, apenas renderizando');
        showVictoryScreen();
      } else if (winner_id === opponentUserId) {
        debug.win('[WIN] ðŸ˜¢ EU PERDI!');
        winner = "DEFEAT";
        matchResult = 'loss';
        // âœ… XP: Processar eventos de derrota
        debug.win('[WIN] ðŸ” ANTES processMatchEndXPEvents(defeat) - xpTotalMatch:', xpTotalMatch);
        processMatchEndXPEvents('defeat');
        debug.win('[WIN] ðŸ” DEPOIS processMatchEndXPEvents(defeat) - xpTotalMatch:', xpTotalMatch);
        applyMatchXP();
        finalXpForChat = xpTotalMatch; // ðŸŽ¯ Salvar XP para chat (serÃ¡ 0 em derrota)
        debug.realtime('[REALTIME] ðŸ’¾ finalXpForChat salvo (derrota):', finalXpForChat);
        debug.win('[WIN] ðŸ‘¥ Stats atualizadas pelo HOST com autoridade, apenas renderizando');
        showDefeatScreen();
      } else {
        debug.win('[WIN] ðŸ¤ EMPATE!');
        winner = "Empate!";
        matchResult = 'draw';
        // âœ… XP: Processar eventos de empate
        processMatchEndXPEvents('draw');
        applyMatchXP();
        finalXpForChat = xpTotalMatch; // ðŸŽ¯ Salvar XP para chat
        debug.realtime('[REALTIME] ðŸ’¾ finalXpForChat salvo (empate):', finalXpForChat);
        debug.win('[WIN] ðŸ‘¥ Stats atualizadas pelo HOST com autoridade, apenas renderizando');
        showDrawScreen();
      }
      
      document.getElementById('gameCanvas').style.display = "none";
      
      // âš ï¸ NÃƒO enviar mensagem automaticamente via Realtime
      // Aguardar o usuÃ¡rio clicar no botÃ£o "Voltar ao Lobby" (backToStartMenu)
      debug.realtime('[REALTIME] ðŸ“¡ Match finalizado via Realtime');
      debug.realtime('[REALTIME] â³ Aguardando usuÃ¡rio clicar em "Voltar ao Lobby"');
      debug.realtime('[REALTIME] xpTotalMatch:', xpTotalMatch);
      debug.realtime('[REALTIME] Modo:', multiplayerMode ? 'Multiplayer' : 'Solo');
      
      // IMPORTANTE: Retornar para nÃ£o processar mais nada
      return;
    }
  }
  if (phase != null) lastPhase = phase;
  
  // Atualizar matchData
  matchData = { ...matchData, ...row };
  
  // Sincronizar HP do oponente se houver atualizaÃ§Ã£o
  if (row.player1_hp || row.player2_hp) {
    const oppHP = (myTeam === 'blue') ? row.player2_hp : row.player1_hp;
    if (oppHP && Array.isArray(oppHP) && oppHP.length === 3) {
      debug.sync('[SYNC] ðŸ“¥ Recebendo HP do oponente do banco:', oppHP);
      // Aplicar HP em cpuNaves (naves do oponente)
      cpuNaves.forEach((nave, idx) => {
        if (oppHP[idx] !== undefined && nave.initialized) {
          const oldHP = nave.hp;
          // âœ… AAA: Sempre sincronizar HP do banco (fonte da verdade)
          // No inÃ­cio do round, o banco tem HP cheio. Durante batalha, HP reduzido.
          nave.hp = oppHP[idx];
          if (oldHP !== nave.hp) {
          }
        }
      });
    }
  }
  
  // Detectar se o turno foi resolvido (turn_resolved_at mudou de null para timestamp)
  const turn_resolved_at = row.turn_resolved_at;
  const turn_number_db = row.turn_number || 1;
  
  if (turn_resolved_at && turn_resolved_at !== lastResolvedAt) {
    
    lastResolvedAt = turn_resolved_at;
    
    // Ler as aÃ§Ãµes do turno resolvido (de last_action_* que foram salvos)
    const action_blue = row.last_action_blue || { type: 'idle' };
    const action_red = row.last_action_red || { type: 'idle' };
    
    
    // AAA SYNC BARRIER: sinalizar que recebi os dados e aguardar oponente
    pendingAnimActions = { action_blue, action_red };
    selfAnimReady = true;

    // Broadcast para o oponente que estou pronto para animar
    if (syncChannel) {
      try {
        syncChannel.send({ type: 'broadcast', event: 'ANIM_READY', payload: { userId: myUserId, turnKey: turn_resolved_at } });
      } catch (e) { console.warn('[SYNC] Erro ao enviar ANIM_READY:', e); }
    }

    // Se oponente jÃ¡ enviou ANIM_READY antes de mim
    if (opponentAnimReady) {
      if (animReadyTimeout) { clearTimeout(animReadyTimeout); animReadyTimeout = null; }
      applyResolvedTurn(pendingAnimActions);
    } else {
      // Fallback: se oponente nÃ£o responder em 1.5s, animar de qualquer jeito
      if (animReadyTimeout) clearTimeout(animReadyTimeout);
      animReadyTimeout = setTimeout(() => {
        if (pendingAnimActions && !window.__lastAppliedTurnKey) {
          console.warn('[SYNC] â° Fallback: oponente nÃ£o respondeu ANIM_READY, animando sozinho');
          applyResolvedTurn(pendingAnimActions);
        }
        animReadyTimeout = null;
      }, 1500);
    }
    
    // Atualizar turno local APÃ“S aplicar as aÃ§Ãµes
    currentTurnNumber = turn_number_db;
  }
  
  // (E) REGRA PRINCIPAL: se phase === 'battle', iniciar batalha 1 vez
  if (phase === 'battle' && !battleStartApplied) {
    battleStartApplied = true;
    startBattleFromSelection();
    return;
  }
  
  // (F) Se phase veio null/undefined, fazer fallback REST
  if ((!phase || phase === undefined) && !battleStartApplied) {
    const fresh = await fetchMatchRow(matchData?.id);
    
    if (fresh) {
      const freshPhase = fresh.phase ?? fresh.match_phase ?? fresh.game_phase ?? fresh.state?.phase ?? null;
      
      if (freshPhase === 'battle' && !battleStartApplied) {
        battleStartApplied = true;
        startBattleFromSelection();
        return;
      }
    }
  }
  
  // LÃ³gica de turnos (somente se batalha jÃ¡ comeÃ§ou)
  if (phase === 'battle' && PVP.battleStarted) {
    const turn_index = row.turn_index;
    const turn_user_id = row.turn_user_id;
    const turn_number = row.turn_number;
    const turn_deadline_at = row.turn_deadline_at;
    const turn_resolved_at = row.turn_resolved_at;
    const currentIsMyTurn = (turn_user_id != null && turn_user_id === myUserId);
    
    const turnIndexChanged = (turn_index != null && turn_index !== lastAppliedTurnIndex);
    const turnUserChanged = (turn_user_id != null && turn_user_id !== lastAppliedTurnUserId);
    const turnNumberChanged = (turn_number != null && turn_number !== currentTurnNumber);
    
    // Se turn_number mudou, guardar novo deadline para quando a animaÃ§Ã£o terminar
    if (turnNumberChanged && turn_deadline_at) {
      currentTurnNumber = turn_number;
      // Guardar deadline â€” o game loop (cleanup) vai consumir via startTurnWindow
      // NUNCA chamar startTurnWindow aqui: a animaÃ§Ã£o pode ainda estar rodando.
      pendingTurnDeadline = turn_deadline_at;
      roundLocked = true;
      // Se a animaÃ§Ã£o jÃ¡ terminou antes do Realtime trazer o deadline, disparar agora
      if (awaitingRoundReady) {
        awaitingRoundReady = false;
        const d = pendingTurnDeadline; pendingTurnDeadline = null;
        startTurnWindow(d);  // mesmo fluxo do round 1
      }
    }
    
    // Apenas aplicar transiÃ§Ã£o se turn_index mudou (novo round)
    // NÃƒO aplicar se apenas turn_user_id mudou (alternÃ¢ncia no mesmo round)
    if (turnIndexChanged) {
      // Guard: se jÃ¡ estiver aplicando transiÃ§Ã£o, ignorar
      if (isApplyingTurnTransition) {
        return;
      }

      // CRÃTICO: NÃƒO chamar applyTurnTransition durante animaÃ§Ã£o ou sync ROUND_READY.
      // Quando Realtime traz turn_index novo enquanto a animaÃ§Ã£o ainda roda (ou logo depois),
      // applyTurnTransition â†’ resetTurnUI zera roundLocked/timers e abre a UI antes do sync,
      // sabotando o barrier do ROUND_READY e causando o travamento no "âŸ³ Sync...".
      // Basta rastrear os Ã­ndices; startTurnWindow cuidarÃ¡ da UI apÃ³s o sync.
      if (mpPhase === 'ANIMATING' || mpPhase === 'ROUND_BANNER' || roundLocked || awaitingRoundReady) {
        lastAppliedTurnIndex = turn_index;
        lastAppliedTurnUserId = turn_user_id;
        turnUserId = turn_user_id;
        isMyTurn = currentIsMyTurn;
        // NÃ£o tocar na UI â€” startTurnWindow farÃ¡ isso apÃ³s sincronizar
      } else {
        isApplyingTurnTransition = true;
        lastAppliedTurnIndex = turn_index;
        lastAppliedTurnUserId = turn_user_id;

        turnUserId = turn_user_id;
        isMyTurn = currentIsMyTurn;

        // SÃ“ resetar UI quando for novo round (turn_index mudou) e NÃƒO estamos em animaÃ§Ã£o/sync
        applyTurnTransition(currentIsMyTurn);

        setTimeout(() => {
          isApplyingTurnTransition = false;
        }, 50);
      }
    } else if (turnUserChanged) {
      // Apenas atualizar quem Ã© o turno, SEM resetar UI
      lastAppliedTurnUserId = turn_user_id;
      turnUserId = turn_user_id;
      isMyTurn = currentIsMyTurn;
      
      // Apenas atualizar mensagem, sem resetar estado
      updateTurnUI();
    }
    
    // Verificar se algum jogador submeteu aÃ§Ã£o (para tentar resolver turno)
    // ðŸ”¥ FIX: usar submitted_blue/submitted_red (os campos corretos no banco)
    // ships_blue/ships_red nÃ£o existem â€” esse bug impedia P1 de re-tentar resolver
    // quando P2 submetia depois do check inicial de 300ms.
    const submitted_blue = row.submitted_blue === true;
    const submitted_red = row.submitted_red === true;
    
    // Se AMBOS submeteram, P1 tenta resolver agora (aciona maybeResolveTurn via Realtime)
    if (submitted_blue && submitted_red) {
      setTimeout(() => maybeResolveTurn(), 500);
    }
  }
}

// (C) Aplicar transiÃ§Ã£o de turno
function applyTurnTransition(isMyTurn) {
  
  // 1) Resetar UI/estado
  resetTurnUI();
  // AAA: Garantir fase interativa no multiplayer
  ensurePvpInteractivePhase('applyTurnTransition');
  
  // 2) Voltar fase para planejamento
  phase = 'selectMove';
  selectedNave = null;
  
  // 3) Regras de input baseado em isMyTurn
  const legendArea = document.getElementById('legendArea');
  const endTurnBtn = document.getElementById('endTurnBtn');
  
  if (isMyTurn) {
    // Minha vez: liberar controles
    // Removido: banner central de aguarde. SÃ³ usar legendArea no HUD.
    if (endTurnBtn) {
      endTurnBtn.disabled = false;
      endTurnBtn.style.opacity = '1';
    }
    if (legendArea) {
      legendArea.textContent = t('yourTurn');
      legendArea.style.color = '';
      // LOG AAA: identificar HUD no turno do jogador
    }
  } else {
    // Vez do oponente: bloquear controles
    // Nunca mostrar popup de aguardando oponente na seleÃ§Ã£o de naves
    if (endTurnBtn) {
      endTurnBtn.disabled = true;
      endTurnBtn.style.opacity = '0.5';
    }
    if (legendArea) {
      legendArea.textContent = t('waitingOpponentShort');
      legendArea.style.color = '';
      // LOG AAA: identificar HUD no turno do oponente
    }
  }
}

// Aplicar update do match (separado para permitir chamada manual)
function applyMatchUpdate(newMatch, oldPhase, oldTurnNumber, oldTurnUserId, oldTurnDeadline, oldTurnResolved) {
  // MERGE de estado: atualizar campos crÃ­ticos sem apagar interaÃ§Ãµes locais
  matchData = { ...matchData, ...newMatch };
  currentPhase = newMatch.phase;
  
  // TURNOS: Reagir a mudanÃ§as de turno baseado em turn_user_id
  // [REMOVIDO/OBSOLETO] Bloco de lÃ³gica de turno desativado. Toda lÃ³gica de turno multiplayer agora Ã© controlada exclusivamente por handleMatchUpdate.
  
  // FIX 3: Se ready do oponente mudou E ambos enviaram aÃ§Ã£o, esconder popup
  const opponentReady = myTeam === 'blue' ? newMatch.ready_red : newMatch.ready_blue;
  const mySubmitted = myTeam === 'blue' ? submitted_blue : submitted_red;
  const oppSubmitted = myTeam === 'blue' ? submitted_red : submitted_blue;
  
  // Esconder popup quando AMBOS enviaram
  // Removido: banner central de aguarde. SÃ³ usar legendArea no HUD.
  
  // Atualizar UI de turno
  updateTurnUI();
}


// Removido: popup central de espera/aguarde. SÃ³ usar legendArea no HUD.

// (C) Resetar UI/inputs para novo turno (Round 2+)
function resetTurnUI() {
  roundLocked = false; // ðŸ”“ destrava seleÃ§Ã£o no novo round
  // AAA: Garantir fase interativa no multiplayer
  ensurePvpInteractivePhase('resetTurnUI');
  
  // NÃƒO resetar se houver vencedor
  if (winner) {
    return;
  }
  
  // IMPORTANTE: Limpar timer interval para evitar contador infinito
  if (typeof turnTimerInterval !== 'undefined' && turnTimerInterval) {
    clearInterval(turnTimerInterval);
    turnTimerInterval = null;
    window.__activeTurnTimer = null; // Limpar referÃªncia global tambÃ©m
    window.__currentTurnDeadline = null; // Limpar deadline atual
  }
  
  // Limpar timer principal se existir
  if (typeof turnTimer !== 'undefined' && turnTimer) {
    clearTimeout(turnTimer);
    turnTimer = null;
  }
  
  // 1) Limpar target/shot/moved de TODAS as naves
  playerNaves.forEach(n => {
    n.target = null;
    n.shot = null;
    if (typeof n.moved !== 'undefined') n.moved = false;
  });
  
  cpuNaves.forEach(n => {
    n.target = null;
    n.shot = null;
    if (typeof n.moved !== 'undefined') n.moved = false;
  });
  
  // Limpar seleÃ§Ã£o e interaÃ§Ã£o
  selectedNave = null;
  isInteracting = false;
  
  // Limpar flags de round
  if (typeof playerWonRound !== 'undefined') playerWonRound = false;
  if (typeof cpuWonRound !== 'undefined') cpuWonRound = false;
  if (typeof roundResultTimer !== 'undefined') roundResultTimer = 0;
  if (typeof isPaused !== 'undefined') isPaused = false;
  if (typeof showExplosionUI !== 'undefined') showExplosionUI = false;
  
  // Limpar projÃ©teis e partÃ­culas
  projectiles = [];
  if (typeof damageTexts !== 'undefined') damageTexts = [];
  if (typeof particles !== 'undefined') particles = [];
  
  // Limpar guard de aplicaÃ§Ã£o de turno
  window.__lastAppliedTurnKey = null;
  
}

// Iniciar timer de seleÃ§Ã£o (15 segundos)

// Cancelar timer de seleÃ§Ã£o
// Cancelar timer de seleÃ§Ã£o
// (refatorado para AAA centralizado, ver bloco acima)

// Atualizar phase para battle e iniciar batalha (funÃ§Ã£o Ãºnica)
async function updatePhaseAndStartBattle() {
  debug.pvp('[PVP] ðŸš€ updatePhaseAndStartBattle chamada');
  debug.pvp('[PVP] PVP.battleStarted:', PVP.battleStarted);
  
  // NÃ£o usar guard aqui - deixar o startBattleFromSelection controlar
  // Apenas atualizar o banco, o Realtime vai sincronizar para ambos
  
  try {
    const { error: phaseError } = await supabaseClient
      .from('matches')
      .update({ phase: 'battle' })
      .eq('id', matchData.id);
    
    if (phaseError) {
      console.error('[PVP] âŒ Erro ao atualizar phase:', phaseError);
    } else {
      debug.pvp('[PVP] âœ… Phase atualizada para battle no banco');
      debug.pvp('[PVP] Aguardando Realtime sincronizar e chamar startBattleFromSelection()');
      cancelSelectionTimer();
      // Removido: banner central de aguarde. SÃ³ usar legendArea no HUD.
    }
  } catch (err) {
    console.error('[PVP] âŒ ExceÃ§Ã£o ao atualizar phase:', err);
  }
}

// Salvar naves selecionadas no banco
async function saveShipSelection() {
  if (!multiplayerMode || !supabaseClient || !matchData) {
    console.error('[PVP] saveShipSelection chamada mas falta:', {
      multiplayerMode,
      supabaseClient: !!supabaseClient,
      matchData: !!matchData
    });
    return false;
  }
  
  try {
    debug.pvp('[PVP] ========================================');
    debug.pvp('[PVP] Salvando seleÃ§Ã£o de naves (DETERMINÃSTICO)');
    debug.pvp('[PVP] selectedNaves:', window.selectedNaves);
    debug.pvp('[PVP] myTeam:', myTeam);
    debug.pvp('[PVP] myUserId:', myUserId);
    debug.pvp('[PVP] player1_id:', player1_id);
    debug.pvp('[PVP] player2_id:', player2_id);
    
    // Usar array puro de nÃºmeros (JSONB) e salvar em player1_ships/player2_ships
    const shipsData = window.selectedNaves; // [1, 2, 3] ou similar
    
    // Determinar campo baseado em player_id (nÃ£o team)
    const updateData = {};
    if (myUserId === player1_id) {
      updateData.player1_ships = shipsData;
      updateData.ready_blue = true;
      debug.pvp('[PVP] Salvando em player1_ships (BLUE)');
    } else if (myUserId === player2_id) {
      updateData.player2_ships = shipsData;
      updateData.ready_red = true;
      debug.pvp('[PVP] Salvando em player2_ships (RED)');
    }
    
    debug.pvp('[PVP] Payload (JSONB array):', JSON.stringify(updateData));
    
    // Atualizar match com minhas naves, ready flag e countdown_started_at (se ainda null)
    const nowIso = new Date().toISOString();
    let updateCountdown = { ...updateData };
    // SÃ³ grava countdown_started_at se ainda estiver null
    if (!matchData.countdown_started_at) {
      updateCountdown.countdown_started_at = nowIso;
    }
    let { data, error } = await supabaseClient
      .from('matches')
      .update(updateCountdown)
      .eq('id', matchData.id)
      .select('*')
      .single();
    
    if (error) {
      console.error('[PVP] âŒ Erro ao salvar seleÃ§Ã£o:');
      console.error('[PVP] error.message:', error.message);
      console.error('[PVP] error.code:', error.code);
      console.error('[PVP] error.details:', error.details);
      console.error('[PVP] error.hint:', error.hint);
      console.error('[PVP] error completo:', JSON.stringify(error));
      console.error('[PVP] Payload enviado:', JSON.stringify(updateData));
      console.error('[PVP] ========================================');
      return false;
    }
    
    debug.pvp('[PVP] âœ… SeleÃ§Ã£o salva');
    
    // Atualizar matchData local
    if (data) {
      matchData = data;
      
      const ready_blue = data.ready_blue;
      const ready_red = data.ready_red;
      
      debug.pvp('[PVP] Status: ready_blue=' + ready_blue + ', ready_red=' + ready_red);
      
      if (ready_blue && ready_red) {
        debug.pvp('[PVP] âœ… Ambos prontos â†’ iniciando batalha');
        cancelSelectionTimer();
        updatePhaseAndStartBattle();
      } else {
        // Timer deve iniciar para o oponente assim que um clicar em pronto
        // AAA: Timer agora Ã© sincronizado via countdown_started_at, nÃ£o iniciar localmente
        // O handleMatchUpdate vai disparar o timer sincronizado para ambos
      }
    }
    
    debug.pvp('[PVP] ========================================');
    return true;
  } catch (err) {
    console.error('[PVP] âŒ EXCEÃ‡ÃƒO ao salvar naves:');
    console.error('[PVP]', err);
    console.error('[PVP] message:', err.message);
    console.error('[PVP] code:', err.code);
    console.error('[PVP] Stack:', err.stack);
    console.error('[PVP] ========================================');
    return false;
  }
}

// Iniciar batalha com naves sincronizadas
function startBattleFromSelection() {
  if (!multiplayerMode || !matchData) {
    console.error('[PVP] startBattleFromSelection chamada mas multiplayerMode:', multiplayerMode, 'matchData:', matchData);
    return;
  }
  
  if (PVP.battleStarted) {
    debug.pvp('[PVP] âš ï¸ Batalha jÃ¡ iniciada, ignorando');
    return;
  }
  
  if (!PVP.hasInitialized) {
    console.error('[PVP] âŒ Tentativa de iniciar batalha sem inicializaÃ§Ã£o completa');
    return;
  }
  
  PVP.battleStarted = true;
  debug.pvp('[PVP] ========================================');
  debug.pvp('[PVP] ðŸš€ INICIANDO BATALHA MULTIPLAYER (DETERMINÃSTICO)');
  debug.pvp('[PVP] matchData:', matchData);
  debug.pvp('[PVP] myUserId:', myUserId);
  debug.pvp('[PVP] myTeam:', myTeam);
  debug.pvp('[PVP] player1_id:', player1_id);
  debug.pvp('[PVP] player2_id:', player2_id);
  
  // GARANTIR que myTeam estÃ¡ definido
  if (!myTeam) {
    console.error('[PVP] âŒ ERRO CRÃTICO: myTeam nÃ£o foi definido!');
    if (myUserId === player1_id) {
      myTeam = 'blue';
      debug.pvp('[PVP] ðŸ”§ CORREÃ‡ÃƒO: Definindo myTeam = blue');
    } else if (myUserId === player2_id) {
      myTeam = 'red';
      debug.pvp('[PVP] ðŸ”§ CORREÃ‡ÃƒO: Definindo myTeam = red');
    }
  }
  
  debug.pvp('[PVP] âœ… myTeam confirmado:', myTeam);
  
  // Ler naves DETERMINISTICAMENTE de player1_ships/player2_ships
  const player1Ships = matchData.player1_ships || [];
  const player2Ships = matchData.player2_ships || [];
  
  debug.pvp('[PVP] player1_ships (BLUE - raw):', player1Ships);
  debug.pvp('[PVP] player2_ships (RED - raw):', player2Ships);
  
  // Determinar minhas naves e naves do oponente baseado em player_id
  let myShips, enemyShips;
  if (myUserId === player1_id) {
    myShips = player1Ships;
    enemyShips = player2Ships;
    debug.pvp('[PVP] âœ“ EU SOU PLAYER1 (BLUE)');
  } else {
    myShips = player2Ships;
    enemyShips = player1Ships;
    debug.pvp('[PVP] âœ“ EU SOU PLAYER2 (RED)');
  }
  
  const isP1 = (myUserId === player1_id);
  debug.pvp('[PVP] âœ“ isP1:', isP1);
  debug.pvp('[PVP] âœ“ myShips:', myShips);
  debug.pvp('[PVP] âœ“ oppShips (enemyShips):', enemyShips);
  
  // ðŸ”¥ AAA: Detectar se sou P1 (host) para authoritative collision
  isPlayer1Host = isP1;
  
  // Fix E: ValidaÃ§Ã£o arrays vazios/null
  if (!myShips || myShips.length !== 3) {
    console.warn('[PVP] Minhas naves invÃ¡lidas, forÃ§ando seleÃ§Ã£o padrÃ£o [1,1,1]');
    myShips = [1, 1, 1];
  }
  
  if (!enemyShips || enemyShips.length !== 3) {
    console.warn('[PVP] Naves do oponente invÃ¡lidas, forÃ§ando seleÃ§Ã£o padrÃ£o [1,1,1]');
    enemyShips = [1, 1, 1];
  }
  
  // CORREÃ‡ÃƒO CRÃTICA: playerNaves = minhas (controlÃ¡veis), cpuNaves = oponente
  // Player1: playerNaves no TOPO (blue), cpuNaves embaixo (red)
  // Player2: playerNaves EMBAIXO (red), cpuNaves no topo (blue)
  debug.pvp('[PVP] Aplicando minhas naves controlÃ¡veis (isP1=' + isP1 + ')...');
  debug.pvp('[PVP] ðŸ” ANTES DE APLICAR - myUserId:', myUserId, 'player1_id:', player1_id, 'isP1:', isP1);
  applyMyShips(myShips, isP1);
  
  debug.pvp('[PVP] Aplicando naves do oponente (isP1=' + isP1 + ')...');
  applyEnemyShips(enemyShips, isP1);
  
  debug.pvp('[PVP] âœ“ Naves aplicadas com sucesso');
  debug.pvp('[PVP] ðŸŽ¨ COR DAS NAVES FINAL:');
  debug.pvp('[PVP]   - playerNaves (minhas):', playerNaves.map((n, i) => `#${i}: ${n.tint || 'AZUL'}`));
  debug.pvp('[PVP]   - cpuNaves (oponente):', cpuNaves.map((n, i) => `#${i}: ${n.tint || 'AZUL'}`));
  debug.pvp('[PVP]   - Resumo: EU sou', isP1 ? 'Player1 (BLUE no topo)' : 'Player2 (RED embaixo)');
  debug.pvp('[PVP]   - Minhas naves devem ser:', isP1 ? 'AZUL' : 'VERMELHO');
  debug.pvp('[PVP]   - Naves oponente devem ser:', isP1 ? 'VERMELHO' : 'AZUL');
  
  // Esconder tela de seleÃ§Ã£o e mostrar jogo
  document.getElementById('naveSelectScreen').style.display = 'none';
  document.getElementById('gameCanvas').style.display = 'block';
  playRandomBgm();
  
  // Aplicar fundo aleatÃ³rio ao iniciar o jogo
  applyGameBackground();
  
  var hudTop = document.getElementById('hudTop');
  hudTop.style.display = 'flex';
  hudTop.style.visibility = 'visible';
  hudTop.style.opacity = '1';
  document.getElementById('gameContour').style.visibility = 'visible';
  galaxyBg.style.opacity = '0.18';
  
  debug.pvp('[PVP] âœ“ UI atualizada - canvas visÃ­vel');
  
  // Mostrar banner de matchup no multiplayer
  const matchupBanner = document.getElementById("matchupBanner");
  const playerNameDisplay = document.getElementById("playerNameDisplay");
  const opponentNameDisplay = document.getElementById("opponentNameDisplay");
  
  if (matchupBanner && playerNameDisplay && opponentNameDisplay) {
    const currentPlayerName = playerName || localStorage.getItem("thor_username") || "Player";
    
    // Determinar ordem correta: P1 (azul) x P2 (vermelho)
    let player1Name, player2Name;
    if (myTeam === 'blue') {
      player1Name = currentPlayerName;
      player2Name = opponentUsername || localStorage.getItem("thor_match_opponent_name") || "Opponent";
    } else {
      player1Name = opponentUsername || localStorage.getItem("thor_match_opponent_name") || "Opponent";
      player2Name = currentPlayerName;
    }
    
    const _p1IsVip = localStorage.getItem('thor_is_vip') === 'true';
    const _p1VipColor = localStorage.getItem('thor_vip_name_color') || '#FFD700';
    playerNameDisplay.textContent = _p1IsVip ? ('ðŸ’Ž ' + player1Name) : player1Name;
    playerNameDisplay.style.color = _p1IsVip ? _p1VipColor : "#00E5FF"; // P1 color
    
    const _p2IsVip = (myTeam === 'red') && localStorage.getItem('thor_is_vip') === 'true';
    const _p2VipColor = localStorage.getItem('thor_vip_name_color') || '#FFD700';
    opponentNameDisplay.textContent = _p2IsVip ? ('ï¿½ ' + player2Name) : player2Name;
    opponentNameDisplay.style.color = _p2IsVip ? _p2VipColor : "#FF4444";
    
    matchupBanner.style.display = "block";
    matchupBanner.style.visibility = "visible";
    
    debug.pvp('[PVP] âœ“ Banner de matchup exibido:', player1Name, '(P1) vs', player2Name, '(P2)');
  }
  
  // Iniciar game loop se necessÃ¡rio
  canStartGame = true;
  if (!window._gameLoopStarted && spritesLoaded === 2) {
    window._gameLoopStarted = true;
    gameActive = true;
    debug.pvp('[PVP] âœ“ Iniciando game loop');
    gameLoop();
  } else {
    debug.pvp('[PVP] Game loop jÃ¡ iniciado ou aguardando sprites');
  }
  
  // Atualizar UI de turno
  updateTurnUI();
  
  // G) Log de turno iniciado
  debug.pvp('[PVP] ðŸ”µ Turno iniciado - aguardando jogadas');
  
  // B) Ligar sincronizaÃ§Ã£o de movimento agora que batalha iniciou
  debug.pvp('[PVP] Batalha iniciada, configurando syncChannel...');
  setupMultiplayerSync(matchData.id);
  
  // Fix F: Logs finais de diagnÃ³stico
  debug.pvp('[PVP] ========================================');
  debug.pvp('[PVP] READY: phase=' + currentPhase + ', myUserId=' + myUserId + ', isP1=' + isP1 + ', turn_user_id=' + turnUserId + ', canInput=' + isMyTurn);
  debug.pvp('[PVP] Render: p1ShipsCount=' + (isP1 ? myShips.length : enemyShips.length) + ', p2ShipsCount=' + (isP1 ? enemyShips.length : myShips.length));
  debug.pvp('[PVP] ========================================');
  
  // INICIAR PRIMEIRO TURNO (idempotente, sem race condition)
  // AAA: Garantir fase interativa no multiplayer
  ensurePvpInteractivePhase('startBattleFromSelection');
  (async () => {
    try {
      debug.pvp('[PVP] ðŸŽ® Configurando primeiro turno...');
      debug.pvp('[PVP] matchId:', matchData.id, 'myUserId:', myUserId, 'myTeam:', myTeam);
      debug.pvp('[PVP] player1_id:', player1_id, 'player2_id:', player2_id);
      
      // Buscar estado atual do match
      const { data: currentMatch, error: fetchError } = await supabaseClient
        .from('matches')
        .select('turn_user_id, turn_number, turn_deadline_at')
        .eq('id', matchData.id)
        .single();
      
      if (fetchError) {
        console.error('[PVP] âŒ Erro ao buscar match atual:', JSON.stringify(fetchError, null, 2));
        return;
      }
      
      debug.pvp('[PVP] Estado atual:', JSON.stringify(currentMatch, null, 2));
      
      // Se turn_user_id jÃ¡ existe, nÃ£o sobrescrever (idempotente)
      if (currentMatch.turn_user_id) {
        debug.pvp('[PVP] âœ“ Turno jÃ¡ configurado por outro jogador:', currentMatch.turn_user_id);
        turnUserId = currentMatch.turn_user_id;
        isMyTurn = (myUserId === turnUserId);
        currentTurnNumber = currentMatch.turn_number || 1;
        
        if (currentMatch.turn_deadline_at) {
          startTurnWindow(currentMatch.turn_deadline_at);
        }
        
        return;
      }
      
      // turn_user_id Ã© null, vou tentar setar (optimistic update)
      debug.pvp('[PVP] turn_user_id Ã© null, configurando primeiro turno...');
      
      const firstDeadline = new Date(Date.now() + 20000).toISOString();
      const now = new Date().toISOString();
      
      // Update com condiÃ§Ã£o: sÃ³ setar se turn_user_id ainda for null (evita race)
      const { data: updateData, error: updateError } = await supabaseClient
        .from('matches')
        .update({
          turn_number: 1,
          turn_user_id: player1_id, // Player 1 sempre comeÃ§a
          turn_deadline_at: firstDeadline,
          turn_started_at: now,
          turn_resolved_at: null
        })
        .eq('id', matchData.id)
        .is('turn_user_id', null) // SÃ³ atualizar se for null
        .select();
      
      if (updateError) {
        console.error('[PVP] âŒ Erro ao configurar turno:', JSON.stringify(updateError, null, 2));
        // Outro jogador pode ter configurado primeiro, buscar novamente
        const { data: refetch } = await supabaseClient
          .from('matches')
          .select('turn_user_id, turn_number, turn_deadline_at')
          .eq('id', matchData.id)
          .single();
        
        if (refetch?.turn_user_id) {
          debug.pvp('[PVP] âœ“ Turno configurado por outro jogador:', refetch.turn_user_id);
          turnUserId = refetch.turn_user_id;
          isMyTurn = (myUserId === turnUserId);
          currentTurnNumber = refetch.turn_number || 1;
          if (refetch.turn_deadline_at) {
            startTurnWindow(refetch.turn_deadline_at);
          }
        }
        return;
      }
      
      if (!updateData || updateData.length === 0) {
        debug.pvp('[PVP] âš ï¸ Update nÃ£o afetou linhas (outro jogador jÃ¡ configurou)');
        // Buscar novamente
        const { data: refetch } = await supabaseClient
          .from('matches')
          .select('turn_user_id, turn_number, turn_deadline_at')
          .eq('id', matchData.id)
          .single();
        
        if (refetch?.turn_user_id) {
          debug.pvp('[PVP] âœ“ Turno configurado:', refetch.turn_user_id);
          turnUserId = refetch.turn_user_id;
          isMyTurn = (myUserId === turnUserId);
          currentTurnNumber = refetch.turn_number || 1;
          if (refetch.turn_deadline_at) {
            startTurnWindow(refetch.turn_deadline_at);
          }
        }
        return;
      }
      
      // Sucesso! Eu configurei o turno
      debug.pvp('[PVP] âœ… Primeiro turno configurado com sucesso');
      debug.pvp('[PVP] turn_user_id:', player1_id, 'turn_number: 1');
      debug.pvp('[PVP] deadline:', firstDeadline);
      
      turnUserId = player1_id;
      isMyTurn = (myUserId === turnUserId);
      currentTurnNumber = 1;
      
      debug.pvp('[PVP] isMyTurn:', isMyTurn);
      
      startTurnWindow(firstDeadline);
      
    } catch (err) {
      console.error('[PVP] âŒ ExceÃ§Ã£o ao configurar turno:', err.message);
      console.error('[PVP] Stack:', err.stack);
    }
  })();
  
  debug.pvp('[PVP] ========================================');
}

// Aplicar naves do OPONENTE (inimigas em cpuNaves)
function applyEnemyShips(shipsArray, myIsP1) {
  // POSIÃ‡Ã•ES FÃSICAS REAIS DO OPONENTE:
  // Se eu sou P1 (topo), oponente Ã© P2 (baixo)
  // Se eu sou P2 (baixo), oponente Ã© P1 (topo)
  const posicoes = myIsP1 ? [
    { x: 700, y: 520 },  // Oponente P2 baixo
    { x: 540, y: 520 },
    { x: 700, y: 350 }
  ] : [
    { x: 100, y: 250 },  // Oponente P1 topo
    { x: 260, y: 80 },
    { x: 100, y: 80 }
  ];
  
  // Centro do MEU campo (para as naves adversÃ¡rias apontarem)
  const myCenterX = myIsP1 ? 180 : 620;
  const myCenterY = myIsP1 ? 150 : 460;
  
  shipsArray.forEach((tipo, i) => {
    if (cpuNaves[i]) {
      cpuNaves[i].tipo = tipo;
      cpuNaves[i].x = posicoes[i].x;
      cpuNaves[i].y = posicoes[i].y;
      
      // Calcular Ã¢ngulo individual apontando para o meu centro
      const dx = myCenterX - cpuNaves[i].x;
      const dy = myCenterY - cpuNaves[i].y;
      cpuNaves[i].angle = Math.atan2(dy, dx) + Math.PI / 2;
      
      let sprite = new Image();
      let hp = 99;
      let alcance = 300;
      if (tipo === 1) {
        sprite.src = 'images/nave_alcance.png';
        hp = 66;
        alcance = 360;
      } else if (tipo === 2) {
        sprite.src = 'images/nave_protecao.png';
        hp = 132;
        alcance = 160;
      } else if (tipo === 4) {
        sprite.src = 'images/nave_alcance_red_vip.png';
        hp = 66;
        alcance = 400;
      } else if (tipo === 5) {
        sprite.src = 'images/nave_alcance_vip.png';
        hp = 66;
        alcance = 400;
      } else if (tipo === 6) {
        sprite.src = 'images/nave_protecao_vip.png';
        hp = 160;
        alcance = 180;
      } else if (tipo === 7) {
        sprite.src = 'images/nave_protecao_red_vip.png';
        hp = 160;
        alcance = 180;
      } else if (tipo === 8) {
        sprite.src = 'images/nave_normal_vip.png';
        hp = 99;
        alcance = 360;
      } else if (tipo === 9) {
        sprite.src = 'images/nave_normal_red_vip.png';
        hp = 99;
        alcance = 360;
      } else {
        sprite.src = 'images/spaceschip.png';
        hp = 99;
        alcance = 300;
      }
      
      
      cpuNaves[i].sprite = sprite;
      cpuNaves[i].hp = hp;
      cpuNaves[i].alcance = alcance;
      
      // COR DO TIME OPONENTE
      if (multiplayerMode) {
        if (myIsP1) {
          cpuNaves[i].tint = 'red';
        }
      } else {
        cpuNaves[i].tint = 'red';
      }
    }
  });
  
  debug.pvp('[PVP] cpuNaves aplicadas:', cpuNaves.map(n => ({ x: n.x, y: n.y, tipo: n.tipo, angle: n.angle, tint: n.tint })));
  debug.pvp('[PVP] âœ… RENDERIZAÃ‡ÃƒO COMPLETA');
  debug.pvp('[PVP] Player1 (BLUE) sempre no TOPO, Player2 (RED) sempre EMBAIXO');
  debug.pvp('[PVP] Cada jogador controla suas prÃ³prias naves (playerNaves)');
  debug.pvp('[PVP] myTeam:', myTeam, '- Minhas naves:', playerNaves.map(n => n.tint || 'BLUE'), '- Oponente:', cpuNaves.map(n => n.tint || 'BLUE'));
}

// MantÃ©m compatibilidade
function applyOpponentNavesFromSelection(shipsArray, isPlayer1Owner = true) {
  if (multiplayerMode) {
    // No contexto multiplayer, isPlayer1Owner indica se OPONENTE Ã© P1
    // Se oponente Ã© P1, ele estÃ¡ no topo
    applyEnemyShips(shipsArray, !isPlayer1Owner);
  } else {
    // Modo solo mantÃ©m lÃ³gica original
    shipsArray.forEach((tipo, i) => {
      if (cpuNaves[i]) {
        cpuNaves[i].tipo = tipo;
        let sprite = new Image();
        let hp = 99;
        if (tipo === 1) {
          sprite.src = 'images/nave_alcance.png';
          hp = 66;
        } else if (tipo === 2) {
          sprite.src = 'images/nave_protecao.png';
          hp = 132;
        } else if (tipo === 4) {
          sprite.src = 'images/nave_alcance_red_vip.png';
          hp = 66;
        } else if (tipo === 5) {
          sprite.src = 'images/nave_alcance_vip.png';
          hp = 66;
        } else if (tipo === 6) {
          sprite.src = 'images/nave_protecao_vip.png';
          hp = 160;
        } else if (tipo === 7) {
          sprite.src = 'images/nave_protecao_red_vip.png';
          hp = 160;
        } else if (tipo === 8) {
          sprite.src = 'images/nave_normal_vip.png';
          hp = 99;
        } else if (tipo === 9) {
          sprite.src = 'images/nave_normal_red_vip.png';
          hp = 99;
        } else {
          sprite.src = 'images/spaceschip.png';
          hp = 99;
        }
        cpuNaves[i].sprite = sprite;
        cpuNaves[i].hp = hp;
      }
    });
  }
}

// Atualizar UI de turno
function updateTurnUI() {
  if (!multiplayerMode) return;
  
  const legendArea = document.getElementById('legendArea');
  const endTurnArea = document.getElementById('endTurnArea');
  const endTurnBtn = document.getElementById('endTurnBtn');
  
  if (!legendArea) return;
  
  // Em multiplayer, NUNCA mostrar botÃ£o de finalizar turno (sistema automÃ¡tico)
  if (endTurnArea) endTurnArea.style.display = 'none';
  
  if (currentPhase !== 'battle') {
    return;
  }
  
  // Mostrar botÃ£o de finalizar turno
  if (endTurnArea) {
    endTurnArea.style.display = isMyTurn ? 'block' : 'none';
  }
  
  // TURNOS SIMULTÃ‚NEOS: sempre permitir input
  legendArea.textContent = t('clickShipToMove');
  legendArea.style.color = myTeam === 'blue' ? '#00D4FF' : '#FF4444';
  // Removido: banner central de aguarde. SÃ³ usar legendArea no HUD.
  
  // Sempre habilitar em modo simultÃ¢neo
  if (endTurnBtn) {
    endTurnBtn.disabled = false;
    endTurnBtn.style.opacity = '1';
  }
}

// Finalizar turno - alternar turn_user_id de forma atÃ´mica
async function endTurn() {
  if (!multiplayerMode || !supabaseClient || !matchData || !isMyTurn) {
    return;
  }
  
  try {
    // Alternar turn_user_id entre player1_id e player2_id
    const nextTurnUserId = (turnUserId === player1_id) ? player2_id : player1_id;
    
    
    const { error } = await supabaseClient
      .from('matches')
      .update({
        turn_user_id: nextTurnUserId,
        turn_index: (matchData.turn_index || 1) + 1,
        updated_at: new Date().toISOString()
      })
      .eq('id', matchData.id);
    
    if (error) {
      console.error('[TURN] âŒ Erro ao finalizar turno:', error);
      return;
    }
    
    
    debug.pvp('[PVP] Turno finalizado, prÃ³ximo:', nextTurn);
  } catch (err) {
    console.error('[PVP] Erro ao finalizar turno:', err);
  }
}

// Configurar sincronizaÃ§Ã£o multiplayer
// VariÃ¡veis globais para turn-based
let myTurnAction = null;
let opponentTurnAction = null;
let turnSubmitted = false;

// Interaction lock: impede sobrescrita de estado durante interaÃ§Ã£o do usuÃ¡rio
let isInteracting = false;
let pendingRemoteState = null;
let roundLocked = false; // ðŸ”’ trava inputs apÃ³s 3 naves READY atÃ© novo round


function setupMultiplayerSync(matchId) {
  if (!multiplayerMode) {
    console.warn('[PVP] setupMultiplayerSync chamado mas multiplayerMode=false');
    return;
  }
  
  // (E) Guard robusto: nunca criar duplicatas
  if (syncChannel) {
    debug.pvp('[PVP] âš ï¸ syncChannel jÃ¡ existe, nÃ£o recriar (evitando duplicata)');
    return;
  }
  
  if (!supabaseClient) {
    console.error('[PVP] âŒ setupMultiplayerSync: supabaseClient global nÃ£o existe!');
    return;
  }
  
  try {
    debug.pvp('[PVP] ðŸ”— Criando syncChannel TURN-BASED para match:', matchId);
    
    syncChannel = supabaseClient.channel(`match:${matchId}`, {
      config: { broadcast: { self: false } }
    });
    
    // C1) Listener TURN_ACTION: receber jogada do oponente
    syncChannel.on('broadcast', { event: 'turn_action' }, ({ payload }) => {
      if (!payload || payload.userId === myUserId) return;
      
      debug.pvp('[PVP] ðŸ“¨ Jogada recebida do oponente:', {
        userId: payload.userId,
        team: payload.team,
        actions: payload.actions?.length
      });
      
      // Salvar a jogada do oponente (nÃ£o aplicar ainda)
      opponentTurnAction = payload;
      
      // D) Se eu jÃ¡ enviei e recebi a dele, executar turno
      if (turnSubmitted && opponentTurnAction) {
        debug.pvp('[PVP] Ambas jogadas prontas, executando turno...');
        executeTurn();
      }
    });
    
    // C2) Listener REALTIME_STATE: receber posicionamento/movimento em tempo real
    syncChannel.on('broadcast', { event: 'realtime_state' }, ({ payload }) => {
      if (!payload || payload.userId === myUserId) return;

      // â”€â”€â”€ AAA STATE MACHINE GUARD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // During PLANNING / RESOLVING / ANIMATING, NEVER apply any incoming
      // position or action data from the opponent.  The only canonical
      // source of truth is pendingAnimActions (from applyResolvedTurn).
      // This prevents all planning leaks, ghost moves, and desync.
      if (mpPhase === 'PLANNING' || mpPhase === 'RESOLVING' || mpPhase === 'ANIMATING') {
        debug.realtime('[REALTIME] ðŸ”’ realtime_state bloqueado â€“ mpPhase=' + mpPhase);
        return;
      }
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      debug.realtime('[REALTIME] ðŸ“¨ Estado em tempo real do oponente:', {
        userId: payload.userId, team: payload.team, ships: payload.ships?.length
      });

      // Se usuÃ¡rio estÃ¡ interagindo, nÃ£o aplicar
      if (isInteracting) {
        debug.realtime('[REALTIME] ðŸ”’ Ignorando update - usuÃ¡rio interagindo');
        return;
      }

      // Aplicar posiÃ§Ãµes do oponente em cpuNaves (apenas coordenadas â€” NUNCA shot/target)
      if (payload.ships && Array.isArray(payload.ships)) {
        payload.ships.forEach((shipData, idx) => {
          if (cpuNaves[idx] && shipData) {
            if (shipData.x !== undefined && shipData.y !== undefined) {
              cpuNaves[idx].targetX = shipData.x;
              cpuNaves[idx].targetY = shipData.y;
              if (cpuNaves[idx].x === 0 && cpuNaves[idx].y === 0) {
                cpuNaves[idx].x = shipData.x;
                cpuNaves[idx].y = shipData.y;
              }
            }
            // âŒ NEVER apply shot/target/angle from realtime â€” these are planning secrets
            // and would cause: ghost aims, position desync, and spoiled strategy.
          }
        });
      }
    });
    
    // AAA SYNC BARRIER 1: ouvir ACK de animaÃ§Ã£o do oponente (ANIM_READY)
    syncChannel.on('broadcast', { event: 'ANIM_READY' }, ({ payload }) => {
      if (!payload || payload.userId === myUserId) return;
      opponentAnimReady = true;
      // Se eu jÃ¡ estou pronto, acionar animaÃ§Ã£o imediatamente
      if (selfAnimReady && pendingAnimActions) {
        if (animReadyTimeout) { clearTimeout(animReadyTimeout); animReadyTimeout = null; }
        applyResolvedTurn(pendingAnimActions);
      }
    });

    // ROUND_READY broadcast removido â€” o round 2+ agora usa o mesmo fluxo DB-driven do round 1.
    // O listener Ã© mantido como no-op para compatibilidade com versÃµes antigas do cliente.
    syncChannel.on('broadcast', { event: 'ROUND_READY' }, ({ payload }) => {
      // no-op: fluxo controlado pelo DB Realtime (turn_deadline_at)
    });

    syncChannel.subscribe((status) => {
      debug.pvp('[PVP] syncChannel status:', status);
      
      if (status === 'SUBSCRIBED') {
        debug.pvp('[PVP] âœ… syncChannel TURN-BASED SUBSCRIBED', { matchId, myUserId, myTeam });
      } else if (status === 'CHANNEL_ERROR') {
        console.error('[PVP] âŒ CHANNEL_ERROR no syncChannel - tentando reconectar em 2s...');
        
        // Tentar reconectar apÃ³s 2 segundos
        setTimeout(() => {
          debug.pvp('[PVP] ðŸ”„ Tentando reconectar syncChannel...');
          if (syncChannel) {
            syncChannel.unsubscribe();
          }
          setupMultiplayerSync(); // Recriar canal
        }, 2000);
      } else if (status === 'TIMED_OUT') {
        console.error('[PVP] â° TIMED_OUT no syncChannel - tentando reconectar...');
        
        setTimeout(() => {
          debug.pvp('[PVP] ðŸ”„ Tentando reconectar apÃ³s timeout...');
          if (syncChannel) {
            syncChannel.unsubscribe();
          }
          setupMultiplayerSync();
        }, 2000);
      } else if (status === 'CLOSED') {
        console.warn('[PVP] ðŸ”’ syncChannel CLOSED');
      }
    });
    
    debug.pvp('[PVP] setupMultiplayerSync TURN-BASED configurado');
  } catch (err) {
    console.error('[PVP] âŒ Erro ao configurar sincronizaÃ§Ã£o:', err);
  }
}

// A) Broadcast de estado em tempo real (posicionamento/movimento)
function broadcastRealtimeState() {
  if (!multiplayerMode || !syncChannel) return;
  
  try {
    const ships = playerNaves.map((n, idx) => ({
      index: idx,
      x: n.x,
      y: n.y,
      angle: n.angle,
      target: n.target,
      shot: n.shot,
      hp: n.hp
    }));
    
    syncChannel.send({
      type: 'broadcast',
      event: 'realtime_state',
      payload: {
        userId: myUserId,
        team: myTeam,
        phase: phase,
        ships: ships
      }
    });
    
    debug.realtime('[REALTIME] ðŸ“¤ Estado em tempo real enviado');
  } catch (err) {
    console.error('[REALTIME] âŒ Erro ao enviar estado:', err);
  }
}

// B) Enviar jogada final do turno
function submitTurnAction() {
  if (!multiplayerMode || !syncChannel || turnSubmitted) return;
  
  debug.pvp('[PVP] ðŸ“¤ Enviando jogada do turno...');
  
  try {
    // Coletar aÃ§Ãµes de todas as naves controladoras (playerNaves)
    const actions = playerNaves.map((n, idx) => ({
      index: idx,
      target: n.target ? { x: n.target.x, y: n.target.y } : null,
      shot: n.shot ? { x: n.shot.x, y: n.shot.y } : null,
      hp: n.hp
    }));
    
    myTurnAction = {
      type: 'turn_action',
      userId: myUserId,
      team: myTeam,
      actions: actions
    };
    
    syncChannel.send({
      type: 'broadcast',
      event: 'turn_action',
      payload: myTurnAction
    });
    
    turnSubmitted = true;
    debug.pvp('[PVP] âœ… Jogada enviada', myTeam, actions.length);
    
    // D) Se jÃ¡ recebi a do oponente, executar
    if (opponentTurnAction) {
      debug.pvp('[PVP] Oponente jÃ¡ enviou, executando turno...');
      executeTurn();
    } else {
      debug.pvp('[PVP] Aguardando jogada do oponente...');
    }
  } catch (err) {
    console.error('[PVP] âŒ Erro ao enviar jogada:', err);
  }
}

// D) Executar turno sincronizado
function executeTurn() {
  if (!myTurnAction || !opponentTurnAction) {
    console.warn('[PVP] executeTurn: faltam aÃ§Ãµes', { my: !!myTurnAction, opp: !!opponentTurnAction });
    return;
  }
  
  debug.pvp('[PVP] ðŸŽ® Executando turno sincronizado');
  
  // Aplicar minhas aÃ§Ãµes em playerNaves
  myTurnAction.actions.forEach(action => {
    const nave = playerNaves[action.index];
    if (nave && nave.hp > 0) {
      nave.target = action.target;
      nave.shot = action.shot;
    }
  });
  
  // Aplicar aÃ§Ãµes do oponente em cpuNaves
  opponentTurnAction.actions.forEach(action => {
    const nave = cpuNaves[action.index];
    if (nave && nave.hp > 0) {
      nave.target = action.target;
      nave.shot = action.shot;
    }
  });
  
  // Disparar projÃ©teis
  phase = 'wait';
  fireProjectiles();
  
  // Resetar para prÃ³ximo turno com limpeza completa
  myTurnAction = null;
  opponentTurnAction = null;
  turnSubmitted = false;
  isInteracting = false;
  pendingRemoteState = null;
  
 
  
  debug.pvp('[PVP] âœ… Turno finalizado e estado limpo para round 2');
}

// A) FunÃ§Ã£o removida - NÃƒO sincronizar movimento em tempo real
// Use submitTurnAction() para enviar jogada final do turno

// Enviar tiro (mantido para compatibilidade mas nÃ£o usado em turn-based)
function broadcastShot(x, y, vx, vy) {
  if (!multiplayerMode || !syncChannel) return;
  
  try {
    // (F) Fix: myTeam Ã© 'blue'/'red' (lowercase), nÃ£o 'BLUE'/'RED'
    const target = myTeam === 'blue' ? 'red' : 'blue';
    
    syncChannel.send({
      type: 'broadcast',
      event: 'shot',
      payload: {
        userId: myUserId,
        team: myTeam,
        target: target,
        x, y, vx, vy,
        t: Date.now()
      }
    });
  } catch (err) {
    console.error('[REALTIME] Erro ao enviar tiro:', err);
  }
}

// Checar desconexÃ£o do oponente
function checkRemoteConnection() {
  if (!multiplayerMode) return;
  
  const now = Date.now();
  if (now - remotePlayerLastSeen > 2000) {
    remotePlayerConnected = false;
  } else {
    remotePlayerConnected = true;
  }
}

function hideEndScreens() {
  document.getElementById('victoryScreen').style.display = 'none';
  document.getElementById('defeatScreen').style.display = 'none';
  document.getElementById('drawScreen').style.display = 'none';
}

function showOnly(screenId) {
  hideEndScreens(); // Garante que nenhuma tela de resultado estÃ¡ ativa
  // Lista das telas principais do jogo (ajuste se adicionar mais telas fullscreen)
  const telas = [
    "loadingScreen", "startContainer", "modeSelectionScreen",
    "naveSelectScreen", "matchmakingScreen",
    "victoryScreen", "defeatScreen", "drawScreen"
  ];
  telas.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.style.display = "none";
  });
  // Mostra sÃ³ a desejada
  const target = document.getElementById(screenId);
  if (target) target.style.display = "flex";
  
  // FIX 1: Trocar SRC das imagens para versÃ£o vermelha se o jogador for RED (player2)
  if (screenId === "naveSelectScreen" && multiplayerMode && myTeam === 'red') {
    document.querySelectorAll('.nave-img').forEach(img => {
      const originalSrc = img.src;
      // Trocar para versÃ£o _red
      if (originalSrc.includes('_vip.png')) {
        // All VIP ships keep their own image â€” already team-colored by design
      } else if (originalSrc.includes('nave_alcance.png')) {
        img.src = originalSrc.replace('nave_alcance.png', 'nave_alcance_red.png');
      } else if (originalSrc.includes('nave_protecao.png')) {
        img.src = originalSrc.replace('nave_protecao.png', 'nave_protecao_red.png');
      } else if (originalSrc.includes('spaceschip.png')) {
        img.src = originalSrc.replace('spaceschip.png', 'nave_normal_red.png');
      }
    });
    // Aplicar tambÃ©m nos previews
    for (let i = 1; i <= 3; i++) {
      const preview = document.getElementById(`preview${i}`);
      if (preview && preview.src) {
        const originalSrc = preview.src;
        if (originalSrc.includes('nave_alcance.png')) {
          preview.src = originalSrc.replace('nave_alcance.png', 'nave_alcance_red.png');
        } else if (originalSrc.includes('nave_protecao.png')) {
          preview.src = originalSrc.replace('nave_protecao.png', 'nave_protecao_red.png');
        } else if (originalSrc.includes('spaceschip.png')) {
          preview.src = originalSrc.replace('spaceschip.png', 'nave_normal_red.png');
        }
      }
    }
  } else if (screenId === "naveSelectScreen") {
    // Resetar para versÃ£o azul se for BLUE ou modo solo
    document.querySelectorAll('.nave-img').forEach(img => {
      const redSrc = img.src;
      if (redSrc.includes('_red.png')) {
        img.src = redSrc.replace('nave_alcance_red.png', 'nave_alcance.png')
                       .replace('nave_protecao_red.png', 'nave_protecao.png')
                       .replace('nave_normal_red.png', 'spaceschip.png');
      }
    });
    for (let i = 1; i <= 3; i++) {
      const preview = document.getElementById(`preview${i}`);
      if (preview && preview.src && preview.src.includes('_red.png')) {
        preview.src = preview.src.replace('nave_alcance_red.png', 'nave_alcance.png')
                                 .replace('nave_protecao_red.png', 'nave_protecao.png')
                                 .replace('nave_normal_red.png', 'spaceschip.png');
      }
    }
  }
  
  // Ocultar banner de matchup apenas em telas especÃ­ficas (nÃ£o durante o jogo)
  const matchupBanner = document.getElementById("matchupBanner");
  if (matchupBanner) {
    // Esconder apenas nas telas de menu, nÃ£o durante o jogo
    const hideInScreens = ["startContainer", "modeSelectionScreen", "matchmakingScreen", "loadingScreen"];
    if (hideInScreens.includes(screenId)) {
      matchupBanner.style.display = "none";
    }
    // Durante naveSelectScreen e o jogo, o banner permanece visÃ­vel (se jÃ¡ foi exibido)
  }
  
  // Header fica oculto apenas nas telas antigas de loading/login quando embedado
  try {
    const shouldShowHeader = !(screenId === 'loadingScreen' || screenId === 'startContainer');
    setHeaderVisible(shouldShowHeader);
  } catch (e) { /* silent */ }
}

// AAA: Input lock global para multiplayer
let inputLocked = false;

let playerScore = 0; // PontuaÃ§Ã£o total do player
// Helper para garantir que o score exibido/enviado nunca seja negativo
function clampScore(val) {
  if (typeof val === 'undefined') val = playerScore;
  return Math.max(0, Number(val || 0));
}

// Fonte da verdade AAA para seleÃ§Ã£o de naves
if (typeof PVP === 'object') {
  PVP.fleetSlots = [null, null, null]; // shipId em cada slot
  PVP.fleetLocked = false;
}

// 4) Garantir que PVP nunca Ã© recriado inteiro
// (Adicionar log em qualquer ponto que faÃ§a PVP = ...)
Object.defineProperty(window, 'PVP', {
  set(v) {
  },
  configurable: true
});

let roundBonus = 0;  // PontuaÃ§Ã£o de bÃ´nus a cada rodada
let cpuScore = 0;
let playerDestroyed = 0;  // âœ… Minhas naves destruÃ­das (perdas)
let cpuDestroyed = 0;     // âœ… Naves do oponente destruÃ­das (meus kills)
let showReadyGo = false;
let readyGoText = "";
let readyGoAlpha = 0;
let readyGoTimer = 0;
let readyGoStep = 0; // 0 = Ready?, 1 = Go!, 2 = Fim
let collisionCpuSolo = 0;     // Quantas vezes CPU colidiu sozinho
let collisionPlayerSolo = 0;  // Quantas vezes vocÃª colidiu suas prÃ³prias naves
let navesPerdidas = 0;        // Quantas naves vocÃª perdeu (abatidas pelo CPU)
let bonusAllAtOnce = false;
let bonusNoLoss = false;
let gameActive = true; // controle para saber se o loop do jogo estÃ¡ ativo
let gameOverSent = false; // Flag para garantir que THOR:GAME_OVER sÃ³ seja enviado uma vez
let statsUpdated = false; // Flag para garantir que player_stats sÃ³ seja atualizado uma vez por partida
let matchFinalizationProcessed = false; // Flag para garantir que finalizaÃ§Ã£o sÃ³ execute uma vez
let finalScoreSaved = { myLost: 0, oppLost: 0 }; // Salvar placar final quando jogo termina

// FunÃ§Ãµes para calcular perdas totais (combate + autocolisÃ£o)
function getMyLost() {
  // Contar MINHAS naves destruÃ­das (playerNaves com hp <= 0)
  return playerNaves.filter(n => n.hp <= 0).length;
}

function getOppLost() {
  // Contar naves do OPONENTE destruÃ­das (cpuNaves com hp <= 0)
  return cpuNaves.filter(n => n.hp <= 0).length;
}



let cpuDestroyedAntesDoRound = 0;   // <==== NOVA VARIÃVEL DO PASSO 1

// Lista global para partÃ­culas de explosÃ£o
let particles = [];






function backToStartMenu() {
  
  // E) Cleanup: remover canais Realtime
  if (syncChannel) {
    try {
      debug.realtime('[REALTIME] Removendo syncChannel');
      supabaseClient.removeChannel(syncChannel);
    } catch(e) {
      console.error('[REALTIME] Erro ao remover syncChannel:', e);
    }
    syncChannel = null;
  }
  
  if (matchStateChannel) {
    try {
      debug.realtime('[REALTIME] Removendo matchStateChannel');
      supabaseClient.removeChannel(matchStateChannel);
    } catch(e) {
      console.error('[REALTIME] Erro ao remover matchStateChannel:', e);
    }
    matchStateChannel = null;
  }
  
  // 1) Fecha as telas finais (vitÃ³ria/derrota/empate)
  hideEndScreens();

  // 2) Para o loop do jogo (evita sobreposiÃ§Ã£o de canvas/loops)
  gameActive = false;
  window._gameLoopStarted = false;

  // Esconder botÃ£o de mute (fora do jogo)
  const muteBtn = document.getElementById('bgm-mute-btn');
  if (muteBtn) muteBtn.style.display = 'none';

  // 3) Limpa algumas coisas do jogo (opcional, mas recomendado)
  projectiles = [];
  explosions = [];
  particles = [];
  wrecks = [];

  // Preparar dados do resultado - usar valores salvos no momento da finalizaÃ§Ã£o
  const matchId = matchData?.id || localStorage.getItem("thor_match_id");
  const opponentName = localStorage.getItem("thor_match_opponent_name") || 'Opponent';
  const myLost = finalScoreSaved.myLost;
  const oppLost = finalScoreSaved.oppLost;
  
  
  // Limpar dados do match multiplayer do localStorage
  localStorage.removeItem("thor_match_id");
  localStorage.removeItem("thor_match_opponent_name");
  localStorage.removeItem("thor_match_opponent_id");
  localStorage.removeItem("thor_match_source");

  // Enviar mensagem ao parent para navegar
  if (window.parent && window.parent !== window) {
    try {
      if (multiplayerMode && matchId) {
        // Em multiplayer: voltar para o chat com resultado
        window.parent.postMessage({
          type: "THOR:RETURN_TO_CHAT",
          payload: {
            matchId: matchId,
            result: winner, // "VICTORY", "DEFEAT", "Empate!"
            myKills: oppLost,
            oppKills: myLost,
            opponentName: opponentName,
            xpGained: finalXpForChat // ðŸŽ¯ Usar XP salvo no fim do jogo
          }
        }, window.location.origin);
      } else {
        // Modo solo: voltar para seleÃ§Ã£o de modo
        
        // Esconder canvas e UI do jogo antes de navegar (evita piscada)
        document.getElementById('gameCanvas').style.display = 'none';
        document.getElementById('hudTop').style.display = 'none';
        document.getElementById('legendArea').style.display = 'none';
        
        window.parent.postMessage(
          { type: "THOR:BACK_TO_MODE", payload: { score: clampScore(), xpGained: finalXpForChat } },
          window.location.origin
        );
      }
    } catch (err) {
      console.error('[GAME] Erro ao enviar mensagem:', err);
    }
  }
  
  // Resetar winner
  winner = null;
}



// Exemplo: evento do botÃ£o
document.getElementById('restartVictory').onclick = backToStartMenu;
document.getElementById('restartDefeat').onclick = backToStartMenu;
document.getElementById('restartDraw').onclick = backToStartMenu;

// FunÃ§Ã£o para criar partÃ­culas de explosÃ£o
function spawnExplosionParticles(x, y, color = "#fff") {
  for (let i = 0; i < 18; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 2 + Math.random() * 3;
    particles.push({
      x,
      y,
      dx: Math.cos(angle) * speed,
      dy: Math.sin(angle) * speed,
      life: 16 + Math.random() * 16,
      color,
      size: 2.5 + Math.random() * 2
    });
  }
}

// Atualiza e desenha partÃ­culas
function updateParticles(ctx) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.dx;
    p.y += p.dy;
    p.dy += 0.05; // leve gravidade
    p.life--;
    if (p.life <= 0) {
      particles.splice(i, 1);
    }
  }
}
function drawParticles(ctx) {
  for (const p of particles) {
    ctx.save();
    ctx.globalAlpha = Math.max(0, p.life / 20);
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

  let screenShake = 0;
let shakeX = 0, shakeY = 0;
let round = 1; // comeÃ§a em 1
let showingRoundText = true;
let roundTextAlpha = 0;
let roundTextFadeIn = true;
let roundTextTimer = 0;
const ROUND_TEXT_DISPLAY = 35; // frames (2s)
let planningTimer = 10; // segundos
let lastTime = Date.now();

const backgroundGalaxy = new Image();
backgroundGalaxy.src = "images/galaxia.png"; // SerÃ¡ atualizado por applyGameBackground()
window.backgroundGalaxy = backgroundGalaxy; // Expor globalmente para applyGameBackground

const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const sfxHit = [document.getElementById("sfx-hit"), document.getElementById("sfx-hit2")];
function playHit() {
  if (sfxMuted) return;
  const s = sfxHit[Math.floor(Math.random() * sfxHit.length)];
  s.currentTime = 0;
  s.play().catch(e => {});
}
const sfxShot = document.getElementById("sfx-shot");
const sfxExplode = document.getElementById("sfx-explode");
const sfxWinner = document.getElementById("sfx-winner");
const sfxLoss = document.getElementById("sfx-loss");
const bgmBattle = document.getElementById("bgm-battle");
bgmBattle.volume = 0.15;
const BGM_TRACKS = [
  'sounds/battle1.mp3',
  'sounds/battle2.mp3',
  'sounds/battle3.mp3',
  'sounds/battle4.mp3',
];
let bgmMuted = false;
let sfxMuted = false;
let musicMuted = false;

function applyAudioSettings() {
  try {
    const raw = localStorage.getItem('thor_settings_v1');
    const s = raw ? JSON.parse(raw) : {};
    const audio = s.audio || {};
    const master = audio.master !== false;
    const music  = audio.music  !== false;
    const sfx    = audio.sfx    !== false;
    sfxMuted   = !master || !sfx;
    musicMuted = !master || !music;
    bgmBattle.muted = musicMuted || bgmMuted;
    // Sync BGM button icon
    const effectiveMuted = bgmMuted || musicMuted;
    const iconOn  = document.getElementById('bgm-icon-on');
    const iconOff = document.getElementById('bgm-icon-off');
    if (iconOn)  iconOn.style.display  = effectiveMuted ? 'none' : '';
    if (iconOff) iconOff.style.display = effectiveMuted ? '' : 'none';
  } catch(e) {}
}
applyAudioSettings();

function playRandomBgm() {
  const track = BGM_TRACKS[Math.floor(Math.random() * BGM_TRACKS.length)];
  bgmBattle.src = track;
  bgmBattle.currentTime = 0;
  bgmBattle.muted = bgmMuted || musicMuted;
  bgmBattle.play().catch(e => {});
  const muteBtn = document.getElementById('bgm-mute-btn');
  if (muteBtn) muteBtn.style.display = 'flex';
}
function toggleBgmMute() {
  bgmMuted = !bgmMuted;
  const effectiveMuted = bgmMuted || musicMuted;
  bgmBattle.muted = effectiveMuted;
  document.getElementById('bgm-icon-on').style.display = effectiveMuted ? 'none' : '';
  document.getElementById('bgm-icon-off').style.display = effectiveMuted ? '' : 'none';
}

window.addEventListener('message', (e) => {
  if (e.data && e.data.type === 'THOR:AUDIO_SETTINGS') {
    applyAudioSettings();
  }
});

const NAVY_SIZE = 50;
const SPEED = 2.5; // AAA: aumentado para movimento mais fluido
let projectiles = [];

// ConfiguraÃ§Ã£o visual dos tipos de tiro (AAA)
const SHOT_TYPES = {
  plasma: {
    accentColor: null, // Usa cor pura do time
    tailLength: 9,
    glowSize: 0, // MODO PERFORMANCE: SEM shadowBlur (GPU killer)
    glowIntensity: 0
  },
  pulse: {
    accentColor: "#ff8800", // Laranja vibrante
    tailLength: 12, // Reduzido de 15
    glowSize: 0, // MODO PERFORMANCE: SEM shadowBlur
    glowIntensity: 0,
    pulseSpeed: 200,
    particleCount: 2
  },
  energy: {
    accentColor: "#d946ef", // Roxo/Magenta
    tailLength: 8,
    glowSize: 0, // MODO PERFORMANCE: SEM shadowBlur
    glowIntensity: 0,
    sparkCount: 1
  }
};
let explosions = [];
let wrecks = [];
let winner = null;


const spritePlayer = new Image();
spritePlayer.src = "images/spaceschip.png";
const spriteCPU = new Image();
spriteCPU.src = "images/spaceschip.png";

// Sprites vermelhos prÃ©-carregados
const redSprites = {
  basic: new Image(),
  alcance: new Image(),
  protecao: new Image()
};
redSprites.basic.src = "images/nave_normal_red.png";
redSprites.alcance.src = "images/nave_alcance_red.png";
redSprites.protecao.src = "images/nave_protecao_red.png";

let mouseX = 0;
let mouseY = 0;
let selectedNave = null;
let phase = "roundText"; // ComeÃ§a mostrando o texto "Round 1"
let turnTime = 0;


let playerNaves = [];

// Aplicar MINHAS naves (controlÃ¡veis em playerNaves)
function applyMyShips(selecao, isP1) {
  if (!myTeam) {
    console.error('[PVP] myTeam Ã© null ao aplicar naves!');
  }
  
  // POSIÃ‡Ã•ES FÃSICAS CORRETAS:
  // Player1 (isP1=true): TOPO esquerda (posiÃ§Ãµes BLUE)
  // Player2 (isP1=false): BAIXO direita (posiÃ§Ãµes RED)
  const posicoes = isP1 ? [
    { x: 100, y: 250 },  // P1 topo
    { x: 260, y: 80 },
    { x: 100, y: 80 }
  ] : [
    { x: 700, y: 520 },  // P2 baixo
    { x: 540, y: 520 },
    { x: 700, y: 350 }
  ];
  
  // Centro do campo adversÃ¡rio para apontar as naves
  const opponentCenterX = isP1 ? 620 : 180;
  const opponentCenterY = isP1 ? 460 : 150;

  playerNaves = selecao.map((tipo, index) => {
    let hp = 99;
    let alcance = 300;
    let sprite = new Image();

    if (tipo === 1) {
      hp = 66; // Nave Alcance: 2 tiros para destruir (66 / 33 = 2)
      alcance = 360;
      sprite.src = "images/nave_alcance.png";
    } else if (tipo === 2) {
      hp = 132; // Nave ProteÃ§Ã£o: 4 tiros para destruir (132 / 33 = 4)
      alcance = 160;
      sprite.src = "images/nave_protecao.png";
    } else if (tipo === 4) {
      hp = 66;
      alcance = 400;
      sprite.src = "images/nave_alcance_red_vip.png";
    } else if (tipo === 5) {
      hp = 66;
      alcance = 400;
      sprite.src = "images/nave_alcance_vip.png";
    } else if (tipo === 6) {
      hp = 160;
      alcance = 180;
      sprite.src = "images/nave_protecao_vip.png";
    } else if (tipo === 7) {
      hp = 160;
      alcance = 180;
      sprite.src = "images/nave_protecao_red_vip.png";
    } else if (tipo === 8) {
      hp = 99;
      alcance = 360;
      sprite.src = "images/nave_normal_vip.png";
    } else if (tipo === 9) {
      hp = 99;
      alcance = 360;
      sprite.src = "images/nave_normal_red_vip.png";
    } else {
      hp = 99; // Nave Normal: 3 tiros para destruir (99 / 33 = 3)
      alcance = 300;
      sprite.src = "images/spaceschip.png";
    }

    const nave = {
      x: posicoes[index].x,
      y: posicoes[index].y,
      target: null,
      shot: null,
      hp,
      angle: 0, // serÃ¡ calculado abaixo
      tipo,
      sprite,
      alcance
    };
    
    
    // Calcular Ã¢ngulo individual apontando para o centro adversÃ¡rio
    const dx = opponentCenterX - nave.x;
    const dy = opponentCenterY - nave.y;
    nave.angle = Math.atan2(dy, dx) + Math.PI / 2;
    
    // COR DO TIME: P1 = AZUL (sem tint), P2 = VERMELHO (tint='red')
    if (multiplayerMode && !isP1) {
      nave.tint = 'red';
    }
    
    return nave;
  });
  
  debug.pvp('[PVP] playerNaves aplicadas (isP1=' + isP1 + '):', playerNaves.map(n => ({ x: n.x, y: n.y, tipo: n.tipo, angle: n.angle, tint: n.tint })));
}

// MantÃ©m compatibilidade com modo solo
function applyPlayerNavesFromSelection(selecao = null, isPlayer1Owner = true) {
  selecao = selecao || JSON.parse(localStorage.getItem("navesSelecionadas") || "[3,3,3]");
  if (multiplayerMode) {
    applyMyShips(selecao, isPlayer1Owner);
  } else {
    // Modo solo original
    try {
      const posicoes = [
        { x: 100, y: 250 },
        { x: 260, y: 80 },
        { x: 100, y: 80 }
      ];

      // Centro do campo adversÃ¡rio (CPU)
      const opponentCenterX = 620;
      const opponentCenterY = 460;

      playerNaves = selecao.map((tipo, index) => {
        let hp = 99;
        let alcance = 300;
        let sprite = new Image();

        if (tipo === 1) {
          hp = 66;
          alcance = 360;
          sprite.src = "images/nave_alcance.png";
        } else if (tipo === 2) {
          hp = 132;
          alcance = 160;
          sprite.src = "images/nave_protecao.png";
        } else if (tipo === 4) {
          hp = 66;
          alcance = 400;
          sprite.src = "images/nave_alcance_red_vip.png";
        } else if (tipo === 5) {
          hp = 66;
          alcance = 400;
          sprite.src = "images/nave_alcance_vip.png";
        } else if (tipo === 6) {
          hp = 160;
          alcance = 180;
          sprite.src = "images/nave_protecao_vip.png";
        } else if (tipo === 7) {
          hp = 160;
          alcance = 180;
          sprite.src = "images/nave_protecao_red_vip.png";
        } else if (tipo === 8) {
          hp = 99;
          alcance = 360;
          sprite.src = "images/nave_normal_vip.png";
        } else if (tipo === 9) {
          hp = 99;
          alcance = 360;
          sprite.src = "images/nave_normal_red_vip.png";
        } else {
          hp = 99;
          alcance = 300;
          sprite.src = "images/spaceschip.png";
        }

        const nave = {
          x: posicoes[index].x,
          y: posicoes[index].y,
          target: null,
          shot: null,
          hp,
          angle: 0,
          tipo,
          sprite,
          alcance
        };
        
        // Calcular Ã¢ngulo apontando para o centro do campo adversÃ¡rio
        const dx = opponentCenterX - nave.x;
        const dy = opponentCenterY - nave.y;
        nave.angle = Math.atan2(dy, dx) + Math.PI / 2;
        
        return nave;
      });
    } catch (err) {
      console.error('[SOLO] Erro ao aplicar naves do jogador:', err);
    }
  }
}


// Criar cpuNaves placeholder (serÃ£o preenchidas depois)
const cpuNaves = Array.from({ length: 3 }, (_, i) => {
  const posicoes = [
    { x: 700, y: 520 },
    { x: 540, y: 520 },
    { x: 700, y: 350 }
  ];

  return {
    x: posicoes[i].x,
    y: posicoes[i].y,
    target: null,
    shot: null,
    hp: 0, // Inicialmente sem HP (serÃ¡ preenchido depois)
    angle: 0,
    tipo: 3,
    sprite: new Image(),
    initialized: false
  };
});

// Inicializar cpuNaves como CPU padrÃ£o (apenas para modo solo)
function initCpuNaves() {
  if (multiplayerMode) {
    debug.pvp('[PVP] Modo multiplayer - nÃ£o inicializar CPU');
    return;
  }
  
  
  // Centro do campo do jogador
  const playerCenterX = 180;
  const playerCenterY = 150;
  
  cpuNaves.forEach((n, i) => {
    const tipo = Math.floor(Math.random() * 3) + 1;
    let sprite = new Image();
    if (tipo === 1) sprite.src = "images/nave_alcance.png";
    else if (tipo === 2) sprite.src = "images/nave_protecao.png";
    else sprite.src = "images/spaceschip.png";

    const hp = tipo === 1 ? 50 : tipo === 2 ? 100 : 75;

    n.tipo = tipo;
    n.sprite = sprite;
    n.hp = hp;
    n.initialized = true;
    n.tint = 'red'; // CPU Ã© sempre vermelha no modo solo
    
    // Calcular Ã¢ngulo apontando para o centro do campo do jogador
    const dx = playerCenterX - n.x;
    const dy = playerCenterY - n.y;
    n.angle = Math.atan2(dy, dx) + Math.PI / 2;
  });
}




canvas.addEventListener("mousemove", (e) => {
  const rect = canvas.getBoundingClientRect();
  mouseX = e.clientX - rect.left;
  mouseY = e.clientY - rect.top;
});

// ===============================
// Canvas Click Handler - SeleÃ§Ã£o de naves, movimento e tiro
// ===============================
function handleCanvasClick(event) {
  
  // NÃ£o permitir cliques se round estÃ¡ travado (todas as naves configuradas)
  if (roundLocked) {
    return;
  }
  
  // NÃ£o permitir cliques durante animaÃ§Ãµes ou pausas
  if (phase === "wait" || phase === "roundText" || phase === "pauseReadyGo") {
    return;
  }
  
  const rect = canvas.getBoundingClientRect();
  const clickX = event.clientX - rect.left;
  const clickY = event.clientY - rect.top;
  

  // FASE 1: Selecionar nave (se ainda nÃ£o hÃ¡ nave selecionada)
  // Aceita tanto "select" (multiplayer) quanto "selectMove" (solo)
  if (selectedNave === null && (phase === "selectMove" || phase === "select")) {
    
    for (let i = 0; i < playerNaves.length; i++) {
      const nave = playerNaves[i];
      if (nave.hp <= 0) continue; // Pula naves destruÃ­das
      
      // NÃƒO permitir selecionar nave que jÃ¡ estÃ¡ READY (tem target E shot)
      if (nave.target && nave.shot) {
        continue;
      }
      
      // Verificar se clicou na nave (distÃ¢ncia < 50px - aumentado para facilitar clique)
      const dist = Math.hypot(clickX - nave.x, clickY - nave.y);
      
      if (dist < 50) {
        selectedNave = nave;
        // Manter a fase como estÃ¡ (nÃ£o forÃ§ar "selectMove" se estÃ¡ em "select")
        document.getElementById("legendArea").textContent = t('chooseDestination');
        return;
      }
    }
    return; // Se nÃ£o clicou em nenhuma nave, ignora
  }

  // FASE 2: Definir movimento (target)
  // SÃ³ entra aqui se o target ainda NÃƒO foi definido
  if (selectedNave !== null && (phase === "selectMove" || phase === "select") && !selectedNave.target) {
    // Calcular distÃ¢ncia do clique atÃ© a posiÃ§Ã£o atual da nave
    const distFromNave = Math.hypot(clickX - selectedNave.x, clickY - selectedNave.y);
    
    // Verificar se estÃ¡ dentro do alcance de movimento
    if (distFromNave <= selectedNave.alcance) {
      // Permitir clicar onde a nave estÃ¡ (target = posiÃ§Ã£o atual = nave fica parada)
      selectedNave.target = { x: clickX, y: clickY };
      
      // Em modo solo, mudar para selectShot. Em multiplayer, manter "select"
      if (!multiplayerMode) {
        phase = "selectShot";
      }
      
      document.getElementById("legendArea").textContent = t('chooseTarget');
    } else {
      // Fora do alcance - ignorar ou mostrar feedback
    }
    return;
  }

  // FASE 3: Definir tiro (shot)
  // Em multiplayer phase fica "select", em solo muda para "selectShot"
  if (selectedNave !== null && (phase === "selectShot" || (phase === "select" && selectedNave.target !== null))) {
    selectedNave.shot = { x: clickX, y: clickY };

    // Verificar se em multiplayer e se todas as naves jÃ¡ configuradas
    if (multiplayerMode) {
      const allShipsReady = playerNaves.filter(nav => nav.hp > 0).every(nav => nav.target && nav.shot);
  
      if (allShipsReady) {
        debug.pvp('[PVP] âœ… Todas as naves configuradas! Enviando aÃ§Ã£o via Supabase...');
        debug.pvp('[PVP] myUserId:', myUserId);
        debug.pvp('[PVP] matchData.player1_id:', matchData?.player1_id);
        debug.pvp('[PVP] Sou Player 1?', myUserId === matchData?.player1_id);
    
        // Coletar aÃ§Ãµes de todas as naves
        const ships = playerNaves.map((n, idx) => ({
          index: idx,
          x: n.x,  // posiÃ§Ã£o canÃ´nica para animaÃ§Ã£o determinÃ­stica
          y: n.y,  // posiÃ§Ã£o canÃ´nica para animaÃ§Ã£o determinÃ­stica
          target: n.target ? { x: n.target.x, y: n.target.y } : null,
          shot: n.shot ? { x: n.shot.x, y: n.shot.y } : null,
          hp: n.hp,
          angle: n.angle,
          // Incluir shotType no payload para garantir sincronizaÃ§Ã£o visual entre telas
          shotType: (typeof ShotTypeManager !== 'undefined') ? ShotTypeManager.getShotType(n.tipo) : 'plasma'
        }));
    
        // Enviar via sistema de database
        submitMyAction({
          type: 'play',
          ships: ships
        });
    
        roundLocked = true; // Travar cliques mas manter phase
        selectedNave = null;
        document.getElementById("legendArea").textContent = t('waitingOpponentShort');
      } else {
        // Algumas naves configuradas, continuar
        // broadcastRealtimeState() removido: nÃ£o vazar posiÃ§Ãµes de planejamento ao oponente
        selectedNave = null;
        // Manter phase = "select" em multiplayer
        document.getElementById("legendArea").textContent = t('selectAnotherShip');
      }
    } else {
      // Modo solo
      selectedNave = null;
      if (playerNaves.filter(n => n.hp > 0).every(n => n.shot)) {
        phase = "wait";
        generateCpuOrders();
        
        // ðŸ”¥ AAA: Ativar fase de combate (necessÃ¡rio para o game loop processar projÃ©teis)
        combatPhase = 'combat';
        movementComplete = false;
        shootingComplete = false;
        projectileHitRegistry.clear();
        
        fireProjectiles();
        document.getElementById("legendArea").textContent = t('attentionCommander');
      } else {
        phase = "selectMove";
        document.getElementById("legendArea").textContent = t('selectAnotherShip');
      }
    }
    return;
  }
}

// Registrar event listener de click
canvas.addEventListener('click', function(event) {
  handleCanvasClick(event);
});


function isCritical(nave) {
  return nave.hp > 0 && nave.hp <= 33; // 33 ou menos, pronto para explodir no prÃ³ximo tiro
}



function drawNave(nave, image, isCPU = false) {
  if (nave.hp <= 0) return;

  ctx.save();

  // Escolhe sprite: player usa nave.sprite, CPU usa image padrÃ£o
  let spriteToUse = !isCPU && nave.sprite ? nave.sprite : image;

  let tremorX = 0, tremorY = 0, naveAlpha = 1;
    const isMoving = nave.target !== null;
const idleBob = isMoving ? 0 : Math.sin(performance.now() / 500 + nave.x) * 2.0;
  if (isCritical(nave)) {
    tremorX = (Math.random() - 0.5) * 8;
    tremorY = (Math.random() - 0.5) * 8;
    naveAlpha = 0.5 + 0.5 * Math.sin(performance.now() / 80);
  }




  const fallback = isCPU ? { x: nave.x - 100, y: nave.y - 100 } : { x: nave.x + 100, y: nave.y + 100 };
  const target = nave.target || fallback;
  const dx = target.x - nave.x;
  const dy = target.y - nave.y;
  const desiredAngle = Math.atan2(dy, dx) + Math.PI / 2;
  
  // CORREÃ‡ÃƒO: Se nave.angle jÃ¡ foi definido e nÃ£o hÃ¡ target real, manter o Ã¢ngulo inicial
  // NÃ£o recalcular baseado no fallback!
  if (nave.angle === undefined || nave.angle === null) {
    nave.angle = desiredAngle;
  } else if (nave.target !== null) {
    // SÃ³ interpolar se houver um target REAL (nÃ£o fallback)
    nave.angle += (desiredAngle - nave.angle) * 0.15;
  }
  // Caso contrÃ¡rio, manter nave.angle fixo (nÃ£o recalcular com fallback)

  ctx.translate(nave.x + tremorX, nave.y + tremorY + idleBob);
  ctx.rotate(nave.angle);
  ctx.globalAlpha = naveAlpha;

  // Se tint vermelho, usar sprite vermelho prÃ©-carregado
  if (nave.tint === 'red') {
    if (nave.tipo === 1 && redSprites.alcance.complete) {
      spriteToUse = redSprites.alcance;
    } else if (nave.tipo === 2 && redSprites.protecao.complete) {
      spriteToUse = redSprites.protecao;
    } else if (nave.tipo === 3 && redSprites.basic.complete) {
      spriteToUse = redSprites.basic;
    }
  }
  
  // Desenhar a nave
  ctx.drawImage(spriteToUse, -NAVY_SIZE / 2, -NAVY_SIZE / 2, NAVY_SIZE, NAVY_SIZE);
  
  ctx.globalAlpha = 1;
  ctx.restore();

  // IndicaÃ§Ã£o visual de nave selecionada (comparaÃ§Ã£o direta de objeto)
  if (!isCPU && selectedNave === nave) {
    const pulse = 0.7 + 0.3 * Math.sin(selectPulseTime * 2);
    ctx.save();
    ctx.beginPath();
    ctx.arc(nave.x, nave.y, NAVY_SIZE * (1 + 0.11 * pulse), 0, Math.PI * 2);
    ctx.globalAlpha = 0.4 + 0.3 * pulse;
    ctx.strokeStyle = "#0ff";
    ctx.lineWidth = 5 + 4 * pulse;
    ctx.shadowColor = "#0ff";
    ctx.shadowBlur = 18 + 14 * pulse;
    ctx.stroke();
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  if (!isCPU && nave.target && nave.shot) {
    ctx.save();
    ctx.font = "bold 14px sans-serif";
    ctx.textAlign = "center";
    ctx.fillStyle = "#ff0";
    ctx.strokeStyle = "#222";
    ctx.lineWidth = 3;
    ctx.strokeText("READY", nave.x, nave.y - NAVY_SIZE);
    ctx.fillText("READY", nave.x, nave.y - NAVY_SIZE);
    ctx.restore();
  }

  ctx.fillStyle = "red";
ctx.fillRect(nave.x - 15, nave.y - NAVY_SIZE / 2 - 10, 30, 5);

let maxHP = nave.tipo === 1 ? 50 : nave.tipo === 2 ? 100 : 75;
ctx.fillStyle = "lime";
ctx.fillRect(nave.x - 15, nave.y - NAVY_SIZE / 2 - 10, 30 * (nave.hp / maxHP), 5);



}


// Supondo que vocÃª jÃ¡ tem:
const startBtn = document.getElementById("startBtn");
const startModal = document.getElementById("startModal");
const galaxyBg = document.getElementById("galaxyBg");
const thorspaceTitle = document.getElementById("thorspace-title");
const playerNameInput = document.getElementById("playerNameInput");

// FunÃ§Ã£o Ãºnica para checar se seleÃ§Ã£o estÃ¡ travada
function isSelectionLocked() {
  // matchPhase pode ser currentPhase ou match.phase dependendo do contexto
  const phase = (typeof match !== 'undefined' && match && match.phase) ? match.phase : (typeof currentPhase !== 'undefined' ? currentPhase : null);
  const locked = (phase !== 'select') || (PVP.battleStarted === true) || (PVP.localTurnSubmitted === true) || (PVP.waitingOpponent === true);
  if (locked) {
  }
  return locked;
}


// ðŸ”¥ AAA: Verificar se todas as naves completaram movimento
function allShipsFinishedMoving() {
  const playerMoving = playerNaves.some(n => n.target !== null && n.hp > 0);
  const cpuMoving = cpuNaves.some(n => n.target !== null && n.hp > 0);
  const finished = !playerMoving && !cpuMoving;
  
  return finished;
}

function moveTowards(nave) {
  if (!nave.target || nave.hp <= 0) return;
  
  const dx = nave.target.x - nave.x;
  const dy = nave.target.y - nave.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  
  const scaledSpeed = SPEED * _frameDt;
  if (dist < scaledSpeed) {
    nave.x = nave.target.x;
    nave.y = nave.target.y;
    nave.target = null;
  } else {
    nave.x += scaledSpeed * dx / dist;
    nave.y += scaledSpeed * dy / dist;
  }
  nave.x = Math.max(NAVY_SIZE / 2, Math.min(canvas.width - NAVY_SIZE / 2, nave.x));
  nave.y = Math.max(NAVY_SIZE / 2, Math.min(canvas.height - NAVY_SIZE / 2, nave.y));
}

// ðŸŽ¯ PHASE 3: PrediÃ§Ã£o de movimento entre snapshots (Dead Reckoning)
// P2 usa velocidade estimada para interpolar posiÃ§Ã£o de naves inimigas
function applyDeadReckoning() {
  // DESABILITADO: Dead reckoning causava jitter em produÃ§Ã£o com latÃªncia real
  // Snapshots a cada 3s + lerp adaptativo jÃ¡ fornecem sincronizaÃ§Ã£o suficiente
  return;
  
  // CÃ“DIGO ORIGINAL (mantido para referÃªncia):
  // if (!multiplayerMode || isPlayer1Host) return;
  // cpuNaves.forEach((nave, i) => {
  //   const shipId = `cpu_${i}`;
  //   const velocity = shipVelocities.get(shipId);
  //   if (velocity && velocity.vx !== undefined && nave.hp > 0) {
  //     const speed = Math.sqrt(velocity.vx * velocity.vx + velocity.vy * velocity.vy);
  //     if (speed > 0.5 && speed < 3) {
  //       nave.x += velocity.vx * 0.02;
  //       nave.y += velocity.vy * 0.02;
  //       nave.x = Math.max(NAVY_SIZE / 2, Math.min(canvas.width - NAVY_SIZE / 2, nave.x));
  //       nave.y = Math.max(NAVY_SIZE / 2, Math.min(canvas.height - NAVY_SIZE / 2, nave.y));
  //     }
  //   }
  // });
}

function generateCpuOrders() {
  // Em modo PVP real, nÃ£o gerar ordens automÃ¡ticas de CPU
  if (multiplayerMode) {
    debug.pvp('[PVP] Modo PVP ativo - CPU desabilitada, aÃ§Ãµes vem do Supabase');
    return;
  }
  
  cpuNaves.forEach((n, i) => {
    if (n.hp <= 0) return;

    // Gera um destino aleatÃ³rio prÃ³ximo
    const angle = Math.random() * Math.PI * 2;
    const distance = 80 + Math.random() * 120;
    const nx = n.x + Math.cos(angle) * distance;
    const ny = n.y + Math.sin(angle) * distance;

    // Limita dentro da tela
    n.target = {
      x: Math.max(NAVY_SIZE/2, Math.min(800 - NAVY_SIZE/2, nx)),
      y: Math.max(NAVY_SIZE/2, Math.min(600 - NAVY_SIZE/2, ny))
    };

    // Mira em uma nave do player ainda viva (simples: escolhe a primeira viva)
    let targetNave = playerNaves.find(pn => pn.hp > 0);
    if (targetNave) {
      n.shot = { x: targetNave.x, y: targetNave.y };
    }
  });
}



function applyScreenShake() {
  if (screenShake > 0) {
    shakeX = (Math.random() - 0.5) * screenShake * 4;
    shakeY = (Math.random() - 0.5) * screenShake * 4;
    screenShake--;
  } else {
    shakeX = 0;
    shakeY = 0;
  }
}


function areNavesColliding(n1, n2) {
  if (n1.hp <= 0 || n2.hp <= 0) return false;
  const dx = n1.x - n2.x;
  const dy = n1.y - n2.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  return dist < NAVY_SIZE; // Troque NAVY_SIZE para ajustar a "sensibilidade" da colisÃ£o
}

function checkNaveCollisions() {
  let alreadyExploded = new Set();

  // Player vs Player (colidiu duas naves suas: -25 pontos por colisÃ£o)
  for (let i = 0; i < playerNaves.length; i++) {
    for (let j = i + 1; j < playerNaves.length; j++) {
      const id = "p" + i + "p" + j;
      if (!alreadyExploded.has(id) && areNavesColliding(playerNaves[i], playerNaves[j])) {
        if (playerNaves[i].hp > 0 && playerNaves[j].hp > 0) {
          playerDestroyed += 2;
          playerScore -= 25;               // -25 pontos por colisÃ£o de DUAS naves SUAS
          collisionPlayerSolo++;           // ADICIONE ESTA LINHA: conta quantas colisÃµes prÃ³prias
          playerNaves[i].hp = 0;
          playerNaves[j].hp = 0;
          
          // âœ… XP: ColisÃ£o com nave aliada
          registerXPEvent('FRIENDLY_COLLISION');
          roundCollisionLosses += 2; // Contar separadamente (nÃ£o soma em roundLosses)
          
          explosions.push({ x: playerNaves[i].x, y: playerNaves[i].y, radius: 1, big: true, flash: 8 });
          explosions.push({ x: playerNaves[j].x, y: playerNaves[j].y, radius: 1, big: true, flash: 8 });
          spawnExplosionParticles(playerNaves[i].x, playerNaves[i].y, "#0ff");
          spawnExplosionParticles(playerNaves[j].x, playerNaves[j].y, "#0ff");
          wrecks.push({ x: playerNaves[i].x, y: playerNaves[i].y });
          wrecks.push({ x: playerNaves[j].x, y: playerNaves[j].y });
          if (!sfxMuted) sfxExplode.play().catch(e => {});
          screenShake = 10;
          alreadyExploded.add(id);
        }
      }
    }
  }

  // CPU vs CPU (colidiu sozinho: +25 pontos pra vocÃª por colisÃ£o deles)
  for (let i = 0; i < cpuNaves.length; i++) {
    for (let j = i + 1; j < cpuNaves.length; j++) {
      const id = "c" + i + "c" + j;
      if (!alreadyExploded.has(id) && areNavesColliding(cpuNaves[i], cpuNaves[j])) {
        if (cpuNaves[i].hp > 0 && cpuNaves[j].hp > 0) {
          cpuDestroyed += 2;
          playerScore += 25;               // +25 pontos por colisÃ£o de DUAS naves CPU
          collisionCpuSolo++;              // ADICIONE ESTA LINHA: conta quantas colisÃµes CPU x CPU
          cpuNaves[i].hp = 0;
          cpuNaves[j].hp = 0;
          explosions.push({ x: cpuNaves[i].x, y: cpuNaves[i].y, radius: 1, big: true, flash: 8 });
          explosions.push({ x: cpuNaves[j].x, y: cpuNaves[j].y, radius: 1, big: true, flash: 8 });
          spawnExplosionParticles(cpuNaves[i].x, cpuNaves[i].y, "#ff6600");
          spawnExplosionParticles(cpuNaves[j].x, cpuNaves[j].y, "#ff6600");
          wrecks.push({ x: cpuNaves[i].x, y: cpuNaves[i].y });
          wrecks.push({ x: cpuNaves[j].x, y: cpuNaves[j].y });
          if (!sfxMuted) sfxExplode.play().catch(e => {});
          screenShake = 10;
          alreadyExploded.add(id);
        }
      }
    }
  }

  // Player vs CPU (cada um perde uma nave; score estÃ¡ no updateProjectiles)
  for (let i = 0; i < playerNaves.length; i++) {
    for (let j = 0; j < cpuNaves.length; j++) {
      const id = "p" + i + "c" + j;
      if (!alreadyExploded.has(id) && areNavesColliding(playerNaves[i], cpuNaves[j])) {
        if (playerNaves[i].hp > 0 && cpuNaves[j].hp > 0) {
          playerNaves[i].hp = 0;
          cpuNaves[j].hp = 0;
          playerDestroyed += 1;
          cpuDestroyed += 1;
          // NÃƒO soma score aqui, pois updateProjectiles jÃ¡ faz isso!
          
          // âœ… XP: ColisÃ£o com nave inimiga
          registerXPEvent('ENEMY_COLLISION');
          roundKills++;
          roundCollisionLosses++; // Contar separadamente
          
          explosions.push({ x: playerNaves[i].x, y: playerNaves[i].y, radius: 1, big: true, flash: 8 });
          explosions.push({ x: cpuNaves[j].x, y: cpuNaves[j].y, radius: 1, big: true, flash: 8 });
          spawnExplosionParticles(playerNaves[i].x, playerNaves[i].y, "#0ff");
          spawnExplosionParticles(cpuNaves[j].x, cpuNaves[j].y, "#ff6600");
          wrecks.push({ x: playerNaves[i].x, y: playerNaves[i].y });
          wrecks.push({ x: cpuNaves[j].x, y: cpuNaves[j].y });
          if (!sfxMuted) sfxExplode.play().catch(e => {});
          screenShake = 10;
          alreadyExploded.add(id);
        }
      }
    }
  }
}



function buildScoreDetails() {
  
  // âœ… USAR EVENTOS DE XP OFICIAIS
  // Filtrar apenas eventos que realmente ocorreram (nÃ£o exibir eventos com XP 0 ou que nÃ£o aconteceram)
  const activeEvents = xpEvents.filter(event => event.xp !== 0);
  
  
  if (activeEvents.length === 0) {
    return `
      <div class="score-grid">
        <div class="score-hex inactive">
          <div class="hex-outline"></div>
          <div class="hex-title">Nenhum evento</div>
          <div class="hex-points">0</div>
        </div>
      </div>
    `;
  }
  
  // Agrupar eventos por tipo para evitar mÃºltiplas entradas do mesmo evento
  const eventGroups = {};
  activeEvents.forEach(event => {
    if (!eventGroups[event.key]) {
      eventGroups[event.key] = {
        name: event.name,
        xp: 0,
        count: 0
      };
    }
    eventGroups[event.key].xp += event.xp;
    eventGroups[event.key].count++;
  });
  
  
  // Converter grupos em array de items (SEM mostrar o multiplicador)
  const items = Object.values(eventGroups).map(group => ({
    title: group.name, // Remover o "(5x)" - apenas mostrar o nome
    value: group.xp,
    active: true
  }));
  
  
  // Ordenar: positivos primeiro, depois negativos
  items.sort((a, b) => b.value - a.value);
  
  const html = `
    <div class="score-grid">
      ${items.map(it => `
        <div class="score-hex active">
          <div class="hex-outline"></div>
          <div class="hex-title">${it.title}</div>
          <div class="hex-points">${formatPoints(it.value)}</div>
        </div>
      `).join("")}
    </div>
  `;
  return html;
}

function formatPoints(v){
  if (v === 0) return "0";
  if (v > 0) return `+${v}`;
  return `${v}`; // negativo jÃ¡ vem com "-"
}


function getEdgePoint(from, to, canvasWidth = canvas.width, canvasHeight = canvas.height) {
  const dx = to.x - from.x;
  const dy = to.y - from.y;
  if (dx === 0 && dy === 0) return { x: from.x, y: from.y };

  // Fatores de interseÃ§Ã£o com cada borda (esq, dir, cima, baixo)
  let tValues = [];
  // Esquerda
  if (dx !== 0) {
    let t = (0 - from.x) / dx;
    let y = from.y + t * dy;
    if (t > 0 && y >= 0 && y <= canvasHeight) tValues.push(t);
  }
  // Direita
  if (dx !== 0) {
    let t = (canvasWidth - from.x) / dx;
    let y = from.y + t * dy;
    if (t > 0 && y >= 0 && y <= canvasHeight) tValues.push(t);
  }
  // Topo
  if (dy !== 0) {
    let t = (0 - from.y) / dy;
    let x = from.x + t * dx;
    if (t > 0 && x >= 0 && x <= canvasWidth) tValues.push(t);
  }
  // Base
  if (dy !== 0) {
    let t = (canvasHeight - from.y) / dy;
    let x = from.x + t * dx;
    if (t > 0 && x >= 0 && x <= canvasWidth) tValues.push(t);
  }

  // O menor t positivo te leva atÃ© a primeira borda
  let tMin = Math.min(...tValues);
  return {
    x: from.x + dx * tMin,
    y: from.y + dy * tMin
  };
}



function fireProjectiles() {
  const PROJECTILE_SPEED = 6; // antes estava super lento
  
  // fireProjectiles chamada

  playerNaves.forEach((n, idx) => {
    if (n.shot && n.hp > 0) {
      // Player nave disparando
      if (!sfxMuted) sfxShot.play().catch(e => {});
      const end = getEdgePoint({ x: n.x, y: n.y }, n.shot);
      const dist = Math.sqrt((end.x - n.x) ** 2 + (end.y - n.y) ** 2);
      const dx = (end.x - n.x) / dist * PROJECTILE_SPEED;
      const dy = (end.y - n.y) / dist * PROJECTILE_SPEED;
      
      // Obter shot type usando ShotTypeManager (AAA quality)
      // IMPORTANTE: buscar pelo TIPO DA NAVE (n.tipo), nÃ£o pelo slot (idx)
      const shipType = n.tipo;
      let shotType = 'plasma';
      
      
      if (typeof ShotTypeManager !== 'undefined') {
        shotType = ShotTypeManager.getShotType(shipType);
      } else {
        // Fallback: ler do localStorage diretamente usando tipo da nave
        try {
          const prefs = JSON.parse(localStorage.getItem('thor_shot_preferences') || '{}');
          shotType = prefs[String(shipType)] || 'plasma';
        } catch (e) {
          shotType = 'plasma';
        }
      }
      
      projectiles.push({
        id: projectileIdCounter++, // ID Ãºnico
        x: n.x,
        y: n.y,
        prevX: n.x,
        prevY: n.y,
        dx,
        dy,
        target: "cpu",
        shotType: shotType
      });
      
      // Broadcast tiro em modo multiplayer
      if (multiplayerMode) {
        broadcastShot(n.x, n.y, dx, dy);
      }
    }
  });

  cpuNaves.forEach((n, idx) => {
    if (n.shot && n.hp > 0) {
      if (!sfxMuted) sfxShot.play().catch(e => {});
      const end = getEdgePoint({ x: n.x, y: n.y }, n.shot);
      const dist = Math.sqrt((end.x - n.x) ** 2 + (end.y - n.y) ** 2);
      const dx = (end.x - n.x) / dist * PROJECTILE_SPEED;
      const dy = (end.y - n.y) / dist * PROJECTILE_SPEED;
      
      // shotType vem do payload da aÃ§Ã£o (fonte Ãºnica de verdade entre P1 e P2)
      // Fallback para opponentShotPreferences caso payload antigo sem shotType
      let shotType = n.shotType || 'plasma';
      if (!n.shotType && multiplayerMode && opponentShotPreferences) {
        const shipType = n.tipo;
        shotType = opponentShotPreferences[String(shipType)] || 'plasma';
      }
      
      projectiles.push({
        id: projectileIdCounter++, // ID Ãºnico
        x: n.x,
        y: n.y,
        prevX: n.x,
        prevY: n.y,
        dx,
        dy,
        target: "player",
        shotType: shotType
      });
    }
  });
}





/**
 * SWEPT COLLISION DETECTION (Raycast)
 * Testa se o segmento de linha (x1,y1) â†’ (x2,y2) intersecta um cÃ­rculo.
 * Usado para detectar colisÃµes de projÃ©teis que movem rÃ¡pido demais
 * e poderiam "pular" frames atravessando naves sem colidir.
 * 
 * Funcionamento:
 * - Testa a trajetÃ³ria completa do projÃ©til entre frames
 * - Garante que nenhum tiro atravesse uma nave sem registrar hit
 * - Usa equaÃ§Ã£o quadrÃ¡tica para resolver interseÃ§Ã£o linha-cÃ­rculo
 * 
 * @param {number} x1, y1 - PosiÃ§Ã£o anterior do projÃ©til
 * @param {number} x2, y2 - PosiÃ§Ã£o atual do projÃ©til
 * @param {number} cx, cy - Centro da nave (alvo)
 * @param {number} r - Raio de colisÃ£o da nave
 * @returns {boolean} true se hÃ¡ interseÃ§Ã£o
 */
function segmentIntersectsCircle(x1, y1, x2, y2, cx, cy, r) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  const fx = x1 - cx;
  const fy = y1 - cy;

  const a = dx * dx + dy * dy;
  const b = 2 * (fx * dx + fy * dy);
  const c = fx * fx + fy * fy - r * r;
  
  let discriminant = b * b - 4 * a * c;
  
  // Se discriminante < 0, a linha nÃ£o intersecta o cÃ­rculo
  if (discriminant < 0) return false;

  discriminant = Math.sqrt(discriminant);
  const t1 = (-b - discriminant) / (2 * a);
  const t2 = (-b + discriminant) / (2 * a);

  // Se algum t entre 0 e 1, hÃ¡ interseÃ§Ã£o no segmento
  // TambÃ©m verificar se o segmento comeÃ§a ou termina dentro do cÃ­rculo
  if ((t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1)) return true;
  
  // Verificar se o segmento atravessa completamente o cÃ­rculo
  if (t1 < 0 && t2 > 1) return true;
  
  return false;
}


// Substitua toda a funÃ§Ã£o updateProjectiles pelo bloco abaixo
function updateProjectiles() {
  for (let i = projectiles.length - 1; i >= 0; i--) {
    const p = projectiles[i];
    // Salvar posiÃ§Ã£o anterior ANTES de mover
    p.prevX = p.x;
    p.prevY = p.y;
    // Aplicar movimento (delta-time normalised to 60 fps)
    p.x += p.dx * _frameDt;
    p.y += p.dy * _frameDt;
    let hit = false;

    // ðŸ”¥ AAA: AUTHORITATIVE COLLISION DETECTION
    // APENAS P1 (HOST) calcula colisÃµes e envia eventos
    // P2 (CLIENT) recebe eventos de hit via Realtime
    const targets = p.target === "cpu" ? cpuNaves : playerNaves;
    
    // ðŸŽ¯ P1: Calcular colisÃµes e enviar eventos
    if (!multiplayerMode || isPlayer1Host) {
      for (let t of targets) {
        if (t.hp <= 0) continue;
        if (segmentIntersectsCircle(p.prevX, p.prevY, p.x, p.y, t.x, t.y, (NAVY_SIZE * 0.6))) {
          const targetIndex = targets.indexOf(t);
          const oldHp = t.hp;
          
          // Aplicar dano localmente no P1
          t.hp -= 33;
          if (t.hp < 0) t.hp = 0;
          
          
          // Efeitos visuais no P1
          explosions.push({ x: t.x, y: t.y, radius: 1 });
          try {
            playHit();
          } catch (e) {}
          
          if (t.hp <= 0) {
            try {
              if (!sfxMuted) sfxExplode.play().catch(e => {});
            } catch (e) {}
            wrecks.push({ x: t.x, y: t.y });
            const teamColor = (targets === cpuNaves) ? "#ff6600" : "#0ff";
            spawnExplosionParticles(t.x, t.y, teamColor);
            screenShake = 10;
            
            // Atualizar placar no P1
            if (targets === cpuNaves) {
              cpuDestroyed++;
              playerScore += 100;
              roundKills++;
              registerXPEvent('DESTROY_ENEMY_SHIP');
              
              const aliveFriendly = playerNaves.filter(n => n.hp > 0).length;
              if (aliveFriendly === 1) {
                registerXPEvent('CLUTCH_KILL');
              }
            } else {
              playerDestroyed++;
              navesPerdidas++;
              playerScore -= 50;
              roundLosses++;
            }
          } else {
            // Tracking de streak de acertos
            if (targets === cpuNaves) {
              roundHitStreaks[targetIndex] = (roundHitStreaks[targetIndex] || 0) + 1;
              
              if (roundHitStreaks[targetIndex] === 3) {
                registerXPEvent('PRECISION_HIT_STREAK');
                roundHitStreaks[targetIndex] = 0;
              }
            }
          }
          
          // ðŸ“¡ MULTIPLAYER: Enviar evento de hit para P2
          if (multiplayerMode) {
            const hitId = `${p.id}_${targetIndex}_${Date.now()}`;
            sendHitEvent({
              hitId: hitId,
              projectileId: p.id,
              targetTeam: p.target,
              targetIndex: targetIndex,
              damage: 33,
              position: { x: t.x, y: t.y },
              hpAfter: t.hp,
              destroyed: t.hp <= 0
            });
          }
          
          projectiles.splice(i, 1);
          hit = true;
          break;
        }
      }
    } else {
      // ï¿½ï¸ P2: Detectar colisÃµes VISUAIS (sem aplicar dano)
      // Remove projÃ©til e mostra efeitos imediatamente (zero lag)
      // Dano serÃ¡ aplicado quando evento chegar do P1 (authoritative)
      for (let t of targets) {
        if (t.hp <= 0) continue;
        if (segmentIntersectsCircle(p.prevX, p.prevY, p.x, p.y, t.x, t.y, (NAVY_SIZE * 0.6))) {
          const targetIndex = targets.indexOf(t);
          
          // ðŸ”¥ AAA: Efeitos visuais IMEDIATOS (client-side prediction)
          // ExplosÃ£o visual SEMPRE (mesmo se som falhar)
          explosions.push({ x: t.x, y: t.y, radius: 1 });
          
          // Som (com proteÃ§Ã£o contra bloqueio de autoplay)
          try {
            playHit();
          } catch (e) {}
          
          projectiles.splice(i, 1);
          hit = true;
          break;
        }
      }
    }
    // Remove sÃ³ se realmente saiu da tela (borda do canvas!)
    if (!hit && (p.x < 0 || p.x > canvas.width || p.y < 0 || p.y > canvas.height)) {
      projectiles.splice(i, 1);
    }
  }
}




function updateExplosions() {
  for (let i = explosions.length - 1; i >= 0; i--) {
    explosions[i].radius += explosions[i].big ? 2.5 : 1.5;
    if (explosions[i].radius > (explosions[i].big ? 40 : 15)) explosions.splice(i, 1);
  }
}


function updateGame() {
  updateParticles(ctx);
  
  // SincronizaÃ§Ã£o multiplayer - APENAS verificar conexÃ£o
  // A) NÃƒO sincronizar movimento em tempo real
  if (multiplayerMode) {
    checkRemoteConnection();
  }

// --- Tela READY/GO! ---
  if (showReadyGo) {
    // Fade in/out igual ao Round X
    if (readyGoStep === 0) { // READY?
      if (readyGoAlpha < 1) readyGoAlpha += 0.07;
      else readyGoTimer++;
      if (readyGoTimer > 60) { // 1s (60 frames)
        readyGoStep = 1;
        readyGoText = "Go!";
        readyGoTimer = 0;
        readyGoAlpha = 0;
      }
    } else if (readyGoStep === 1) { // GO!
      if (readyGoAlpha < 1) readyGoAlpha += 0.15;
      else readyGoTimer++;
      if (readyGoTimer > 20) { // 0.33s
        readyGoStep = 2;
        readyGoAlpha -= 0.13;
      }
    } else if (readyGoStep === 2) {
      readyGoAlpha -= 0.13;
  if (readyGoAlpha <= 0) {
  readyGoAlpha = 0;
  showReadyGo = false;
  planningTimer = 10;
  lastTime = Date.now();
  phase = "selectMove";
  isInteracting = false; // Resetar interaction lock
  document.getElementById("legendArea").textContent = t('clickShipToMove');
  const hudTop = document.getElementById("hudTop");
  if (hudTop) {
    hudTop.style.visibility = 'visible';
    hudTop.style.opacity = '1';
  }
  
  // Aplicar estado pendente se houver
  if (pendingRemoteState) {
    debug.realtime('[REALTIME] ðŸ“¥ Aplicando estado pendente apÃ³s Ready/Go');
    const pending = pendingRemoteState;
    pendingRemoteState = null;
    applyMatchUpdate(pending, currentPhase, currentTurnNumber, turnUserId, matchData?.turn_deadline_at, matchData?.turn_resolved_at);
  }
}

    }
    return; // Pausa todo o resto enquanto exibe Ready/Go!
  }

  if (winner) return;

  if (phase === "roundText") {
     const hudTop = document.getElementById("hudTop");
     if (hudTop) {
       hudTop.style.visibility = 'hidden';
       hudTop.style.opacity = '0';
     }
    // Fade in/out do texto "Round X"
    if (roundTextFadeIn) {
      roundTextAlpha += 0.05;
      if (roundTextAlpha >= 1) {
        roundTextAlpha = 1;
        roundTextFadeIn = false;
      }
    } else {
      roundTextTimer++;
      if (roundTextTimer > ROUND_TEXT_DISPLAY) {
        roundTextAlpha -= 0.05;
        if (roundTextAlpha <= 0) {
          roundTextAlpha = 0;
          showingRoundText = false;
          resetTurn();
        }
      }
    }
    return;
  }

  if (phase === "wait") {
    // GUARD: Se jogo terminou, nÃ£o processar mais nada
    if (!gameActive || winner) {
      return;
    }
    
    // Log de debugging a cada 60 frames (1 segundo)
    if (typeof window.combatDebugCounter === 'undefined') window.combatDebugCounter = 0;
    window.combatDebugCounter++;
    if (window.combatDebugCounter % 60 === 0) {
    // Status:
    // phase: combatPhase,
    // movementComplete,
    // shootingComplete,
    // projectiles: projectiles.length,
    // explosions: explosions.length
    }
    
    // ðŸ”¥ AAA: COMBATE PARALELO (movimento + tiros simultÃ¢neos)
    if (combatPhase === 'combat') {
      // Processar MOVIMENTO
      playerNaves.forEach(moveTowards);
      cpuNaves.forEach(moveTowards);
      checkNaveCollisions();
      
      // Verificar se movimento terminou
      if (!movementComplete && allShipsFinishedMoving()) {
        movementComplete = true;
      }
      
      // Processar TIROS (em paralelo com movimento)
      updateProjectiles();
      updateExplosions();
      
      // Verificar se tiros terminaram
      if (!shootingComplete && projectiles.length === 0 && explosions.length === 0) {
        shootingComplete = true;
      }
      
      // Round sÃ³ termina quando AMBOS terminarem
      if (movementComplete && shootingComplete) {
        combatPhase = 'cleanup';
      }
    }
    
    // Fase 3: CLEANUP - Finalizar turno
    if (combatPhase === 'cleanup' && movementComplete && shootingComplete) {
      mpPhase = 'ROUND_BANNER'; // canonical state: animation done, banner + sync barrier next
      // âœ… XP: Processar eventos de round
      processRoundXPEvents();
      
      // Sincronizar HP ANTES de verificar vitÃ³ria
      if (multiplayerMode) {
        syncShipsHP();
      }
      
      const gameEnded = checkWinCondition();
      if (gameEnded) {
        // Jogo terminou, nÃ£o avanÃ§ar para prÃ³ximo round
        return;
      }
      
      // ðŸ”¥ AAA: Resetar sistema de fases
      combatPhase = 'idle';
      movementComplete = false;
      shootingComplete = false;
      
      // Resetar targets e shots para prÃ³ximo turno
      playerNaves.forEach(n => {
        n.target = null;
        n.shot = null;
      });
      cpuNaves.forEach(n => {
        n.target = null;
        n.shot = null;
      });
      
      if (!winner) {
        if (multiplayerMode) {
          // AnimaÃ§Ã£o concluÃ­da: parar e ocultar o timer do round anterior imediatamente.
          // startTurnWindow re-ativa o HUD depois que o banner do prÃ³ximo round fechar.
          if (turnTimerInterval) { clearInterval(turnTimerInterval); turnTimerInterval = null; window.__activeTurnTimer = null; }
          if (turnTimer) { clearTimeout(turnTimer); turnTimer = null; }
          if (window.__activeTurnTimer) { clearInterval(window.__activeTurnTimer); window.__activeTurnTimer = null; }
          // Ocultar apenas timerArea; manter hudTop visÃ­vel para legenda aparecer
          const _timerCleanup = document.getElementById('timerArea');
          if (_timerCleanup) { _timerCleanup.style.visibility = 'hidden'; }
          const _hudCleanup = document.getElementById('hudTop');
          if (_hudCleanup) { _hudCleanup.style.visibility = 'visible'; _hudCleanup.style.opacity = '1'; }

          // Legenda de transiÃ§Ã£o entre rounds
          const _legCleanup = document.getElementById('legendArea');
          if (_legCleanup) { _legCleanup.textContent = t('preparingNextRound'); _legCleanup.style.color = '#00D4FF'; }

          // Manter naves bloqueadas atÃ© o banner do prÃ³ximo round fechar
          roundLocked = true;

          phase = "selectMove";
          isInteracting = false;
          myActionSubmitted = false;

          // DB-driven: mesmo fluxo do round 1 â€” deadline do DB via Realtime.
          if (pendingTurnDeadline) {
            const _d = pendingTurnDeadline; pendingTurnDeadline = null;
            startTurnWindow(_d);  // idÃªntico ao round 1
          } else {
            // Realtime ainda nÃ£o trouxe o novo deadline â€” aguardar.
            awaitingRoundReady = true;
            // Fallback: se Realtime nÃ£o chegar em 5s, buscar do DB diretamente
            if (roundReadyTimeout) clearTimeout(roundReadyTimeout);
            roundReadyTimeout = setTimeout(async () => {
              roundReadyTimeout = null;
              if (!awaitingRoundReady) return;
              console.warn('[SYNC] â° Fallback: Realtime nÃ£o chegou, buscando deadline do DB...');
              try {
                const { data: freshRow } = await supabaseClient
                  .from('matches').select('turn_number, turn_deadline_at').eq('id', matchData.id).single();
                if (freshRow && freshRow.turn_deadline_at) {
                  awaitingRoundReady = false;
                  if (freshRow.turn_number) currentTurnNumber = freshRow.turn_number;
                  startTurnWindow(freshRow.turn_deadline_at);
                }
              } catch(e) { console.error('[SYNC] Erro no fallback DB:', e); }
            }, 5000);
          }
          
          // Aplicar estado pendente se houver
          if (pendingRemoteState) {
            debug.realtime('[REALTIME] ðŸ“¥ Aplicando estado pendente apÃ³s fim de turno');
            const pending = pendingRemoteState;
            pendingRemoteState = null;
            applyMatchUpdate(pending, currentPhase, currentTurnNumber, turnUserId, matchData?.turn_deadline_at, matchData?.turn_resolved_at);
          }
        } else {
          // Modo solo: Round text
          phase = "roundText";
          showingRoundText = true;
          roundTextAlpha = 0;
          roundTextFadeIn = true;
          roundTextTimer = 0;
          round++;
        }
      } else {
        resetTurn();
      }
    }
  }

  // Adicione esta parte para permitir planejamento quando nÃ£o estÃ¡ mostrando roundText
  // IMPORTANTE: NÃƒO usar planningTimer no modo multiplayer (use timer do Supabase)
  if ((phase === "selectMove" || phase === "selectShot") && !showingRoundText && !multiplayerMode) {
    const now = Date.now();
    if (now - lastTime >= 1000) {
  planningTimer--;
  lastTime = now;
  if (planningTimer <= 0) {
    phase = "wait";
    selectedNave = null;
    document.getElementById("legendArea").textContent = t('attentionCommander');
    generateCpuOrders();
    
    // ðŸ”¥ AAA: Combate paralelo no modo solo
    combatPhase = 'combat';
    movementComplete = false;
    shootingComplete = false;
    projectileHitRegistry.clear();
    // Modo SOLO: COMBATE iniciado (movimento + tiros simultÃ¢neos)
    
    // Disparar projÃ©teis IMEDIATAMENTE
    fireProjectiles();
  }
}

    // ATUALIZA O TIMER NO HUD:
    const timerSpan = document.getElementById("timerText");
    timerSpan.textContent = planningTimer.toString().padStart(2, "0");
    timerSpan.style.color = (planningTimer > 3) ? "#14ffff" : "#ff4242";
    timerSpan.style.textShadow = (planningTimer > 3) 
      ? "0 0 14px #0ff8"
      : "0 0 18px #ff424299";
  }
}


function resetTurn() {
   cpuDestroyedAntesDoRound = cpuDestroyed; // Salva quantas jÃ¡ estavam destruÃ­das antes deste round
  playerNaves.forEach(n => { n.shot = null; n.target = null; });
  cpuNaves.forEach(n => { n.shot = null; n.target = null; });
  projectiles = [];
  explosions = [];
  selectedNave = null;
  
  // âœ… XP: Resetar tracking de round
  resetRoundXPTracking();

  // 3) Garantir que fleetSlots/fleetLocked nÃ£o sÃ£o resetados por resets/snapshots

if (!winner) {
  // INÃCIO DO READY/GO!
  showReadyGo = true;
  readyGoText = "Ready?";
  readyGoAlpha = 0;
  readyGoStep = 0;
  readyGoTimer = 0;
  phase = "pauseReadyGo"; // nova fase pausa!
}

const timerSpan = document.getElementById("timerText");
timerSpan.textContent = planningTimer.toString().padStart(2, "0");
timerSpan.style.color = "#14ffff";
timerSpan.style.textShadow = "0 0 14px #0ff8";
  const hudTop = document.getElementById("hudTop");
  if (hudTop) {
    hudTop.style.visibility = 'hidden';
    hudTop.style.opacity = '0';
  }



}


function checkWinCondition() {
  // ðŸ›¡ï¸ AAA GUARD: Prevenir mÃºltiplas execuÃ§Ãµes (sÃ³ pode terminar uma vez)
  if (matchEndProcessed) {
    debug.win('[WIN] âš ï¸ matchEndProcessed=true, ignorando checkWinCondition');
    return true; // JÃ¡ processado
  }
  
  if (gameActive === false || phase === 'finished') {
    debug.win('[WIN] âš ï¸ Jogo jÃ¡ terminou, ignorando checkWinCondition');
    return true; // JÃ¡ processado
  }
  
  // Calcular perdas totais (combate + autocolisÃ£o)
  const myLost = getMyLost();
  const oppLost = getOppLost();
  
  debug.win('[WIN] checkWinCondition chamada:');
  debug.win('[WIN]   - myLost:', myLost, '(playerNaves hp:', playerNaves.map(n => n.hp), ')');
  debug.win('[WIN]   - oppLost:', oppLost, '(cpuNaves hp:', cpuNaves.map(n => n.hp), ')');

  // CondiÃ§Ã£o de fim de jogo: 3 naves destruÃ­das de qualquer lado
  if (myLost >= 3 || oppLost >= 3) {
    debug.win('[WIN] ðŸ Jogo terminado! myLost=' + myLost + ', oppLost=' + oppLost);
    
    // ðŸ”’ LOCK IMEDIATO: Prevenir race conditions E MÃšLTIPLAS EXECUÃ‡Ã•ES
    matchEndProcessed = true; // âš ï¸ CRITICAL: Lock antes de qualquer async
    gameActive = false;
    phase = 'finished';

    // ðŸŽ¯ SALVAR PLACAR FINAL IMEDIATAMENTE
    finalScoreSaved = { myLost, oppLost };
    debug.win('[WIN] ðŸ’¾ finalScoreSaved atualizado:', finalScoreSaved);

    // Determinar vencedor baseado em kills
    let localWinner;
    if (oppLost > myLost) {
      localWinner = "VICTORY"; // Eu ganhei
      winner = "VICTORY"; // Correto para a tela
      debug.win('[WIN] ðŸŽ‰ VITÃ“RIA LOCAL (oppLost > myLost)');
      
      // âœ… XP: Processar eventos de vitÃ³ria
      processMatchEndXPEvents('win');
      applyMatchXP();
      
      showVictoryScreen();
    }
    else if (oppLost < myLost) {
      localWinner = "DEFEAT"; // Eu perdi
      winner = "DEFEAT"; // Correto para a tela
      debug.win('[WIN] ðŸ˜¢ DERROTA LOCAL (oppLost < myLost)');
      
      // âœ… XP: Processar eventos de derrota
      debug.win('[WIN] ðŸ” ANTES processMatchEndXPEvents(defeat) - xpTotalMatch:', xpTotalMatch);
      processMatchEndXPEvents('defeat');
      debug.win('[WIN] ðŸ” DEPOIS processMatchEndXPEvents(defeat) - xpTotalMatch:', xpTotalMatch);
      applyMatchXP();
      
      showDefeatScreen();
    }
    else {
      localWinner = "DRAW";
      winner = "Empate!";
      debug.win('[WIN] ðŸ¤ EMPATE LOCAL (oppLost == myLost)');
      
      // âœ… XP: Processar eventos de empate
      processMatchEndXPEvents('draw');
      applyMatchXP();
      
      showDrawScreen();
    }

    document.getElementById('gameCanvas').style.display = "none";
    
    
    // ðŸŽ¯ SALVAR XP FINAL PARA O CHAT
    finalXpForChat = xpTotalMatch;
    
    // ðŸŽ® ARQUITETURA AAA: Authority Pattern
    // Apenas Player1 (host) tem autoridade para processar fim de jogo no servidor
    if (multiplayerMode && supabaseClient && matchData) {
      const isPlayer1 = myUserId === matchData.player1_id;
      
      if (isPlayer1) {
        debug.win('[WIN] ðŸ‘‘ SOU HOST (Player1) - Processando fim de jogo com autoridade');
        // Host processa TUDO: match update + stats de AMBOS jogadores
        updateMatchAsAuthority(localWinner, myLost, oppLost).catch(err => {
          console.error('[WIN] Erro ao processar fim de jogo:', err);
        });
      } else {
        debug.win('[WIN] ðŸ‘¥ SOU CLIENT (Player2) - Aguardando confirmaÃ§Ã£o do host via Realtime');
        // Client apenas atualiza display local, servidor Ã© atualizado pelo host
        // Stats serÃ£o atualizadas pelo host no servidor
      }
    }

    // âš ï¸ NÃƒO enviar mensagem aqui - serÃ¡ enviado pelo botÃ£o "Voltar ao Lobby"
    // Em multiplayer: backToStartMenu() envia THOR:RETURN_TO_CHAT
    // Em modo solo: backToStartMenu() envia THOR:GAME_OVER

    return true; // Indica que o jogo terminou
  }

  return false; // Jogo continua
}

// ðŸŽ® ARQUITETURA AAA: Authority-Based Match Processing
// HOST (Player1) ENVIA dados para API - backend valida e processa
async function updateMatchAsAuthority(localWinner, myLost, oppLost) {
  // ðŸ›¡ï¸ AAA GUARD: VerificaÃ§Ã£o de seguranÃ§a (lock jÃ¡ foi feito no checkWinCondition)
  if (!matchEndProcessed) {
    console.error('[WIN] âŒ ERRO CRÃTICO: updateMatchAsAuthority chamado sem matchEndProcessed=true');
    matchEndProcessed = true; // ForÃ§ar lock
  }
  
  try {
    debug.win('[WIN] ========================================');
    debug.win('[WIN] ðŸ‘‘ HOST enviando resultado para API backend');
    debug.win('[WIN] localWinner:', localWinner);
    debug.win('[WIN] myLost:', myLost, 'oppLost:', oppLost);
    
    // ðŸŽ¯ AAA ARCHITECTURE: Chamar API Route que valida e processa
    // Backend garante seguranÃ§a, validaÃ§Ã£o e atomicidade
    
    // Obter tokens de auth para API
    const { data: sessionData } = await supabaseClient.auth.getSession();
    const accessToken = sessionData?.session?.access_token;
    const refreshToken = sessionData?.session?.refresh_token;
    
    if (!accessToken || !refreshToken) {
      console.error('[WIN] âŒ Tokens de autenticaÃ§Ã£o nÃ£o encontrados');
      return;
    }
    
    debug.win('[WIN] ðŸ“¡ Chamando API /api/finalize-match...');
    
    const response = await fetch('/api/finalize-match', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        matchId: matchData.id,
        myLost: myLost,
        oppLost: oppLost,
        accessToken: accessToken,
        refreshToken: refreshToken
      })
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      console.error('[WIN] âŒ Erro na API:', errorData);
      return;
    }
    
    const result = await response.json();
    debug.win('[WIN] âœ… API respondeu:', result);
    
    if (result.alreadyFinalized) {
      debug.win('[WIN] â­ï¸ Match jÃ¡ foi finalizado anteriormente (idempotente)');
    } else {
      debug.win('[WIN] ðŸŽ‰ Match finalizado com sucesso!');
    }
    
  } catch (err) {
    console.error('[WIN] âŒ ExceÃ§Ã£o ao processar fim de jogo:', err);
  }
}

// âš ï¸ DEPRECATED: Mantida por compatibilidade, mas nÃ£o deve ser mais usada
// Nova arquitetura usa updateMatchAsAuthority (apenas pelo host)
async function updateMatchWinner(localWinner, myLost, oppLost) {
  console.warn('[WIN] âš ï¸ updateMatchWinner DEPRECATED - use updateMatchAsAuthority');
  try {
    debug.win('[WIN] ========================================');
    debug.win('[WIN] Atualizando match com vencedor');
    debug.win('[WIN] localWinner:', localWinner);
    debug.win('[WIN] myTeam:', myTeam);
    debug.win('[WIN] myLost:', myLost, 'oppLost:', oppLost);
    
    // Determinar vencedor global (player1 ou player2)
    let winner_id = null;
    if (localWinner === 'VICTORY') {
      winner_id = myUserId; // Eu ganhei
    } else if (localWinner === 'DEFEAT') {
      winner_id = opponentUserId; // Oponente ganhou
    }
    // Se DRAW, winner_id fica null
    
    debug.win('[WIN] winner_id:', winner_id);
    
    // Atualizar match
    const { error } = await supabaseClient
      .from('matches')
      .update({
        phase: 'finished',
        winner_id: winner_id,
        finished_at: new Date().toISOString()
      })
      .eq('id', matchData.id);
    
    if (error) {
      console.error('[WIN] Erro ao atualizar match:', error);
      return;
    }
    
    debug.win('[WIN] âœ… Match atualizado com vencedor');
    
    // ðŸŽ¯ ATUALIZAR PLAYER STATS (uma Ãºnica vez, no fluxo local)
    if (multiplayerMode && myUserId && supabaseClient) {
      // â›” Prevenir mÃºltiplas atualizaÃ§Ãµes na mesma partida
      const statsLockKey = `stats_updated_${matchData?.id || 'unknown'}`;
      if (!sessionStorage.getItem(statsLockKey)) {
        sessionStorage.setItem(statsLockKey, 'true');
        debug.stats('[STATS] ðŸ”’ Lock criado:', statsLockKey);
        
        const result = localWinner === 'VICTORY' ? 'win' : localWinner === 'DEFEAT' ? 'loss' : 'draw';
        const statsUpdate = {
          matches_played: 1,
          ships_destroyed: Number(oppLost ?? 0),
          ships_lost: Number(myLost ?? 0),
          wins: result === 'win' ? 1 : 0,
          losses: result === 'loss' ? 1 : 0,
          draws: result === 'draw' ? 1 : 0,
        };
        
        try {
          // Buscar stats atuais
          const { data: statsRow } = await supabaseClient
            .from("player_stats")
            .select("matches_played, wins, losses, draws, ships_destroyed, ships_lost")
            .eq("user_id", myUserId)
            .maybeSingle();
          
          if (statsRow) {
            // Atualizar somando os valores
            const updateObj = {
              matches_played: Number(statsRow.matches_played ?? 0) + 1,
              wins: Number(statsRow.wins ?? 0) + statsUpdate.wins,
              losses: Number(statsRow.losses ?? 0) + statsUpdate.losses,
              draws: Number(statsRow.draws ?? 0) + statsUpdate.draws,
              ships_destroyed: Number(statsRow.ships_destroyed ?? 0) + statsUpdate.ships_destroyed,
              ships_lost: Number(statsRow.ships_lost ?? 0) + statsUpdate.ships_lost,
            };
            debug.stats('[STATS] âœ… Atualizando stats:', updateObj);
            await supabaseClient
              .from("player_stats")
              .update(updateObj)
              .eq("user_id", myUserId);
          } else {
            // Inserir novo registro
            debug.stats('[STATS] âœ… Inserindo stats iniciais:', statsUpdate);
            await supabaseClient
              .from("player_stats")
              .insert([{ user_id: myUserId, ...statsUpdate }]);
          }
          debug.win('[WIN] ðŸ“Š Stats atualizados com sucesso');
        } catch (statsErr) {
          console.error('[WIN] Erro ao atualizar stats:', statsErr);
        }
      } else {
        debug.stats('[STATS] â­ï¸ Stats jÃ¡ foram atualizados para este matchId, pulando...');
      }
    }
  } catch (err) {
    console.error('[WIN] ExceÃ§Ã£o ao atualizar vencedor:', err);
  }
}

function fillEndScoreUI(hideDetails = false, hideTotal = false) {
  updateScoreBoard();

  document.querySelectorAll(".score-details").forEach(el => {
    if (hideDetails) {
      el.style.display = 'none';
    } else {
      el.style.display = 'block';
      el.innerHTML = buildScoreDetails();
    }
  });

  // âœ… EXIBIR XP TOTAL (nÃ£o Score)
  document.querySelectorAll(".score-total").forEach(el => {
    if (hideTotal) {
      el.style.display = 'none';
    } else {
      el.style.display = 'block';
      const displayValue = xpTotalMatch === 0 ? '0' : (xpTotalMatch > 0 ? `+${xpTotalMatch}` : `${xpTotalMatch}`);
      // Exibe TOTAL XP normalmente
      el.textContent = `TOTAL XP: ${displayValue}`;
      // Se for modo prÃ¡tica, exibe aviso logo abaixo
      if (!multiplayerMode) {
        // Cria ou seleciona o elemento de aviso
        let warning = el.nextElementSibling;
        if (!warning || !warning.classList.contains('practice-xp-warning')) {
          warning = document.createElement('div');
          warning.className = 'practice-xp-warning';
          warning.style.marginTop = '8px';
          warning.style.fontSize = '15px';
          warning.style.color = '#FFD34F';
          warning.style.textShadow = '0 0 8px #000, 0 0 12px #FFD34F88';
          warning.style.fontFamily = "'Orbitron', sans-serif";
          warning.style.letterSpacing = '1px';
          warning.style.textAlign = 'center';
          el.parentNode.insertBefore(warning, el.nextSibling);
        }
        warning.textContent = `[ PRACTICE ] ` + t('practiceXpWarning');
        warning.style.display = 'block';
      } else {
        // Oculta o aviso se nÃ£o for prÃ¡tica
        let warning = el.nextElementSibling;
        if (warning && warning.classList.contains('practice-xp-warning')) {
          warning.style.display = 'none';
        }
      }
    }
  });

  updateHeaderScore(); // âœ… ADICIONE ESTA LINHA

  // --- HUD vertical fix: always reserve space ---
  const hud = document.getElementById('hudTop');
  if (hud) {
    if (hideDetails && hideTotal) {
      hud.style.visibility = 'hidden';
      hud.style.opacity = '0';
    } else {
      hud.style.display = 'flex';
      hud.style.visibility = 'visible';
      hud.style.opacity = '1';
    }
  }
}


function showVictoryScreen() {
  if (window.resultScreenShown) return;
  window.resultScreenShown = true;
  bgmBattle.pause(); bgmBattle.currentTime = 0; bgmBattle.src = '';
  if (!sfxMuted) { sfxWinner.currentTime = 0; sfxWinner.play().catch(e => {}); }
  if (document.getElementById("modeSelectionScreen").style.display === "flex") return;

  if ((cpuDestroyed - cpuDestroyedAntesDoRound) === 3) {
    playerScore += 200;
    bonusAllAtOnce = true;
  }
  if (playerNaves.every(n => n.hp > 0)) {
    playerScore += 250;
    bonusNoLoss = true;
  }

  showOnly('victoryScreen');
  
  // Atualizar textos traduzidos
  const victoryTextEl = document.getElementById('victoryText');
  const victoryBtnEl = document.getElementById('restartVictory');
  if (victoryTextEl) victoryTextEl.textContent = t('victory');
  if (victoryBtnEl) victoryBtnEl.textContent = t('returnToLobby');
  
  fillEndScoreUI(); // âœ… aqui jÃ¡ vai atualizar o header tambÃ©m
  
  // NÃƒO finalizar match aqui - serÃ¡ feito via THOR:GAME_OVER
  
  // envia o score ao parent uma vez quando a tela de resultado aparece
  try {
    if (!scoreMessageSent && window.parent && window.parent !== window) {
      window.parent.postMessage({ type: "THOR:SCORE_UPDATE", payload: { score: clampScore() } }, window.location.origin);
      scoreMessageSent = true;
    }
  } catch (e) { console.warn('Erro ao enviar THOR:SCORE_UPDATE', e); }
  
}

function showDefeatScreen() {
  if (window.resultScreenShown) return;
  window.resultScreenShown = true;
  bgmBattle.pause(); bgmBattle.currentTime = 0; bgmBattle.src = '';
  if (!sfxMuted) { sfxLoss.currentTime = 0; sfxLoss.play().catch(e => {}); }
  if (document.getElementById("modeSelectionScreen").style.display === "flex") return;

  showOnly('defeatScreen');
  
  // Atualizar textos traduzidos
  const defeatTextEl = document.getElementById('defeatText');
  const defeatBtnEl = document.getElementById('restartDefeat');
  if (defeatTextEl) defeatTextEl.textContent = t('defeat');
  if (defeatBtnEl) defeatBtnEl.textContent = t('returnToLobby');
  
  // âœ… Ocultar score details e total XP na derrota
  fillEndScoreUI(true, true);
  
  // NÃƒO finalizar match aqui - serÃ¡ feito via THOR:GAME_OVER
  
  try {
    if (!scoreMessageSent && window.parent && window.parent !== window) {
      window.parent.postMessage({ type: "THOR:SCORE_UPDATE", payload: { score: clampScore() } }, window.location.origin);
      scoreMessageSent = true;
    }
  } catch (e) { console.warn('Erro ao enviar THOR:SCORE_UPDATE', e); }
}

function showDrawScreen() {
  if (window.resultScreenShown) return;
  window.resultScreenShown = true;
  bgmBattle.pause(); bgmBattle.currentTime = 0; bgmBattle.src = '';
  if (document.getElementById("modeSelectionScreen").style.display === "flex") return;

  showOnly('drawScreen');
  
  // Atualizar textos traduzidos
  const drawTextEl = document.getElementById('drawText');
  const drawBtnEl = document.getElementById('restartDraw');
  if (drawTextEl) drawTextEl.textContent = t('draw');
  if (drawBtnEl) drawBtnEl.textContent = t('returnToLobby');
  
  fillEndScoreUI();
  
  // NÃƒO finalizar match aqui - serÃ¡ feito via THOR:GAME_OVER
  
  try {
    if (!scoreMessageSent && window.parent && window.parent !== window) {
      window.parent.postMessage({ type: "THOR:SCORE_UPDATE", payload: { score: clampScore() } }, window.location.origin);
      scoreMessageSent = true;
    }
  } catch (e) { console.warn('Erro ao enviar THOR:SCORE_UPDATE', e); }
}

/**
 * Finaliza partida multiplayer e envia para o parent processar
 */
function finalizeMultiplayerMatch(result) {
  try {
    const matchSource = localStorage.getItem("thor_match_source");
    const matchId = localStorage.getItem("thor_match_id");
    const opponentName = localStorage.getItem("thor_match_opponent_name");

    // SÃ³ finalizar se for multiplayer
    if (matchSource !== "multiplayer" || !matchId || !opponentName) {
      return;
    }

    const myScore = clampScore();
    // Para bot, simular um score (pode ser 0 ou aleatÃ³rio)
    const opponentScore = Math.floor(Math.random() * myScore * 0.8);

    // Enviar estatÃ­sticas de naves destruÃ­das
    const myKills = cpuDestroyed;       // Naves do oponente que eu destruÃ­ (correto)
    const oppKills = playerDestroyed;   // Minhas naves destruÃ­das (correto)

    // Determinar resultado com base em kills
    let finalResult = result;
    if (myKills > oppKills) {
      finalResult = 'win';
    } else if (myKills < oppKills) {
      finalResult = 'loss';
    } else {
      finalResult = 'draw';
    }

    // Enviar ao parent para processar
    if (window.parent && window.parent !== window) {
      window.parent.postMessage({
        type: "THOR:FINALIZE_MATCH",
        payload: {
          matchId,
          opponentName,
          myScore,
          opponentScore,
          myKills,
          oppKills,
          result: finalResult, // 'win' | 'loss' | 'draw' calculado por kills
        }
      }, window.location.origin);
    }

  } catch (err) {
    console.error("Error requesting match finalization:", err);
  }
}



function restartGame() {
  window._gameLoopStarted = false; 
  // Reseta contadores e status do placar e bÃ´nus
  collisionCpuSolo = 0;
  collisionPlayerSolo = 0;
  navesPerdidas = 0;
  bonusAllAtOnce = false;
  bonusNoLoss = false;
  playerDestroyed = 0;
  cpuDestroyed = 0;
  winner = null;
  gameOverSent = false; // Resetar flag de game over
  gameActive = true; // Reativar o jogo

 // Esconde o canvas do jogo e o HUD superior
  document.getElementById("gameCanvas").style.display = "none";
  document.getElementById("hudTop").style.display = "none";

  // Esconde SVG do contorno do jogo (se quiser)
  document.querySelector("svg").style.visibility = "hidden";
  // Esconde tudo do jogo
  document.getElementById("gameCanvas").style.display = "none";
  document.getElementById("gameContour").style.visibility = "hidden";
  document.getElementById("hudTop").style.display = "none";

  // Mostra apenas a seleÃ§Ã£o de naves
  document.getElementById("naveSelectScreen").style.display = "flex";
  document.getElementById("thorspace-logo").style.display = "none";
  document.getElementById("startContainer").style.display = "none";
  document.getElementById("modeSelectionScreen").style.display = "none";

  // Reseta seleÃ§Ã£o de naves
  window.selectedNaves = [];
  updatePreviews();
  
  // Em multiplayer: resetar flags. O timer SÃ“ inicia quando o jogador clicar
  // "Pronto!" (apÃ³s oponente confirmar presenÃ§a). Nunca comeÃ§a automaticamente.
  if (multiplayerMode) {
    PVP.hasSavedSelection = false;
    opponentInGame = false; // reset â€” serÃ¡ true quando oponente entrar na presenÃ§a
  }

  // Reseta variÃ¡veis de rodada e estado (mantÃ©m os dados prontos para prÃ³xima partida)
  wrecks = [];
  explosions = [];
  projectiles = [];
  selectedNave = null;
  planningTimer = 10;
  lastTime = Date.now();
  round = 1;
  phase = "roundText";
  showingRoundText = true;
  roundTextAlpha = 0;
  roundTextFadeIn = true;
  roundTextTimer = 0;
}



function showVictoryModal() {
  const victoryTitle = document.getElementById("victoryTitle");
  if (winner === "VICTORY") {
    victoryTitle.textContent = playerName + " " + t('won');
  } else {
    victoryTitle.textContent = winner;
  }
  document.getElementById("victoryModal").style.display = "flex";
  document.getElementById("gameCanvas").style.pointerEvents = "none";
}

function hideVictoryModal() {
  document.getElementById("victoryModal").style.display = "none";
  document.getElementById("gameCanvas").style.pointerEvents = "auto";
}

function getCenter(naves) {
  const vivos = naves.filter(n => n.hp > 0);
  if (vivos.length === 0) return { x: 400, y: 300 };
  const x = vivos.reduce((sum, n) => sum + n.x, 0) / vivos.length;
  const y = vivos.reduce((sum, n) => sum + n.y, 0) / vivos.length;
  return { x, y };
}

let MAX_MOVEMENT_RADIUS = 300;


function drawGame() {
  applyScreenShake();
ctx.save();
ctx.translate(shakeX, shakeY);

  // Limpar e desenhar fundo preto como fallback
  ctx.fillStyle = '#111';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  drawParticles(ctx);

  // Fundo galÃ¡xia
  if (backgroundGalaxy.complete) {
    ctx.drawImage(backgroundGalaxy, 0, 0, canvas.width, canvas.height);
  }

  // Desenhar destroÃ§os (wrecks) ANTES das naves para ficarem atrÃ¡s
  wrecks.forEach(w => {
    ctx.strokeStyle = "#999";
    ctx.beginPath();
    ctx.moveTo(w.x - 10, w.y - 10);
    ctx.lineTo(w.x + 10, w.y + 10);
    ctx.moveTo(w.x + 10, w.y - 10);
    ctx.lineTo(w.x - 10, w.y + 10);
    ctx.stroke();
  });

  // --- DESENHA APENAS NAVES VIVAS ---
  playerNaves.forEach(n => {
    if (n.hp > 0) drawNave(n, spritePlayer, false);
  });
  cpuNaves.forEach(n => {
    if (n.hp > 0) drawNave(n, n.sprite, true);
  });

  // Efeitos visuais para nave selecionada
  if (selectedNave !== null && selectedNave.hp > 0) {
    const nave = selectedNave; // selectedNave jÃ¡ Ã© o objeto da nave
    
    // Verificar se o mouse estÃ¡ dentro do alcance da nave
    const distanceToMouse = Math.hypot(mouseX - nave.x, mouseY - nave.y);
    const withinRange = distanceToMouse <= nave.alcance;
    
      if (!nave.target) {
        ctx.beginPath();
        ctx.arc(nave.x, nave.y, nave.alcance, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(0,255,255,0.07)";
        ctx.fill();
        ctx.strokeStyle = "#0ff";
        ctx.setLineDash([4, 4]);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      ctx.beginPath();
      ctx.moveTo(nave.x, nave.y);
      ctx.lineTo(mouseX, mouseY);
      // Cinza transparente se fora de alcance, ciano se dentro
      ctx.strokeStyle = nave.target ? "rgba(150,150,150,0.35)" : (withinRange ? "#0ff" : "rgba(150,150,150,0.35)");
      ctx.setLineDash([4, 4]);
      ctx.stroke();
      ctx.setLineDash([]);

// Se for fase de movimento: dois cÃ­rculos concÃªntricos (solo ou multiplayer)
if (phase === "selectMove" || (phase === "select" && !nave.target)) {
    ctx.save();
    
    // Cinza transparente se fora de alcance, ciano se dentro
    const targetColor = withinRange ? "#0ff" : "rgba(150,150,150,0.45)";
    const targetFillOpacity = withinRange ? 0.13 : 0.05;
    
    // CÃ­rculo externo
    ctx.beginPath();
    ctx.arc(mouseX, mouseY, 14, 0, Math.PI * 2);
    ctx.fillStyle = withinRange ? "rgba(0,255,255,0.13)" : "rgba(150,150,150,0.07)";
    ctx.fill();
    ctx.strokeStyle = targetColor;
    ctx.lineWidth = 2;
    ctx.stroke();

    // CÃ­rculo interno
    ctx.beginPath();
    ctx.arc(mouseX, mouseY, 7, 0, Math.PI * 2);
    ctx.strokeStyle = targetColor;
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Se fora de alcance, X cinza apagado (sem destaque agressivo)
    if (!withinRange) {
      ctx.strokeStyle = "rgba(150,150,150,0.45)";
      ctx.lineWidth = 2;
      // Diagonal 1
      ctx.beginPath();
      ctx.moveTo(mouseX - 5, mouseY - 5);
      ctx.lineTo(mouseX + 5, mouseY + 5);
      ctx.stroke();
      // Diagonal 2
      ctx.beginPath();
      ctx.moveTo(mouseX + 5, mouseY - 5);
      ctx.lineTo(mouseX - 5, mouseY + 5);
      ctx.stroke();
    }
    ctx.restore();
}

// Se for fase de tiro: alvo de mira estilizado (solo ou multiplayer com target jÃ¡ definido)
if (phase === "selectShot" || (phase === "select" && nave.target)) {
    ctx.save();
    // CÃ­rculo externo
    ctx.beginPath();
    ctx.arc(mouseX, mouseY, 18, 0, Math.PI * 2);
    ctx.strokeStyle = "#f00";
    ctx.lineWidth = 3;
    ctx.stroke();

    // CÃ­rculo interno
    ctx.beginPath();
    ctx.arc(mouseX, mouseY, 7, 0, Math.PI * 2);
    ctx.strokeStyle = "#f00";
    ctx.lineWidth = 2;
    ctx.stroke();

    // Desenhar o alvo (crosshair)
    ctx.strokeStyle = "#f00";
    ctx.lineWidth = 2;
    // Linha vertical
    ctx.beginPath();
    ctx.moveTo(mouseX, mouseY - 10);
    ctx.lineTo(mouseX, mouseY + 10);
    ctx.stroke();
    // Linha horizontal
    ctx.beginPath();
    ctx.moveTo(mouseX - 10, mouseY);
    ctx.lineTo(mouseX + 10, mouseY);
    ctx.stroke();
    ctx.restore();
}
  }

  ctx.fillStyle = "#fff";
projectiles.forEach(p => {
  ctx.save();
  
  // Team colors baseado em myTeam
  // IMPORTANTE: target indica PARA ONDE o tiro vai, nÃ£o de quem veio
  // - target: "cpu" = tiros de playerNaves (MEUS tiros)
  // - target: "player" = tiros de cpuNaves (tiros do OPONENTE)
  let teamColor;
  if (!multiplayerMode || myTeam === 'blue') {
    // Solo ou P1 (azul): tiros do jogador (target: "cpu") = azul, tiros da CPU/P2 (target: "player") = vermelho
    teamColor = p.target === "cpu" ? "#0ff" : "#ff3a34";
  } else {
    // P2 (vermelho): meus tiros (target: "cpu") = vermelho, tiros do P1 (target: "player") = azul
    teamColor = p.target === "cpu" ? "#ff3a34" : "#0ff";
  }
  
  // Shot type config
  const shotType = p.shotType || 'plasma';
  const shotConfig = SHOT_TYPES[shotType];
  const accentColor = shotConfig.accentColor || teamColor;
  
  // Parse RGB do team color e accent color para mixing
  const isBlueShot = !multiplayerMode ? p.target === "cpu" : (myTeam === 'blue' && p.target === "cpu") || (myTeam === 'red' && p.target === "player");
  const teamRGB = isBlueShot ? [0, 255, 255] : [255, 58, 52];
  
  let accentRGB;
  if (accentColor === teamColor || !accentColor) {
    accentRGB = teamRGB; // Plasma usa team color
  } else if (shotType === 'pulse') {
    accentRGB = [255, 136, 0]; // Laranja vibrante
  } else if (shotType === 'energy') {
    accentRGB = [217, 70, 239]; // Roxo
  } else {
    accentRGB = teamRGB;
  }
  
  // Mix: 50% team color + 50% accent na cauda (mais visÃ­vel)
  const mixRGB = [
    Math.round(teamRGB[0] * 0.5 + accentRGB[0] * 0.5),
    Math.round(teamRGB[1] * 0.5 + accentRGB[1] * 0.5),
    Math.round(teamRGB[2] * 0.5 + accentRGB[2] * 0.5)
  ];
  
  const tailColor = `rgba(${mixRGB[0]}, ${mixRGB[1]}, ${mixRGB[2]}, 0.02)`;
  const gradColor1 = `rgba(${mixRGB[0]}, ${mixRGB[1]}, ${mixRGB[2]}, 0.25)`;
  const gradColor2 = `rgba(${teamRGB[0]}, ${teamRGB[1]}, ${teamRGB[2]}, 1)`; // Centro sempre team color puro
  
  // Cauda com gradiente (accent nas pontas â†’ team color no centro)
  let grad = ctx.createLinearGradient(
    p.x - p.dx * shotConfig.tailLength, p.y - p.dy * shotConfig.tailLength,
    p.x, p.y
  );
  grad.addColorStop(0, tailColor);    // Ponta: quase transparente
  grad.addColorStop(0.4, gradColor1); // Meio: suave
  grad.addColorStop(1, gradColor2);   // Centro: sÃ³lido
  
  ctx.strokeStyle = grad;
  ctx.shadowColor = accentColor; // Glow usa accent color
  ctx.shadowBlur = 8;
  ctx.lineWidth = 4;
  
  // Efeitos especiais por tipo
  let t = performance.now();
  let sway = Math.sin(t / 140 + p.x * 0.1 + p.y * 0.03) * 1.3;
  
  // PULSE: AnimaÃ§Ã£o pulsante com raio e partÃ­culas
  if (shotType === 'pulse') {
    const pulsePhase = (t % shotConfig.pulseSpeed) / shotConfig.pulseSpeed;
    const pulseScale = 1 + Math.sin(pulsePhase * Math.PI * 2) * 0.15; // Muito sutil
    ctx.lineWidth = 3 * pulseScale;
    
    // SEM shadowBlur - modo performance mÃ¡ximo
    ctx.shadowBlur = 0;
    
    // Pre-calcular perpendiculares (evita Math.sqrt repetido)
    const magnitude = Math.sqrt(p.dx * p.dx + p.dy * p.dy) || 1;
    const perpX = -p.dy / magnitude;
    const perpY = p.dx / magnitude;
    
    // AAA: Usar batch rendering - uma Ãºnica passada
    ctx.beginPath();
    for (let i = 0; i < shotConfig.particleCount; i++) {
      const offset = (i / shotConfig.particleCount) * shotConfig.tailLength;
      const particleX = p.x - p.dx * offset;
      const particleY = p.y - p.dy * offset;
      
      // Movimento errÃ¡tico tipo raio (pre-calculado)
      const zigzag = Math.sin(t / 60 + i * 1.5) * 3; // Reduzido de 4
      
      // PartÃ­cula brilhante
      ctx.moveTo(particleX + perpX * zigzag + 2, particleY + perpY * zigzag);
      ctx.arc(
        particleX + perpX * zigzag, 
        particleY + perpY * zigzag, 
        1.5 + Math.sin(t / 100 + i) * 0.8, // Reduzido
        0, 
        Math.PI * 2
      );
    }
    ctx.fillStyle = `rgba(${accentRGB[0]}, ${accentRGB[1]}, ${accentRGB[2]}, 0.7)`;
    ctx.fill();
  }
  
  // ENERGY: Sparks laterais elÃ©tricos
  if (shotType === 'energy') {
    ctx.shadowBlur = 0; // Performance: sem glow
    
    for (let i = 0; i < shotConfig.sparkCount; i++) {
      const offset = (i / shotConfig.sparkCount) * shotConfig.tailLength;
      const sparkX = p.x - p.dx * offset;
      const sparkY = p.y - p.dy * offset;
      const sparkSway = Math.sin(t / 80 + i * 2) * 5;
      const sparkSize = 6 + Math.sin(t / 100 + i) * 2;
      
      // Spark 1 (lado direito perpendicular)
      ctx.beginPath();
      ctx.moveTo(sparkX, sparkY);
      ctx.lineTo(sparkX + sparkSway, sparkY - sparkSway);
      ctx.strokeStyle = accentColor;
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.7;
      ctx.stroke();
      
      // Spark 2 (lado esquerdo perpendicular)
      ctx.beginPath();
      ctx.moveTo(sparkX, sparkY);
      ctx.lineTo(sparkX - sparkSway, sparkY + sparkSway);
      ctx.strokeStyle = accentColor;
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.6;
      ctx.stroke();
      
      // Ponto brilhante no spark
      ctx.beginPath();
      ctx.arc(sparkX + sparkSway, sparkY - sparkSway, 2, 0, Math.PI * 2);
      ctx.fillStyle = accentColor;
      ctx.globalAlpha = 0.8;
      ctx.fill();
      
      ctx.globalAlpha = 1;
    }
  }
  
  // Cauda principal
  ctx.beginPath();
  ctx.moveTo(p.x - p.dx * shotConfig.tailLength + sway, p.y - p.dy * shotConfig.tailLength - sway);
  ctx.lineTo(p.x, p.y);
  
  // Para Energy e Pulse, aplicar gradiente com fade na cauda
  if (shotType === 'energy' || shotType === 'pulse') {
    const tailGrad = ctx.createLinearGradient(
      p.x - p.dx * shotConfig.tailLength,
      p.y - p.dy * shotConfig.tailLength,
      p.x,
      p.y
    );
    tailGrad.addColorStop(0, `rgba(${mixRGB[0]}, ${mixRGB[1]}, ${mixRGB[2]}, 0)`);
    tailGrad.addColorStop(0.3, `rgba(${mixRGB[0]}, ${mixRGB[1]}, ${mixRGB[2]}, 0.15)`);
    tailGrad.addColorStop(0.7, `rgba(${mixRGB[0]}, ${mixRGB[1]}, ${mixRGB[2]}, 0.25)`);
    tailGrad.addColorStop(1, `rgba(${teamRGB[0]}, ${teamRGB[1]}, ${teamRGB[2]}, 1)`);
    ctx.strokeStyle = tailGrad;
    ctx.lineWidth = 2;
  }
  
  ctx.stroke();
  
  // NÃºcleo com camada de accent color ao redor
  ctx.shadowBlur = shotConfig.glowSize;
  ctx.shadowColor = teamColor;
  
  // Camada externa (accent color) para pulse e energy
  if (shotType !== 'plasma') {
    // ENERGY e PULSE: Formato de estrela cadente/gota
    if (shotType === 'energy' || shotType === 'pulse') {
      ctx.save();
      
      // Rotacionar para alinhar com direÃ§Ã£o do tiro
      const angle = Math.atan2(p.dy, p.dx);
      ctx.translate(p.x, p.y);
      ctx.rotate(angle);
      
      const headWidth = 8;      // Largura mÃ¡xima da cabeÃ§a
      const headLength = 15;    // Comprimento da cabeÃ§a (alongada)
      const tailLength = 35;    // Comprimento da cauda apÃ³s a cabeÃ§a (bem maior)
      const totalLength = headLength + tailLength;
      
      // Gradiente com fade suave no final
      const dropGrad = ctx.createLinearGradient(headLength, 0, -tailLength, 0);
      dropGrad.addColorStop(0, `rgba(${accentRGB[0]}, ${accentRGB[1]}, ${accentRGB[2]}, 0.95)`);
      dropGrad.addColorStop(0.2, `rgba(${accentRGB[0]}, ${accentRGB[1]}, ${accentRGB[2]}, 0.8)`);
      dropGrad.addColorStop(0.4, `rgba(${accentRGB[0]}, ${accentRGB[1]}, ${accentRGB[2]}, 0.55)`);
      dropGrad.addColorStop(0.7, `rgba(${accentRGB[0]}, ${accentRGB[1]}, ${accentRGB[2]}, 0.25)`);
      dropGrad.addColorStop(0.9, `rgba(${accentRGB[0]}, ${accentRGB[1]}, ${accentRGB[2]}, 0.08)`);
      dropGrad.addColorStop(1, `rgba(${accentRGB[0]}, ${accentRGB[1]}, ${accentRGB[2]}, 0)`);
      
      // Desenhar gota como forma Ãºnica suave
      ctx.beginPath();
      
      // ComeÃ§ar na frente da cabeÃ§a (ponta direita)
      ctx.moveTo(headLength, 0);
      
      // Curva superior da cabeÃ§a (parte redonda/alongada)
      ctx.bezierCurveTo(
        headLength, headWidth * 0.7,        // Controle 1: curva suave no topo
        headLength * 0.5, headWidth,        // Controle 2: ponto mais largo
        0, headWidth                         // Fim: meio da largura mÃ¡xima
      );
      
      // Curva superior afunilando para a cauda
      ctx.bezierCurveTo(
        -totalLength * 0.2, headWidth * 0.75, // Controle 1: comeÃ§a a afunilar
        -totalLength * 0.5, headWidth * 0.35, // Controle 2: metade da espessura
        -totalLength * 0.8, headWidth * 0.12  // Controle 3: quase fino
      );
      
      // Ponta final da cauda (muito fina)
      ctx.lineTo(-tailLength, 0);
      
      // Curva inferior da cauda (espelhada)
      ctx.bezierCurveTo(
        -totalLength * 0.8, -headWidth * 0.12, // Controle 1: quase fino
        -totalLength * 0.5, -headWidth * 0.35, // Controle 2: metade da espessura
        -totalLength * 0.2, -headWidth * 0.75  // Controle 3: comeÃ§a a engrossar
      );
      
      // Curva inferior da cabeÃ§a
      ctx.bezierCurveTo(
        0, -headWidth,                       // Controle 1: meio da largura mÃ¡xima
        headLength * 0.5, -headWidth,       // Controle 2: ponto mais largo
        headLength, -headWidth * 0.7        // Controle 3: curva suave embaixo
      );
      
      // Fecha na frente da cabeÃ§a
      ctx.lineTo(headLength, 0);
      ctx.closePath();
      
      ctx.fillStyle = dropGrad;
      ctx.shadowBlur = 18;
      ctx.shadowColor = `rgba(${accentRGB[0]}, ${accentRGB[1]}, ${accentRGB[2]}, 0.7)`;
      ctx.fill();
      
      // Brilho extra na cabeÃ§a alongada
      const glowGrad = ctx.createRadialGradient(headLength * 0.5, 0, 0, headLength * 0.5, 0, headWidth * 1.5);
      glowGrad.addColorStop(0, `rgba(${accentRGB[0]}, ${accentRGB[1]}, ${accentRGB[2]}, 0.8)`);
      glowGrad.addColorStop(0.4, `rgba(${accentRGB[0]}, ${accentRGB[1]}, ${accentRGB[2]}, 0.4)`);
      glowGrad.addColorStop(1, `rgba(${accentRGB[0]}, ${accentRGB[1]}, ${accentRGB[2]}, 0)`);
      
      ctx.beginPath();
      ctx.ellipse(headLength * 0.5, 0, headLength * 0.7, headWidth * 1.2, 0, 0, Math.PI * 2);
      ctx.fillStyle = glowGrad;
      ctx.fill();
      
      ctx.restore();
    }
  }
  
  // Centro (team color puro) - menor para pulse/energy
  ctx.beginPath();
  ctx.arc(p.x, p.y, shotType === 'plasma' ? 4 : 2.5, 0, Math.PI * 2);
  ctx.fillStyle = teamColor;
  ctx.globalAlpha = shotConfig.glowIntensity;
  ctx.fill();
  
  ctx.restore();
});



 explosions.forEach(e => {
  // Flash branco inicial
  if (e.flash && e.flash > 0) {
    ctx.save();
    ctx.globalAlpha = e.flash / 8;
    ctx.beginPath();
    ctx.arc(e.x, e.y, (e.big ? 50 : 18) + 12 * e.flash, 0, Math.PI * 2);
    ctx.fillStyle = "#fff";
    ctx.fill();
    ctx.restore();
    e.flash--;
  }
  // ExplosÃ£o principal (amarela/laranja maior)
  ctx.save();
  ctx.beginPath();
  ctx.arc(e.x, e.y, e.big ? e.radius * 2 : e.radius, 0, Math.PI * 2);
  ctx.fillStyle = e.big ? "orange" : "orange";
  ctx.globalAlpha = 0.9;
  ctx.fill();
  ctx.restore();
});


if (winner) {
    ctx.save();
    ctx.font = "bold 60px Orbitron, sans-serif";
    ctx.textAlign = "center";
    ctx.fillStyle = "#fff";
    ctx.strokeStyle = "#0ff";
    ctx.lineWidth = 4;
    ctx.strokeText(winner, canvas.width / 2, canvas.height / 2);
    ctx.fillText(winner, canvas.width / 2, canvas.height / 2);
    ctx.restore();
}
function drawFuturisticTimerIcon(ctx, x, y, color="#14ffff") {
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = 3.5;
  ctx.shadowColor = color;
  ctx.shadowBlur = 16;

  // Corpo do timer (um cÃ­rculo com traÃ§o no topo)
  ctx.beginPath();
  ctx.arc(x, y, 17, 0.35*Math.PI, 1.65*Math.PI, false); // arco inferior
  ctx.stroke();

  ctx.beginPath();
  ctx.arc(x, y, 17, 1.75*Math.PI, 0.25*Math.PI, false); // arco superior
  ctx.stroke();

  // TraÃ§o centralizado no topo (como se fosse um relÃ³gio digital)
  ctx.beginPath();
  ctx.moveTo(x, y-17);
  ctx.lineTo(x, y-9);
  ctx.stroke();

  // Linhas laterais, para look mais digital
  ctx.beginPath();
  ctx.moveTo(x-10, y+14);
  ctx.lineTo(x-6, y+6);
  ctx.moveTo(x+10, y+14);
  ctx.lineTo(x+6, y+6);
  ctx.stroke();

  // Circulo central (ponteiro digital)
  ctx.beginPath();
  ctx.arc(x, y, 4, 0, 2*Math.PI);
  ctx.fillStyle = color;
  ctx.globalAlpha = 0.7;
  ctx.fill();

  ctx.shadowBlur = 0;
  ctx.restore();
}


  // --- Round X texto por cima de tudo, com fade ---
  if (showingRoundText) {
    ctx.save();
    ctx.globalAlpha = roundTextAlpha;
    ctx.font = "bold 60px Orbitron, sans-serif";
    ctx.textAlign = "center";
    ctx.fillStyle = "#fff";
    ctx.strokeStyle = "#0ff";
    ctx.lineWidth = 4;
    ctx.strokeText("Round " + round, canvas.width/2, canvas.height/2);
    ctx.fillText("Round " + round, canvas.width/2, canvas.height/2);
    ctx.globalAlpha = 1.0;
    ctx.restore();
  }
   // --- Ready?/Go! texto central com fade ---
  if (showReadyGo) {
    ctx.save();
    ctx.globalAlpha = readyGoAlpha;
    ctx.font = "bold 60px Orbitron, sans-serif";
    ctx.textAlign = "center";
    ctx.fillStyle = "#fff";
    ctx.strokeStyle = "#0ff";
    ctx.lineWidth = 4;
    ctx.strokeText(readyGoText, canvas.width / 2, canvas.height / 2);
    ctx.fillText(readyGoText, canvas.width / 2, canvas.height / 2);
    ctx.globalAlpha = 1.0;
    ctx.restore();
  }
  ctx.restore();

  // Atualiza partÃ­culas
for (let i = particles.length - 1; i >= 0; i--) {
  let p = particles[i];
  p.x += p.dx;
  p.y += p.dy;
  p.dx *= 0.98; // desaceleraÃ§Ã£o leve
  p.dy *= 0.98;
  p.life--;
  if (p.life < 0) particles.splice(i, 1);
}

// Desenha partÃ­culas
particles.forEach(p => {
  ctx.save();
  ctx.globalAlpha = Math.max(0, p.life / p.maxLife);
  ctx.fillStyle = p.color;
  ctx.beginPath();
  ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
  ctx.shadowColor = p.color;
  ctx.shadowBlur = 16;
  ctx.fill();
  ctx.restore();
});


}

function drawMinimalistTimerIcon(ctx, x, y, radius, color, timer) {
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = 3.5;
  ctx.shadowColor = color;
  ctx.shadowBlur = 14;

  // CÃ­rculo externo
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, 2 * Math.PI);
  ctx.stroke();

  // Bolinha central
  ctx.beginPath();
  ctx.arc(x, y, 4, 0, 2 * Math.PI);
  ctx.fillStyle = color;
  ctx.globalAlpha = 0.8;
  ctx.fill();

  ctx.globalAlpha = 1;

  // Ponteiro giratÃ³rio (gira conforme o tempo)
  // Rotaciona em funÃ§Ã£o dos segundos restantes (quanto menor, mais adiantado)
const angle = (-Math.PI / 2) - (2 * Math.PI * ((timer % 10) / 10)); // gira horÃ¡rio

  const pointerLength = radius - 4;
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(x + pointerLength * Math.cos(angle), y + pointerLength * Math.sin(angle));
  ctx.strokeStyle = color;
  ctx.lineWidth = 2.4;
  ctx.shadowBlur = 18;
  ctx.stroke();

  ctx.restore();
}

// ðŸŽ¯ AAA: InterpolaÃ§Ã£o linear para movimento suave (anti-jitter)
function lerp(start, end, factor) {
  return start + (end - start) * factor;
}

let selectPulseTime = 0;
// Delta-time for frame-rate independent animations (normalised to 60 fps).
let _frameDt = 1.0;
let _lastFrameMs = 0;

function gameLoop(now) {
  if (!gameActive) {
    window._gameLoopActive = false; // mark loop as stopped so it can restart next session
    _lastFrameMs = 0;
    return;
  }
  // Compute dt: clamp between 0.5 and 2.0 so spiral-death on tab-wake is prevented.
  _frameDt = (_lastFrameMs > 0) ? Math.min(Math.max((now - _lastFrameMs) / (1000 / 60), 0.5), 2.0) : 1.0;
  _lastFrameMs = now;
  selectPulseTime += 0.07 * _frameDt; // quanto menor, mais lento o pulso
  
  // ðŸ”¥ AAA: Processar fila de eventos no P2
  if (multiplayerMode && !isPlayer1Host) {
    processEventQueue();
    // ðŸŽ¯ PHASE 3: Dead Reckoning para movimento suave
    applyDeadReckoning();
  }
  
  // Lerp de posiÃ§Ã£o removido: nenhum broadcast de posiÃ§Ã£o ocorre durante planejamento.
  // PosiÃ§Ãµes canÃ´nicas chegam via applyResolvedTurn (payload do turno resolvido).
  // Resultado: sem ghost, sem drift, sem jitter â€” animaÃ§Ã£o 100% determinÃ­stica.
  
  // ðŸ“¸ AAA PHASE 2: P1 envia snapshots periÃ³dicos
  if (multiplayerMode && isPlayer1Host) {
    const now = Date.now();
    if (now - lastSnapshotTime >= SNAPSHOT_INTERVAL_MS) {
      sendSnapshot();
    }
  }
  
  updateGame();
  drawGame();
  requestAnimationFrame(gameLoop);
}



let spritesLoaded = 0;
let canStartGame = false;

function tryStartGame() {
  spritesLoaded++;
  if (spritesLoaded === 2 && canStartGame) {
    gameLoop();
  }
}

spritePlayer.onload = tryStartGame;
spriteCPU.onload = tryStartGame;

setTimeout(() => {
  if (spritesLoaded < 2 && canStartGame) {
    console.warn("â³ Sprites nÃ£o carregadas a tempo, iniciando mesmo assim.");
    gameLoop();
  }
}, 1200);




var playerName = "Jogador";
// evita envio duplicado do score ao parent
var scoreMessageSent = false;


function updateScoreBoard() {
  const player = (typeof playerName === 'string' && playerName.length > 0) ? playerName : "Jogador";
  let opponent = localStorage.getItem("thor_match_opponent_name") || "CPU";
  
  // Em modo PVP, usar o nome do oponente real
  if (multiplayerMode && opponentUsername) {
    opponent = opponentUsername;
  }
  
  document.querySelectorAll('.score-board').forEach(sb => {
    // Se for PVP, mostrar com cores dos times
    if (multiplayerMode) {
      const myColor = myTeam === 'blue' ? '#00d4ff' : '#ff4444';
      const oppColor = myTeam === 'blue' ? '#ff4444' : '#00d4ff';
      const myKills = getOppLost();
      const myDeaths = getMyLost();
      sb.innerHTML = `<span style="color: ${myColor};">${player}</span> ${myKills} x ${myDeaths} <span style="color: ${oppColor};">${opponent}</span>`;
    } else {
      sb.innerHTML = `${player} ${cpuDestroyed} x ${playerDestroyed} ${opponent}`;
    }
  });
}

function updateHeaderScore() {
  // Se estamos em iframe, nÃ£o fazer nada aqui (header Ã© do Next.js)
  if (window.self !== window.top) return;
  const el = document.getElementById("userHeaderPts");
  if (!el) return;
  el.textContent = `${clampScore()}pts`;
  // sincroniza com o header centralizado
  try { createOrUpdateHeader(playerName, playerScore); } catch (e) { /* silent */ }
}
  
// Faz o update centralizado do header quando o score muda
function refreshHeaderFromState() {
  // Se estamos em iframe, nÃ£o fazer nada aqui
  if (window.self !== window.top) return;
  createOrUpdateHeader(playerName, playerScore);
}

// Cria ou atualiza o header Ãºnico usado pelo jogo (nome, score, logout)
function createOrUpdateHeader(name, score) {
  // se estamos embedados em um iframe, nÃ£o criar/mostrar o header antigo
  // SEMPRE retornar quando em iframe, pois o header vem do Next.js
  if (window.self !== window.top) return;
  let header = document.getElementById('userHeader');
  if (!header) {
    header = document.createElement('div');
    header.id = 'userHeader';
    header.className = 'user-header';
    header.style.position = 'fixed';
    header.style.top = '20px';
    header.style.right = '12px';
    header.style.zIndex = 9000;
    header.style.display = 'flex';
    header.style.alignItems = 'center';
    header.style.gap = '13px';

    const img = document.createElement('img');
    img.src = 'images/nave_normal.png';
    img.className = 'user-header-ship';
    img.alt = 'Nave';
    header.appendChild(img);

    const nameSpan = document.createElement('span');
    nameSpan.id = 'userHeaderName';
    nameSpan.className = 'user-header-name';
    header.appendChild(nameSpan);

    const ptsSpan = document.createElement('span');
    ptsSpan.id = 'userHeaderPts';
    ptsSpan.className = 'user-header-pts';
    header.appendChild(ptsSpan);

    const btn = document.createElement('button');
    btn.id = 'userLogoutBtn';
    btn.className = 'user-logout-btn';
    btn.textContent = t('logout');
    header.appendChild(btn);

    document.body.appendChild(header);
  }

  const nameEl = document.getElementById('userHeaderName');
  const ptsEl = document.getElementById('userHeaderPts');
  if (nameEl) nameEl.textContent = name || '';
  if (ptsEl) ptsEl.textContent = `${clampScore(typeof score === 'undefined' ? undefined : score)}pts`;

  // garante que o header seja visÃ­vel apÃ³s qualquer atualizaÃ§Ã£o
  try { header.style.display = 'flex'; } catch (e) { /* silent */ }

  // garante que exista apenas um header (remove duplicados acidentais)
  const headers = document.querySelectorAll('#userHeader');
  if (headers.length > 1) {
    headers.forEach((h, idx) => { if (idx > 0) h.remove(); });
  }

  // attach logout to send postMessage to parent (non-destructive)
  const logoutBtn = document.getElementById('userLogoutBtn');
  if (logoutBtn && !logoutBtn._bound) {
    logoutBtn.addEventListener('click', () => {
      try {
        if (window.parent && window.parent !== window) {
          window.parent.postMessage({ type: 'THOR:LOGOUT' }, window.location.origin);
        }
      } catch (e) {
        console.warn('Erro ao enviar THOR:LOGOUT', e);
      }
    });
    logoutBtn._bound = true;
  }
}

function showHeader() {
  // Se estamos em iframe, nÃ£o fazer nada aqui
  if (window.self !== window.top) return;
  const h = document.getElementById('userHeader');
  if (h) h.style.display = 'flex';
}

function setHeaderVisible(visible) {
  // Se estamos em iframe, nÃ£o fazer nada aqui
  if (window.self !== window.top) return;
  const h = document.getElementById('userHeader');
  if (!h) return;
  h.style.display = visible ? 'flex' : 'none';
}



const naveSources = {
  1: "images/nave_alcance.png",
  2: "images/nave_protecao.png",
  3: "images/spaceschip.png",
  4: "images/nave_alcance_red_vip.png",
  5: "images/nave_alcance_vip.png",
  6: "images/nave_protecao_vip.png",
  7: "images/nave_protecao_red_vip.png",
  8: "images/nave_normal_vip.png",
  9: "images/nave_normal_red_vip.png"
};

const naveSourcesRed = {
  1: "images/nave_alcance_red.png",
  2: "images/nave_protecao_red.png",
  3: "images/nave_normal_red.png",
  4: "images/nave_alcance_red_vip.png",
  5: "images/nave_alcance_vip.png",
  6: "images/nave_protecao_vip.png",
  7: "images/nave_protecao_red_vip.png",
  8: "images/nave_normal_vip.png",
  9: "images/nave_normal_red_vip.png"
};


// Usar window.selectedNaves diretamente para evitar problemas de escopo
if (!window.selectedNaves) {
  window.selectedNaves = [];
}
let selectedNaves = window.selectedNaves;

function selectNave(tipo) {
  
  // AAA: Bloquear input se inputLocked
  if (inputLocked) {
    return;
  }
  
  if (window.selectedNaves.length >= 3) {
    return;
  }

  window.selectedNaves.push(tipo);
  updatePreviews();
}


function removeNave(index) {
  if (isSelectionLocked()) return;
  window.selectedNaves.splice(index, 1);
  if (window.slotShotTypes) window.slotShotTypes.splice(index, 1);
  updatePreviews();
  // Se remover, destrava seleÃ§Ã£o
  if (window.selectedNaves.length < 3 && PVP.selectionComplete) {
    PVP.selectionComplete = false;
  }
}

function updatePreviews() {
  // Escolher fontes baseado no time
  const sources = (multiplayerMode && myTeam === 'red') ? naveSourcesRed : naveSources;
  
  // Reseta todas as imagens de preview
  for (let i = 0; i < 3; i++) {
    const preview = document.getElementById(`preview${i + 1}`);
    const shotIcon = document.getElementById(`shotIcon${i + 1}`);
    if (preview) {
      preview.src = "images/placeholder_nave.png";
      preview.style.opacity = "0.4";
    }
    if (shotIcon) {
      shotIcon.style.opacity = "0";
    }
  }

  // Reset per-slot shot type tracker when selection is cleared
  if (!window.selectedNaves || window.selectedNaves.length === 0) {
    window.slotShotTypes = [];
  }

  // ValidaÃ§Ã£o de selectedNaves
  if (!Array.isArray(window.selectedNaves)) {
    console.error('[PREVIEWS] window.selectedNaves is not an array:', window.selectedNaves);
    return;
  }

  // Atualiza com base nas naves atualmente selecionadas
  window.selectedNaves.forEach((shipType, slotIndex) => {
    const preview = document.getElementById(`preview${slotIndex + 1}`);
    const shotIcon = document.getElementById(`shotIcon${slotIndex + 1}`);
    
    if (!preview || !shotIcon) return;
    
    const source = sources[shipType];
    if (source) {
      preview.src = source;
      preview.style.opacity = "1";
      
      // Atualizar Ã­cone de shot type usando o tipo da nave como chave
      // Fallback seguro caso ShotTypeManager nÃ£o esteja carregado ainda
      let shotType = 'plasma';
      // Use per-slot tracking first (immune to ShotTypeManager async overwrites)
      if (window.slotShotTypes && window.slotShotTypes[slotIndex] !== undefined) {
        shotType = window.slotShotTypes[slotIndex];
      } else if (typeof ShotTypeManager !== 'undefined') {
        shotType = ShotTypeManager.getShotType(shipType);
      } else {
        // Fallback: ler do localStorage diretamente
        try {
          const prefs = JSON.parse(localStorage.getItem('thor_shot_preferences') || '{}');
          shotType = prefs[String(shipType)] || 'plasma';
        } catch (e) {
          shotType = 'plasma';
        }
      }
      shotIcon.src = `images/shots/${shotType}.png`;
      shotIcon.style.opacity = "0.9";
    }
  });

  // Disable/enable carousel cards based on selection count (lock once all 3 slots filled)
  const trackEl = document.getElementById('naveCarouselTrack');
  if (trackEl) {
    if (window.selectedNaves.length >= 3) {
      trackEl.classList.add('carousel-all-selected');
    } else {
      trackEl.classList.remove('carousel-all-selected');
    }
  }

  // Mostra o botÃ£o somente se houver exatamente 3 selecionadas
  const btn = document.getElementById("startGameBtn");
  if (btn) {
    const has3Ships = (window.selectedNaves.length === 3);
    btn.style.display = has3Ships ? "block" : "none";
    
    // Em multiplayer: estado do botÃ£o depende da presenÃ§a do oponente
    if (multiplayerMode && !PVP.hasSavedSelection) {
      updateReadyBtnState();
    } else {
      btn.textContent = t('startGame');
      btn.disabled = false;
      btn.style.opacity = '1';
      btn.style.cursor = 'pointer';
    }
  }
}


function startGameAfterSelection() {

  // reset flag para permitir envio de score na prÃ³xima partida
  scoreMessageSent = false;
  
  // âœ… Resetar flags de finalizaÃ§Ã£o para nova partida
  finalScoreSaved = { myLost: 0, oppLost: 0 }; // Resetar placar salvo
  matchFinalizationProcessed = false;
  statsUpdated = false;
  gameOverSent = false;
  window.__matchEndEventsProcessed = false; // ðŸ”“ Resetar flag de eventos de fim
  
  // âœ… XP: Resetar sistema de XP para nova partida
  resetMatchXP();

  // AAA: VerificaÃ§Ã£o robusta usando window.selectedNaves
  if (!window.selectedNaves || window.selectedNaves.length !== 3) {
    alert("Escolha 3 naves antes de iniciar.");
    return;
  }

  localStorage.setItem("navesSelecionadas", JSON.stringify(window.selectedNaves));

  if (!playerName || playerName.trim().length === 0) {
    playerName = "Jogador";
  }

  // MODO MULTIPLAYER: Sistema de turnos
  if (multiplayerMode && matchData) {
    debug.pvp('[PVP] ========================================');
    debug.pvp('[PVP] MODO MULTIPLAYER - Salvando seleÃ§Ã£o de naves...');
    debug.pvp('[PVP] Meu time:', myTeam);
    debug.pvp('[PVP] Naves selecionadas:', window.selectedNaves);
    
    // Guard: evitar salvar mÃºltiplas vezes
    if (PVP.hasSavedSelection) {
      debug.pvp('[PVP] âš ï¸ SeleÃ§Ã£o jÃ¡ salva, ignorando');
      return;
    }
    
    PVP.hasSavedSelection = true;
    
    // Cancelar timer se estiver rodando
    cancelSelectionTimer();
    
    // Salvar minhas naves no banco
    saveShipSelection().then(success => {
      if (!success) {
        alert('Erro ao salvar seleÃ§Ã£o de naves');
        PVP.hasSavedSelection = false; // permitir retry
        // Reabilitar botÃ£o
        const btn = document.getElementById('startGameBtn');
        if (btn) {
          btn.disabled = false;
          btn.textContent = t('ready');
        }
        return;
      }
      
      debug.pvp('[PVP] âœ… SeleÃ§Ã£o salva com sucesso');
      
      // (H) Feedback visual: desabilitar botÃ£o e mostrar aguardando
      const btn = document.getElementById('startGameBtn');
      if (btn) {
        btn.disabled = true;
        btn.textContent = t('waitingSync');
        btn.style.opacity = '0.6';
      }
      
      // Aguardar Realtime ou fallback REST chamar startBattleFromSelection
    });
    
    debug.pvp('[PVP] ========================================');
    return;
  }

  // Modo solo/practice normal
  
  document.getElementById("naveSelectScreen").style.display = "none";

  // Aplica as naves escolhidas - AAA: usar window.selectedNaves
  applyPlayerNavesFromSelection(window.selectedNaves);
  
  // Inicializar CPU apenas para modo solo
  initCpuNaves();

  // Mostra o canvas e o HUD do jogo
  galaxyBg.style.opacity = "0.18";
  document.getElementById("gameCanvas").style.display = "block";
  playRandomBgm();
  var hudTop = document.getElementById("hudTop");
  var timerText = document.getElementById("timerText");
  var legendArea = document.getElementById("legendArea");
  if (hudTop && timerText && legendArea) {
    showGameHUD('10', 'Round 1 - Prepare-se para a batalha');
  }
  document.getElementById("gameContour").style.visibility = "visible";

  // Mostrar banner de matchup
  const matchupBanner = document.getElementById("matchupBanner");
  const playerNameDisplay = document.getElementById("playerNameDisplay");
  const opponentNameDisplay = document.getElementById("opponentNameDisplay");
  
  if (matchupBanner && playerNameDisplay && opponentNameDisplay) {
    const currentPlayerName = playerName || localStorage.getItem("thor_username") || "Player";
    
    // Determinar quem Ã© P1 (azul) e quem Ã© P2 (vermelho)
    let player1Name, player2Name;
    if (multiplayerMode && myTeam === 'blue') {
      // Eu sou azul (P1) â†’ Eu na esquerda, oponente na direita
      player1Name = currentPlayerName;
      player2Name = opponentUsername || localStorage.getItem("thor_match_opponent_name") || "Opponent";
    } else if (multiplayerMode && myTeam === 'red') {
      // Eu sou vermelho (P2) â†’ Oponente na esquerda, eu na direita
      player1Name = opponentUsername || localStorage.getItem("thor_match_opponent_name") || "Opponent";
      player2Name = currentPlayerName;
    } else {
      // Solo mode
      player1Name = currentPlayerName;
      player2Name = "CPU";
    }
    
    // Exibir sempre P1 (azul) x P2 (vermelho)
    const _p1IsVip2 = localStorage.getItem('thor_is_vip') === 'true';
    const _p1VipColor2 = localStorage.getItem('thor_vip_name_color') || '#FFD700';
    playerNameDisplay.textContent = _p1IsVip2 ? ('ðŸ’Ž ' + player1Name) : player1Name;
    playerNameDisplay.style.color = _p1IsVip2 ? _p1VipColor2 : "#00E5FF"; // Sempre azul (P1)
    
    const _p2IsVip2 = (myTeam === 'red') && localStorage.getItem('thor_is_vip') === 'true';
    const _p2VipColor2 = localStorage.getItem('thor_vip_name_color') || '#FFD700';
    opponentNameDisplay.textContent = _p2IsVip2 ? ('ï¿½ ' + player2Name) : player2Name;
    opponentNameDisplay.style.color = _p2IsVip2 ? _p2VipColor2 : "#FF4444";
    
    
    matchupBanner.style.display = "block";
    matchupBanner.style.visibility = "visible";
    matchupBanner.style.opacity = "1";
    
    // Log para debug
    
    // ForÃ§ar apÃ³s um delay para garantir que outras funÃ§Ãµes nÃ£o escondam
    setTimeout(() => {
      if (matchupBanner.style.display === "none") {
        console.warn('[MATCHUP] âš ï¸ Banner foi escondido! ForÃ§ando exibiÃ§Ã£o novamente...');
        matchupBanner.style.display = "block";
      }
    }, 100);
  }

  canStartGame = true;

// Chama o gameLoop sÃ³ se ainda nÃ£o estiver rodando
gameActive = true; // always re-enable before checking loop state
if (!window._gameLoopActive) {
  window._gameLoopActive = true;
  window._gameLoopStarted = true;
  if (spritesLoaded === 2) {
    gameLoop();
  } else {
    // VocÃª pode aguardar o carregamento dos sprites aqui se quiser
  }
}
} // âœ… FECHA startGameAfterSelection AQUI



// ðŸ”“ Deixa as funÃ§Ãµes acessÃ­veis pelo HTML inline (onclick)
window.selectNave = selectNave;
window.removeNave = removeNave;
window.startGameAfterSelection = startGameAfterSelection;

// No handler de snapshot/sync do servidor:
function applyServerSnapshot(newShips) {
  if (typeof ships !== 'undefined' && Array.isArray(ships)) {
    const merged = mergeShipsPreservingFlags(ships, newShips);
    ships = merged;
    debug.sync('[SYNC] merge snapshot preserving ready/selected');
  } else {
    ships = newShips;
    debug.sync('[SYNC] initial snapshot');
  }
  updatePreviews();
}

// FunÃ§Ã£o para desbloquear seleÃ§Ã£o explicitamente
function unlockSelection() {
  PVP.selectionComplete = false;
  window.selectedNaves = [];
  updatePreviews();
}


let assetsToLoad = 6;
let assetsLoaded = 0;

const preloadAssets = [
  "images/spaceschip.png",
  "images/nave_alcance.png",
  "images/nave_protecao.png",
  "sounds/sfx-hit.mp3",
  "sounds/sfx-hit2.mp3",
  "sounds/sfx-shot.mp3",
  "sounds/sfx-explode.mp3"
];

assetsToLoad = preloadAssets.length;

function assetLoaded() {
  assetsLoaded++;
  const percent = Math.floor((assetsLoaded / assetsToLoad) * 100);
  document.getElementById("loadingBar").style.width = percent + "%";

  if (assetsLoaded >= assetsToLoad) {
    setTimeout(() => {
      if (!isEmbedded) showOnly("startContainer"); // Mostra sÃ³ a tela de login quando nÃ£o embedado
    }, 500);
  }
}



preloadAssets.forEach(src => {
  if (src.endsWith(".mp3")) {
    const audio = new Audio();
    audio.src = src;
    audio.addEventListener("canplaythrough", assetLoaded, { once: true });
    audio.addEventListener("error", assetLoaded, { once: true }); // proteÃ§Ã£o extra
  } else {
    const img = new Image();
    img.src = src;
    img.onload = assetLoaded;
    img.onerror = assetLoaded; // proteÃ§Ã£o extra
  }
});

// Caso algo falhe por qualquer motivo, forÃ§a o loading a sumir em 5 segundos
setTimeout(() => {
  if (assetsLoaded < assetsToLoad) {
    if (!isEmbedded) showOnly("startContainer");
  }
}, 5000);



// ============================================
// APLICAR TRADUÃ‡Ã•ES NA INTERFACE (escopo global)
// ============================================
function updateUITranslations() {
  // TÃ­tulo da seleÃ§Ã£o
  const titleEl = document.getElementById('selectShipsTitle');
  if (titleEl) titleEl.textContent = t('selectShips');
  
  // Labels de Range e Protection
  document.querySelectorAll('.ship-label-range').forEach(el => {
    el.textContent = t('range');
  });
  document.querySelectorAll('.ship-label-protection').forEach(el => {
    el.textContent = t('protection');
  });
  
  // DescriÃ§Ãµes das naves
  const shipDescs = document.querySelectorAll('.ship-desc-text');
  shipDescs.forEach(el => {
    const shipNum = el.getAttribute('data-ship');
    if (shipNum === '1') el.textContent = t('ship1Desc');
    if (shipNum === '2') el.textContent = t('ship2Desc');
    if (shipNum === '3') el.textContent = t('ship3Desc');
  });
  
  // BotÃ£o de iniciar
  const startBtn = document.getElementById('startGameBtn');
  if (startBtn && !multiplayerMode) {
    startBtn.textContent = t('startGame');
  }
}

window.addEventListener("DOMContentLoaded", () => {
  const startBtn = document.getElementById("startBtn");
  const playerNameInput = document.getElementById("playerNameInput");

startBtn.onclick = () => {
  playerName = playerNameInput.value.trim();
  if (playerName.length === 0) {
    playerNameInput.focus();
    playerNameInput.style.borderColor = "#f00";
    return;
  }
  
  // Sempre apÃ³s login do usuÃ¡rio (mas sÃ³ se nÃ£o estiver em iframe)
  if (!isEmbedded) {
    createOrUpdateHeader(playerName, playerScore);
  }

  document.getElementById("startContainer").style.display = "none";
  document.getElementById("thorspace-logo").style.display = "none"; // Esconde logo se ainda estiver visÃ­vel
showOnly("modeSelectionScreen");

};

  // Se estiver embedado, ouvir THOR:INIT do parent para inicializar username e mode
  if (isEmbedded) {
    window.addEventListener('message', async (event) => {
      if (event.origin !== window.location.origin) return;
      const msg = event.data;
      if (!msg || typeof msg !== 'object') return;
      if (msg.type === 'THOR:INIT') {
        const payload = msg.payload || {};
        const initName = String(payload.username || '').trim();
        const initMode = String(payload.mode || 'practice');
        const userId = payload.userId;
        const matchId = payload.matchId;

        // Armazenar dados do jogador ANTES de qualquer inicializaÃ§Ã£o
        if (userId && initName) {
          window.THOR_PLAYER = { userId, username: initName, matchId };
          
          // Salvar userId no localStorage para ShotTypeManager
          localStorage.setItem('thor_user_id', userId);
        } else {
          console.error('[THOR] âŒ ATENÃ‡ÃƒO: userId ou username nÃ£o recebidos!', { userId, initName });
        }

        if (initName) {
          playerName = initName;
          // NÃ£o criar header aqui pois jÃ¡ vem do Next.js quando embedado
          if (!isEmbedded) {
            createOrUpdateHeader(playerName, playerScore);
          }
        }

        // Checar se hÃ¡ matchId na URL para modo PVP real
        const urlParams = getUrlParams();
        
        if (urlParams.mode === 'multiplayer' && urlParams.matchId && !urlParams.matchId.startsWith('fake-')) {
          debug.pvp('[PVP] Detectado matchId na URL:', urlParams.matchId);
          
          // AGUARDAR um pouco para garantir que o Supabase client estÃ¡ disponÃ­vel
          setTimeout(async () => {
            try {
              const success = await initMultiplayerMode(urlParams.matchId);
              
              if (success) {
                debug.pvp('[PVP] âœ… Multiplayer inicializado com sucesso');
                // Ir para seleÃ§Ã£o de naves
                showOnly('naveSelectScreen');
                window.selectedNaves = [];
                updatePreviews();
                // AAA: Garantir fase interativa e timer no round 1
                phase = 'select';
                currentPhase = 'select';
                ensurePvpInteractivePhase('initMultiplayerMode');
              } else {
                console.error('[PVP] âŒ FALHA ao inicializar multiplayer - initMultiplayerMode retornou false');
                alert('Erro ao inicializar multiplayer: Falha na inicializaÃ§Ã£o (verifique console)');
              }
            } catch (err) {
              console.error('[MP INIT ERROR] âŒâŒâŒ EXCEÃ‡ÃƒO CAPTURADA âŒâŒâŒ');
              console.error('[MP INIT ERROR] Tipo:', typeof err);
              console.error('[MP INIT ERROR] Mensagem:', err.message || 'sem mensagem');
              console.error('[MP INIT ERROR] Code:', err.code || 'sem code');
              console.error('[MP INIT ERROR] Details:', err.details || 'sem details');
              console.error('[MP INIT ERROR] Stack:', err.stack);
              console.error('[MP INIT ERROR] Objeto completo:', err);
              
              const errorMsg = err.message || err.toString() || 'Erro desconhecido';
              alert(`Erro MP: ${errorMsg}\n\nVerifique o console para detalhes completos.`);
            }
          }, 100);
        } else if (initMode === 'multiplayer') {
          // Multiplayer sem matchId (nÃ£o deveria acontecer)
          console.error('[PVP] Mode=multiplayer mas sem matchId na URL');
          showOnly('naveSelectScreen');
          window.selectedNaves = [];
          updatePreviews();
        } else {
          // Modo solo (practice)
          showOnly('naveSelectScreen');
          window.selectedNaves = [];
          updatePreviews();
        }
      }
    });
  }

  // Registra o clique do botÃ£o de logout do header para apenas enviar mensagem ao parent
  const logoutBtn = document.getElementById('userLogoutBtn');
  if (logoutBtn && !logoutBtn._bound) {
    logoutBtn.addEventListener('click', () => {
      try {
        if (window.parent) {
          window.parent.postMessage({ type: "THOR:LOGOUT" }, window.location.origin);
        }
      } catch (e) {
        // silencioso: nÃ£o redireciona nem faz logout, apenas tenta enviar a mensagem
        console.warn('Erro ao enviar mensagem de logout ao parent', e);
      }
    });
    logoutBtn._bound = true;
  }

document.getElementById("practiceBtn").onclick = () => {
  document.getElementById("modeSelectionScreen").style.display = "none";
  // garante que usamos o header Ãºnico e removemos possÃ­veis duplicatas antigas
  // (mas sÃ³ se nÃ£o estiver em iframe)
  if (!isEmbedded) {
    createOrUpdateHeader(playerName, playerScore);
    document.querySelectorAll('.user-header-pts, .user-header-name').forEach(el => { if (!el.closest('#userHeader')) el.remove(); });
  }
  document.getElementById("naveSelectScreen").style.display = "flex";
  document.getElementById("thorspace-logo").style.display = "none";
  window.selectedNaves = [];
  updatePreviews();
};


document.getElementById("multiplayerBtn").onclick = () => {
  document.getElementById("modeSelectionScreen").style.display = "none";
  document.getElementById("matchmakingScreen").style.display = "flex";

  // Mostra o nome do player no slot azul
  document.getElementById("playerSlot").textContent = playerName;

  // Inicia a rotaÃ§Ã£o vertical dos nomes
  startMatchmakingSlot();

  // Aguarda 6s: (3s de rotaÃ§Ã£o + 3s de "Oponente encontrado!")
  setTimeout(() => {
    document.getElementById("matchmakingScreen").style.display = "none";
    // antes de abrir a tela de escolha de naves, garantir header Ãºnico
    // (mas sÃ³ se nÃ£o estiver em iframe)
    if (!isEmbedded) {
      createOrUpdateHeader(playerName, playerScore);
      document.querySelectorAll('.user-header-pts, .user-header-name').forEach(el => { if (!el.closest('#userHeader')) el.remove(); });
    }
    document.getElementById("naveSelectScreen").style.display = "flex";
    document.getElementById("thorspace-logo").style.display = "none";

    window.selectedNaves = [];
    updatePreviews();
  }, 6000);
};



// â”€â”€ Nave Selection Carousel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let naveCarouselOffset = 0;
let naveCarouselVisibleCount = 0;
const CAROUSEL_SLOT_W = 250; // 230px slot + 20px gap

function initNaveCarousel() {
  const isVip = localStorage.getItem('thor_is_vip') === 'true';
  const slot4 = document.getElementById('naveSlot4');
  const slot5 = document.getElementById('naveSlot5');
  const slot6 = document.getElementById('naveSlot6');
  const slot7 = document.getElementById('naveSlot7');
  const slot8 = document.getElementById('naveSlot8');
  const slot9 = document.getElementById('naveSlot9');

  // Team-based VIP ship visibility (always visible, locked for non-VIP):
  // RED  (P2): tipo 4 (alcance red), tipo 7 (protecao red), tipo 9 (normal red)
  // BLUE (P1/solo): tipo 5 (alcance), tipo 6 (protecao), tipo 8 (normal)
  let showRed  = false; // P2 only
  let showBlue = false; // P1 + solo
  if (!multiplayerMode) {
    showBlue = true;
  } else if (myTeam === 'red') {
    showRed = true;
  } else {
    showBlue = true;
  }

  if (slot4) slot4.style.display = showRed  ? 'block' : 'none';
  if (slot5) slot5.style.display = showBlue ? 'block' : 'none';
  if (slot6) slot6.style.display = showBlue ? 'block' : 'none';
  if (slot7) slot7.style.display = showRed  ? 'block' : 'none';
  if (slot8) slot8.style.display = showBlue ? 'block' : 'none';
  if (slot9) slot9.style.display = showRed  ? 'block' : 'none';

  // For VIP users: move their visible VIP slots to the front of the track
  const isVipUser = localStorage.getItem('thor_is_vip') === 'true';
  const track = document.getElementById('naveCarouselTrack');
  // Hide immediately so the flash of wrong ordering is never painted
  if (track) track.style.visibility = 'hidden';
  if (track && isVipUser) {
    const vipIds = ['naveSlot4','naveSlot5','naveSlot6','naveSlot7','naveSlot8','naveSlot9'];
    const visibleVip = vipIds.map(id => document.getElementById(id)).filter(el => el && el.style.display !== 'none');
    // prepend in reverse order so the first VIP slot lands at position 0
    [...visibleVip].reverse().forEach(el => track.prepend(el));
  }

  // Count visible slots
  naveCarouselVisibleCount = document.querySelectorAll('#naveCarouselTrack .nave-card-slot:not([style*="display: none"])').length;

  // Reset offset
  naveCarouselOffset = 0;

  // Allow repaint to flush before we reveal (requestAnimationFrame ensures layout is committed)
  requestAnimationFrame(() => {
    updateNaveCarousel();
    if (track) track.style.visibility = '';
  });
}

function updateNaveCarousel() {
  const track = document.getElementById('naveCarouselTrack');
  const prevBtn = document.getElementById('carouselPrevBtn');
  const nextBtn = document.getElementById('carouselNextBtn');
  if (!track || !prevBtn || !nextBtn) return;

  // Recalculate visible count
  const visibleSlots = Array.from(document.querySelectorAll('#naveCarouselTrack .nave-card-slot')).filter(
    s => s.style.display !== 'none'
  );
  naveCarouselVisibleCount = visibleSlots.length;

  const maxOffset = Math.max(0, naveCarouselVisibleCount - 3);
  naveCarouselOffset = Math.max(0, Math.min(naveCarouselOffset, maxOffset));

  // Compute pixel offset: walk through all slots (visible + hidden) until we've passed `naveCarouselOffset` visible ones
  const allSlots = Array.from(document.querySelectorAll('#naveCarouselTrack .nave-card-slot'));
  let visIdx = 0;
  let pixelOffset = 0;
  for (const slot of allSlots) {
    if (slot.style.display === 'none') continue;
    if (visIdx === naveCarouselOffset) break;
    pixelOffset += CAROUSEL_SLOT_W;
    visIdx++;
  }

  track.style.transform = 'translateX(-' + pixelOffset + 'px)';

  // Mark only the 3 currently-visible slots so off-screen cards lose their glow
  let inViewIdx = 0;
  for (const slot of allSlots) {
    if (slot.style.display === 'none') { slot.classList.remove('carousel-in-view'); continue; }
    const inView = inViewIdx >= naveCarouselOffset && inViewIdx < naveCarouselOffset + 3;
    slot.classList.toggle('carousel-in-view', inView);
    inViewIdx++;
  }

  const needArrows = naveCarouselVisibleCount > 3;
  prevBtn.style.visibility = needArrows ? 'visible' : 'hidden';
  nextBtn.style.visibility = needArrows ? 'visible' : 'hidden';
  prevBtn.style.opacity = (naveCarouselOffset <= 0) ? '0.3' : '1';
  nextBtn.style.opacity = (naveCarouselOffset >= maxOffset) ? '0.3' : '1';
  prevBtn.style.pointerEvents = (naveCarouselOffset <= 0) ? 'none' : 'auto';
  nextBtn.style.pointerEvents = (naveCarouselOffset >= maxOffset) ? 'none' : 'auto';
}

function naveCarouselMove(dir) {
  naveCarouselOffset += dir;
  updateNaveCarousel();
}
// Expose to global scope so inline onclick handlers can reach them
window.initNaveCarousel = initNaveCarousel;
window.updateNaveCarousel = updateNaveCarousel;
window.naveCarouselMove = naveCarouselMove;
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  document.querySelectorAll(".nave-card").forEach(el => {
    el.addEventListener("click", (e) => {
      // VIP guard: block selection of VIP ships for non-VIP users
      if (el.classList.contains('vip-nave-card') && localStorage.getItem('thor_is_vip') !== 'true') {
        e.stopPropagation();
        // Shake the card and show tooltip
        el.classList.remove('vip-nave-shake');
        void el.offsetWidth; // reflow to restart animation
        el.classList.add('vip-nave-shake');
        let tip = el.querySelector('.vip-locked-tip');
        if (!tip) {
          tip = document.createElement('div');
          tip.className = 'vip-locked-tip';
          tip.textContent = 'ðŸ’Ž Exclusivo VIP';
          el.appendChild(tip);
        }
        tip.style.opacity = '1';
        clearTimeout(tip._hideTimer);
        tip._hideTimer = setTimeout(() => { tip.style.opacity = '0'; }, 1800);
        return;
      }
      // AAA: Permitir seleÃ§Ã£o de nave SEMPRE que a tela de seleÃ§Ã£o estiver visÃ­vel
      const naveSelectScreen = document.getElementById('naveSelectScreen');
      if (naveSelectScreen && naveSelectScreen.style.display !== 'none') {
        const tipo = parseInt(el.dataset.nave, 10);
        pendingNaveSelection = tipo;
        openShotTypeModal(tipo);
        return;
      }
      // Fora da seleÃ§Ã£o de naves, aplicar guardas multiplayer
      if (multiplayerMode) {
        if (!isMyTurn) {
          debug.pvp('[PVP][INPUT][GUARD][CARD] Ignorando clique em nave-card: nÃ£o Ã© meu turno.');
          e.stopPropagation();
          return;
        }
        if (typeof phase !== 'undefined' && phase !== 'select') {
          debug.pvp('[PVP][INPUT][GUARD][CARD] Ignorando clique em nave-card: phase != select. phase:', phase);
          e.stopPropagation();
          return;
        }
      }
      const tipo = parseInt(el.dataset.nave, 10);
      selectNave(tipo);
    });
  });
});


function startMatchmakingSlot() {
  const names = ["JoÃ£o", "Maria", "Lucas", "Ana", "Rafael", "Thais", "Pedro", "Juliana"];
  const container = document.getElementById("opponentNames");
  const legend = document.getElementById("matchLegend");
  
  // Passo 1: mostra legenda "Procurando oponente..."
  legend.textContent = t('searchingOpponent');

  // Monta nomes verticalmente
  container.innerHTML = "";
  container.classList.add("slot-names");
  names.forEach(n => {
    const el = document.createElement("div");
    el.textContent = n;
    el.style.height = "42px";
    el.style.lineHeight = "42px";
    el.style.fontSize = "22px";
    el.style.textAlign = "center";
    container.appendChild(el);
  });
  container.style.animation = "spinNames 2s cubic-bezier(.73,-0.05,.67,1.03)";

  // Depois de 2s, para a animaÃ§Ã£o e mostra o nome do oponente
  setTimeout(() => {
    container.style.animation = "none";
    const chosen = names[Math.floor(Math.random() * names.length)];
    container.innerHTML = `<div style="height:42px;line-height:42px;font-size:22px;text-align:center;">${chosen}</div>`;

    // Muda legenda por 3 segundos
    legend.textContent = t('opponentFound');

    // ApÃ³s 3s, troca para tela de seleÃ§Ã£o de naves
    setTimeout(() => {
      document.getElementById("matchmakingScreen").style.display = "none";
      document.getElementById("naveSelectScreen").style.display = "flex";
      window.selectedNaves = [];
      updatePreviews();
      // AAA: Re-adiciona handler de clique nas nave-card apÃ³s DOM update
      setTimeout(() => {
        document.querySelectorAll(".nave-card").forEach(el => {
          el.onclick = null;
          el.addEventListener("click", (e) => {
            const naveSelectScreen = document.getElementById('naveSelectScreen');
            if (naveSelectScreen && naveSelectScreen.style.display !== 'none') {
              const tipo = parseInt(el.dataset.nave, 10);
              pendingNaveSelection = tipo;
              openShotTypeModal(tipo);
              return;
            }
            if (multiplayerMode) {
              if (!isMyTurn) {
                debug.pvp('[PVP][INPUT][GUARD][CARD] Ignorando clique em nave-card: nÃ£o Ã© meu turno.');
                e.stopPropagation();
                return;
              }
              if (typeof phase !== 'undefined' && phase !== 'select') {
                debug.pvp('[PVP][INPUT][GUARD][CARD] Ignorando clique em nave-card: phase != select. phase:', phase);
                e.stopPropagation();
                return;
              }
            }
            const tipo = parseInt(el.dataset.nave, 10);
            selectNave(tipo);
          });
        });
      }, 100);
    }, 3000);
  }, 2000); // Este setTimeout Ãºnico Ã© ok - nÃ£o Ã© polling
}

// POLLING REMOVIDO: Realtime substitui necessidade de polling
// Se precisar fallback, implementar somente quando disconnected com intervalo >= 10s


// Cleanup do canal multiplayer ao fechar/sair
window.addEventListener('beforeunload', () => {
  // Parar heartbeat ao sair
  stopHeartbeat();
  
  // Se estiver em partida multiplayer em andamento, aplicar WO
  if (multiplayerMode && matchData && currentPhase !== 'finished') {
    
    // Usar sendBeacon para enviar de forma sÃ­ncrona (mais confiÃ¡vel no unload)
    const supabaseUrl = new URLSearchParams(window.location.search).get('supabaseUrl');
    const supabaseKey = new URLSearchParams(window.location.search).get('supabaseKey');
    
    if (supabaseUrl && supabaseKey && matchData.id && opponentUserId) {
      const url = `${supabaseUrl}/rest/v1/matches?id=eq.${matchData.id}`;
      const payload = JSON.stringify({
        phase: 'finished',
        winner_id: opponentUserId,
        wo: true,
        finished_at: new Date().toISOString()
      });
      
      const blob = new Blob([payload], { type: 'application/json' });
      
      // sendBeacon Ã© sÃ­ncrono e confiÃ¡vel para unload
      navigator.sendBeacon(url, blob);
      
      // TambÃ©m tentar com fetch keepalive como fallback
      fetch(url, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          'apikey': supabaseKey,
          'Authorization': `Bearer ${supabaseKey}`,
          'Prefer': 'return=minimal'
        },
        body: payload,
        keepalive: true // Permite requisiÃ§Ã£o continuar apÃ³s pÃ¡gina fechar
      }).catch(() => {}); // Ignorar erros
      
    }
  }
  
  // Remover canais ao fechar
  if (supabaseClient) {
    try {
      if (syncChannel) {
        supabaseClient.removeChannel(syncChannel);
        debug.pvp('[PVP] Canal broadcast removido ao fechar');
      }
      if (matchStateChannel) {
        supabaseClient.removeChannel(matchStateChannel);
        debug.pvp('[PVP] Canal de estado removido ao fechar');
      }
    } catch (err) {
      console.error('[PVP] Erro ao remover canais:', err);
    }
  }
});

</script>

<!-- Shot Type Modal -->
<div id="shotTypeModal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.92); z-index:9999; align-items:center; justify-content:center; padding:20px; animation:fadeIn 0.2s ease;">
  <div id="shotTypeModalContent" style="background:linear-gradient(135deg, rgba(0,15,30,0.98) 0%, rgba(0,5,15,0.98) 100%); border:2px solid rgba(0,229,255,0.5); border-radius:16px; padding:24px; max-width:800px; width:100%; position:relative; box-shadow:0 0 40px rgba(0,229,255,0.3); animation:slideUp 0.3s ease;">
    
    <!-- Header -->
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:16px;">
      <h2 style="font-size:22px; font-weight:700; color:#00E5FF; margin:0; font-family:'Orbitron',sans-serif; text-shadow:0 0 20px rgba(0,229,255,0.6); letter-spacing:1px;">
        Tipo de Tiro
      </h2>
      <button onclick="closeShotTypeModal()" style="background:transparent; border:2px solid rgba(0,229,255,0.4); border-radius:8px; width:36px; height:36px; display:flex; align-items:center; justify-content:center; cursor:pointer; transition:all 0.2s; color:#00E5FF;">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none">
          <path d="M18 6L6 18M6 6l12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
        </svg>
      </button>
    </div>

    <!-- Ship Indicator -->
    <div id="shotTypeShipLabel" style="font-size:12px; color:rgba(255,255,255,0.6); margin-bottom:16px; font-family:'Orbitron',sans-serif;">
      Nave 1 / 3
    </div>

    <!-- Cards Grid -->
    <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(220px, 1fr)); gap:16px; margin-bottom:20px;">
      
      <!-- Plasma Card -->
      <div class="shot-card" data-type="plasma" onclick="selectShotType('plasma')" style="background:rgba(0,20,40,0.6); border:2px solid rgba(0,229,255,0.3); border-radius:12px; padding:14px; cursor:pointer; transition:all 0.3s cubic-bezier(0.4, 0, 0.2, 1); position:relative; overflow:hidden;">
        <div class="shot-check" style="position:absolute; top:10px; right:10px; width:28px; height:28px; border-radius:50%; background:rgba(0,229,255,0.2); display:none; align-items:center; justify-content:center; border:2px solid #00E5FF;">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none">
            <path d="M5 13l4 4L19 7" stroke="#00E5FF" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </div>
        <div style="width:100%; height:100px; border-radius:8px; background:rgba(0,0,0,0.4); margin-bottom:10px; display:flex; align-items:center; justify-content:center; overflow:hidden; border:1px solid rgba(0,229,255,0.2);">
          <img src="images/shots/plasma.png" alt="Plasma" style="max-width:70%; max-height:70%; object-fit:contain;">
        </div>
        <div style="font-size:15px; font-weight:700; color:#FFF; margin-bottom:6px; font-family:'Orbitron',sans-serif;">
          Plasma ClÃ¡ssico
        </div>
        <div style="font-size:11px; color:rgba(255,255,255,0.7); line-height:1.4; margin-bottom:8px; font-family:'Orbitron',sans-serif;">
          ProjÃ©til clÃ¡ssico de energia azul.
        </div>
        <div class="shot-active-badge" style="display:none; align-items:center; gap:4px; padding:4px 8px; background:rgba(0,229,255,0.15); border:1px solid rgba(0,229,255,0.4); border-radius:12px; font-size:10px; font-weight:700; color:#00E5FF; font-family:'Orbitron',sans-serif; width:fit-content;">
          <svg width="10" height="10" viewBox="0 0 24 24" fill="none">
            <path d="M5 13l4 4L19 7" stroke="#00E5FF" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          ATIVO
        </div>
      </div>

      <!-- Pulse Card -->
      <div class="shot-card" data-type="pulse" onclick="selectShotType('pulse')" style="background:rgba(0,20,40,0.6); border:2px solid rgba(251,191,36,0.3); border-radius:12px; padding:14px; cursor:pointer; transition:all 0.3s cubic-bezier(0.4, 0, 0.2, 1); position:relative; overflow:hidden;">
        <div class="vip-lock-overlay" style="display:none; position:absolute; inset:0; background:rgba(0,0,0,0.65); border-radius:10px; z-index:10; flex-direction:column; align-items:center; justify-content:center; gap:6px; pointer-events:none;">
          <svg width="28" height="28" viewBox="0 0 24 24" fill="none"><rect x="5" y="11" width="14" height="10" rx="2" stroke="#FFD700" stroke-width="2"/><path d="M8 11V7a4 4 0 118 0v4" stroke="#FFD700" stroke-width="2" stroke-linecap="round"/></svg>
          <span style="font-size:10px; font-weight:900; color:#FFD700; font-family:'Orbitron',sans-serif; letter-spacing:1px;">ðŸ’Ž EXCLUSIVO VIP</span>
        </div>
        <div style="width:100%; height:100px; border-radius:8px; background:rgba(0,0,0,0.4); margin-bottom:10px; display:flex; align-items:center; justify-content:center; overflow:hidden; border:1px solid rgba(0,229,255,0.2);">
          <img src="images/shots/pulse.png" alt="Pulse" style="max-width:70%; max-height:70%; object-fit:contain;">
        </div>
        <div style="font-size:15px; font-weight:700; color:#fbbf24; margin-bottom:6px; font-family:'Orbitron',sans-serif; display:flex; align-items:center; gap:8px;">
          Pulse Energy
          <span class="vip-badge" style="display:none; font-size:9px; font-weight:900; padding:2px 7px; border-radius:20px; background:rgba(255,215,0,0.18); border:1px solid rgba(255,215,0,0.55); color:#FFD700; font-family:'Orbitron',sans-serif; letter-spacing:1px;">ðŸ’Ž VIP</span>
        </div>
        <div style="font-size:11px; color:rgba(255,255,255,0.7); line-height:1.4; margin-bottom:8px; font-family:'Orbitron',sans-serif;">
          ProjÃ©til energÃ©tico pulsante amarelo.
        </div>
        <div class="shot-active-badge" style="display:none; align-items:center; gap:4px; padding:4px 8px; background:rgba(251,191,36,0.15); border:1px solid rgba(251,191,36,0.4); border-radius:12px; font-size:10px; font-weight:700; color:#fbbf24; font-family:'Orbitron',sans-serif; width:fit-content;">
          <svg width="10" height="10" viewBox="0 0 24 24" fill="none">
            <path d="M5 13l4 4L19 7" stroke="#fbbf24" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          ATIVO
        </div>
      </div>

      <!-- Energy Card -->
      <div class="shot-card" data-type="energy" onclick="selectShotType('energy')" style="background:rgba(0,20,40,0.6); border:2px solid rgba(217,70,239,0.3); border-radius:12px; padding:14px; cursor:pointer; transition:all 0.3s cubic-bezier(0.4, 0, 0.2, 1); position:relative; overflow:hidden;">
        <div class="vip-lock-overlay" style="display:none; position:absolute; inset:0; background:rgba(0,0,0,0.65); border-radius:10px; z-index:10; flex-direction:column; align-items:center; justify-content:center; gap:6px; pointer-events:none;">
          <svg width="28" height="28" viewBox="0 0 24 24" fill="none"><rect x="5" y="11" width="14" height="10" rx="2" stroke="#FFD700" stroke-width="2"/><path d="M8 11V7a4 4 0 118 0v4" stroke="#FFD700" stroke-width="2" stroke-linecap="round"/></svg>
          <span style="font-size:10px; font-weight:900; color:#FFD700; font-family:'Orbitron',sans-serif; letter-spacing:1px;">ðŸ’Ž EXCLUSIVO VIP</span>
        </div>
        <div style="width:100%; height:100px; border-radius:8px; background:rgba(0,0,0,0.4); margin-bottom:10px; display:flex; align-items:center; justify-content:center; overflow:hidden; border:1px solid rgba(0,229,255,0.2);">
          <img src="images/shots/energy.png" alt="Energy" style="max-width:70%; max-height:70%; object-fit:contain;">
        </div>
        <div style="font-size:15px; font-weight:700; color:#d946ef; margin-bottom:6px; font-family:'Orbitron',sans-serif; display:flex; align-items:center; gap:8px;">
          Ion Spark
          <span class="vip-badge" style="display:none; font-size:9px; font-weight:900; padding:2px 7px; border-radius:20px; background:rgba(255,215,0,0.18); border:1px solid rgba(255,215,0,0.55); color:#FFD700; font-family:'Orbitron',sans-serif; letter-spacing:1px;">ðŸ’Ž VIP</span>
        </div>
        <div style="font-size:11px; color:rgba(255,255,255,0.7); line-height:1.4; margin-bottom:8px; font-family:'Orbitron',sans-serif;">
          ProjÃ©til de Ã­ons elÃ©tricos roxo.
        </div>
        <div class="shot-active-badge" style="display:none; align-items:center; gap:4px; padding:4px 8px; background:rgba(217,70,239,0.15); border:1px solid rgba(217,70,239,0.4); border-radius:12px; font-size:10px; font-weight:700; color:#d946ef; font-family:'Orbitron',sans-serif; width:fit-content;">
          <svg width="10" height="10" viewBox="0 0 24 24" fill="none">
            <path d="M5 13l4 4L19 7" stroke="#d946ef" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          ATIVO
        </div>
      </div>

    </div>

    <!-- Confirm Button -->
    <button onclick="confirmShotType()" style="width:100%; padding:12px 24px; background:linear-gradient(90deg, #00E5FF, #0072FF); color:#001018; border:none; border-radius:10px; font-size:15px; font-weight:700; font-family:'Orbitron',sans-serif; cursor:pointer; transition:all 0.3s cubic-bezier(0.4, 0, 0.2, 1); transform:translateY(0); box-shadow:0 4px 20px rgba(0,229,255,0.4); letter-spacing:1px;">
      CONFIRMAR
    </button>

  </div>
</div>

<style>
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}
@keyframes slideUp {
  from { transform: translateY(30px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}
.shot-card:not(.shot-locked):hover {
  transform: translateY(-4px) scale(1.02);
  border-color: rgba(0,229,255,0.6) !important;
  box-shadow: 0 8px 32px rgba(0,229,255,0.4);
}
.shot-card.selected {
  background: linear-gradient(135deg, rgba(0,229,255,0.15) 0%, rgba(0,114,255,0.15) 100%) !important;
  border-color: rgba(0,229,255,0.8) !important;
  transform: translateY(-4px) scale(1.02);
  box-shadow: 0 8px 32px rgba(0,229,255,0.4);
}
.shot-card.selected .shot-check {
  display: flex !important;
}
.shot-card.selected .shot-active-badge {
  display: inline-flex !important;
}
.shot-card.shot-locked {
  opacity: 0.55;
  cursor: not-allowed !important;
}
.shot-card.shot-locked:hover {
  transform: none !important;
  border-color: rgba(255,215,0,0.3) !important;
  box-shadow: none !important;
}
#shotTypeModalContent button:last-child:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 30px rgba(0,229,255,0.6);
}
</style>

<script>
// Shot Type Modal Variables
let currentModalShipIndex = 1;
// Shot Type System - AAA Quality
const VALID_SHOT_TYPES = ['plasma', 'pulse', 'energy'];
const DEFAULT_SHOT_TYPE = 'plasma';

// State management
const ShotTypeManager = {
  preferences: new Map(), // shipType -> shotType
  selectedShotType: DEFAULT_SHOT_TYPE,
  currentShipType: null,
  
  // ValidaÃ§Ã£o
  isValidShotType(type) {
    return VALID_SHOT_TYPES.includes(type);
  },
  
  // Get shot type for a ship
  getShotType(shipType) {
    if (!shipType || shipType < 1 || shipType > 48) return DEFAULT_SHOT_TYPE;
    return this.preferences.get(String(shipType)) || DEFAULT_SHOT_TYPE;
  },
  
  // Set shot type for a ship
  setShotType(shipType, shotType) {
    if (!this.isValidShotType(shotType)) {
      console.error('[SHOT TYPE] Invalid shot type:', shotType);
      return false;
    }
    this.preferences.set(String(shipType), shotType);
    return true;
  },
  
  // Serialize to object for storage
  toObject() {
    return Object.fromEntries(this.preferences);
  },
  
  // Load from object
  fromObject(obj) {
    if (!obj || typeof obj !== 'object') return;
    Object.entries(obj).forEach(([key, value]) => {
      if (this.isValidShotType(value)) {
        this.preferences.set(key, value);
      }
    });
  },
  
  // Save to localStorage with error handling
  saveToLocalStorage() {
    try {
      const data = this.toObject();
      localStorage.setItem('thor_shot_preferences', JSON.stringify(data));
      return true;
    } catch (err) {
      console.error('[SHOT TYPE] Error saving to localStorage:', err);
      return false;
    }
  },
  
  // Load from localStorage with validation
  loadFromLocalStorage() {
    try {
      const cached = localStorage.getItem('thor_shot_preferences');
      if (cached) {
        const data = JSON.parse(cached);
        this.fromObject(data);
        return true;
      }
    } catch (err) {
      console.error('[SHOT TYPE] Error loading from localStorage:', err);
    }
    return false;
  },
  
  // Save to Supabase
  async saveToSupabase() {
    const userId = localStorage.getItem('thor_user_id');
    
    if (!userId || !supabaseClient) {
      console.warn('[SHOT TYPE] âš ï¸ NÃ£o pode salvar - userId ou supabaseClient ausente');
      return false;
    }
    
    try {
      const { error } = await supabaseClient
        .from('profiles')
        .update({ shot_preferences: this.toObject() })
        .eq('id', userId);
      
      if (error) {
        console.error('[SHOT TYPE] âŒ Erro ao salvar:', error);
        throw error;
      }
      return true;
    } catch (err) {
      console.error('[SHOT TYPE] âŒ Error saving to Supabase:', err);
      return false;
    }
  },
  
  // Load from Supabase
  async loadFromSupabase() {
    const userId = localStorage.getItem('thor_user_id');
    if (!userId || !supabaseClient) return false;

    try {
      const { data, error } = await supabaseClient
        .from('profiles')
        .select('shot_preferences')
        .eq('id', userId)
        .single();

      if (error) throw error;
      
      if (data?.shot_preferences) {
        this.fromObject(data.shot_preferences);
        this.saveToLocalStorage();
        return true;
      }
    } catch (err) {
      console.error('[SHOT TYPE] Error loading from Supabase:', err);
    }
    return false;
  }
};

// Legacy compatibility
let currentShotPreferences = new Proxy({}, {
  get(target, prop) {
    return ShotTypeManager.getShotType(prop);
  },
  set(target, prop, value) {
    return ShotTypeManager.setShotType(prop, value);
  }
});
let selectedShotType = DEFAULT_SHOT_TYPE;

// Load shot preferences on init
async function loadShotPreferences() {
  await ShotTypeManager.loadFromSupabase();
  updateButtonThumbnails();
}

// Update button thumbnails based on preferences - AAA Quality
function updateButtonThumbnails() {
  // Atualizar todos os botÃµes de nave (tipos 1â€“9)
  for (let shipType = 1; shipType <= 9; shipType++) {
    const btn = document.querySelector(`.shot-type-btn[data-ship="${shipType}"]`);
    if (!btn) continue;
    
    const thumb = btn.querySelector('.shot-thumb');
    if (!thumb) continue;
    
    let shotType = 'plasma';
    if (typeof ShotTypeManager !== 'undefined') {
      shotType = ShotTypeManager.getShotType(shipType);
    } else {
      try {
        const prefs = JSON.parse(localStorage.getItem('thor_shot_preferences') || '{}');
        shotType = prefs[String(shipType)] || 'plasma';
      } catch (e) {
        shotType = 'plasma';
      }
    }
    thumb.src = `images/shots/${shotType}.png`;
  }
}

// Open modal with validation - AAA Quality
function openShotTypeModal(shipType) {
  
  // ValidaÃ§Ã£o robusta
  if (!shipType || shipType < 1 || shipType > 48) {
    console.error('[SHOT TYPE] Invalid ship type:', shipType);
    return;
  }
  
  // Configurar estado do modal
  ShotTypeManager.currentShipType = shipType;
  selectedShotType = ShotTypeManager.getShotType(shipType);
  
  // Update ship label - mostrar qual nave (1, 2 ou 3)
  const label = document.getElementById('shotTypeShipLabel');
  if (label) {
    label.textContent = `Nave ${shipType} / 3`;
  }
  
  // Update selected state
  document.querySelectorAll('.shot-card').forEach(card => {
    const isSelected = card.dataset.type === selectedShotType;
    card.classList.toggle('selected', isSelected);
  });
  
  // Apply VIP locks/badges to pulse and energy cards
  const isVip = localStorage.getItem('thor_is_vip') === 'true';
  document.querySelectorAll('.shot-card[data-type="pulse"], .shot-card[data-type="energy"]').forEach(card => {
    const overlay = card.querySelector('.vip-lock-overlay');
    const badge = card.querySelector('.vip-badge');
    if (!isVip) {
      card.classList.add('shot-locked');
      if (overlay) overlay.style.display = 'flex';
      if (badge) badge.style.display = 'none';
    } else {
      card.classList.remove('shot-locked');
      if (overlay) overlay.style.display = 'none';
      if (badge) badge.style.display = 'inline-block';
    }
  });

  // Show modal
  const modal = document.getElementById('shotTypeModal');
  if (modal) {
    modal.style.display = 'flex';
  }
}

// Close modal
function closeShotTypeModal() {
  document.getElementById('shotTypeModal').style.display = 'none';
  pendingNaveSelection = null;
}

// Select shot type with validation
function selectShotType(type) {
  if (!ShotTypeManager.isValidShotType(type)) {
    console.error('[SHOT TYPE] Invalid shot type:', type);
    return;
  }

  // Block VIP-locked shots
  const card = document.querySelector(`.shot-card[data-type="${type}"]`);
  if (card && card.classList.contains('shot-locked')) return;
  
  selectedShotType = type;
  
  // Update UI
  document.querySelectorAll('.shot-card').forEach(card => {
    const isSelected = card.dataset.type === type;
    card.classList.toggle('selected', isSelected);
  });
}

// Confirm and save with robust error handling
async function confirmShotType() {
  const shipType = ShotTypeManager.currentShipType;
  
  if (!shipType) {
    console.error('[SHOT TYPE] No ship type selected');
    closeShotTypeModal();
    return;
  }
  
  
  // Update state
  if (!ShotTypeManager.setShotType(shipType, selectedShotType)) {
    console.error('[SHOT TYPE] Failed to set shot type');
    return;
  }
  
  // Save to storage (both sync)
  ShotTypeManager.saveToLocalStorage();
  
  // If opened from ship selection screen, add the ship to the squad now
  if (pendingNaveSelection !== null) {
    const naveToAdd = pendingNaveSelection;
    // Store chosen shot type per slot BEFORE selectNave increments selectedNaves
    const nextSlot = window.selectedNaves ? window.selectedNaves.length : 0;
    window.slotShotTypes = window.slotShotTypes || [];
    window.slotShotTypes[nextSlot] = selectedShotType;
    pendingNaveSelection = null;
    selectNave(naveToAdd);
  }

  // Update UI immediately
  updateButtonThumbnails();
  updatePreviewIcon(shipType, selectedShotType);
  
  // Save to Supabase async (nÃ£o bloqueia)
  ShotTypeManager.saveToSupabase().catch(err => {
    console.error('[SHOT TYPE] Background save failed:', err);
  });
  
  closeShotTypeModal();
}

// Update preview icon helper
function updatePreviewIcon(shipType, shotType) {
  if (!window.selectedNaves || !Array.isArray(window.selectedNaves)) return;
  
  const slotIndex = window.selectedNaves.indexOf(shipType);
  if (slotIndex === -1) return;
  
  const shotIcon = document.getElementById(`shotIcon${slotIndex + 1}`);
  if (shotIcon) {
    shotIcon.src = `images/shots/${shotType}.png`;
    shotIcon.style.opacity = "0.9";
  }
}

// Load preferences on page load
if (typeof window !== 'undefined') {
  // DESENVOLVIMENTO: Resetar para plasma ao inicializar (remova em produÃ§Ã£o)
  // localStorage.removeItem('thor_shot_preferences');
  
  // Load from localStorage immediately
  ShotTypeManager.loadFromLocalStorage();
  
  // Load from Supabase when ready (com retry em caso de falha)
  const initShotPreferences = async () => {
    await loadShotPreferences();
    // Atualizar thumbnails dos botÃµes apÃ³s carregar
    if (typeof updateButtonThumbnails === 'function') {
      updateButtonThumbnails();
    }
    // Atualizar previews se houver naves selecionadas
    if (typeof updatePreviews === 'function') {
      updatePreviews();
    }
  };
  
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initShotPreferences);
  } else {
    initShotPreferences();
  }
}
</script>

</body>
</html>