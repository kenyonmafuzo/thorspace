<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Thorspace</title>
  <!-- Supabase Client para modo multiplayer -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
body, html {
  height: 100%;
  margin: 0;
  padding: 0;
  background: #000;
}

button, .mode-btn, .end-btn {
  text-transform: uppercase;
}

canvas {
  display: block;
  margin: 0 auto;
  box-shadow: 0 0 60px #0ff4;
  border: 2px solid #0ff;
}

#galaxyBg {
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  z-index: 0; /* atr√°s de tudo */
  background: url('images/galaxiaintro.png') center center / cover no-repeat;
  opacity: 0.18; /* ajuste a transpar√™ncia aqui! */
  pointer-events: none; /* permite clicar em tudo acima normalmente */
    backdrop-filter: blur(54px);
  -webkit-backdrop-filter: blur(54px);
}


#startContainer {
  position: fixed;
  top: 0; left: 0; width: 100vw; height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  /* Troque justify-content: center; por: */
  justify-content: flex-start;
  padding-top: 7vh; /* Suba tudo ajustando aqui! */
  z-index: 1001;
  pointer-events: auto;
  background: transparent;
}


#thorspace-title {
  position: static;
  margin-bottom: 36px;
  font-family: 'Orbitron', sans-serif;
  font-size: 56px;
  color: #0ff;
  text-shadow: 0 4px 16px #000, 0 0 32px #0ff9;
  letter-spacing: 6px;
  font-weight: bold;
  user-select: none;
  pointer-events: none;
  text-transform: uppercase;
  text-align: center;
}

#startModal {
  position: static;
  width: auto;
  height: auto;
  display: flex; align-items: center; justify-content: center;
  z-index: 1002;
  border-radius: 32px;
}

#startModal .modal-content {
background: rgba(0, 165, 242, 0.04);
    border: 1px solid rgba(0, 165, 242, 1.42);
    box-shadow: 0 0 7px #00a5f2, 0 0 0.3px #0ff8 inset, 0 0 0px #000c;
    border-radius: 28px;
    padding: 48px 36px 36px 36px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 28px;
    backdrop-filter: blur(15px) brightness(1.6);
    -webkit-backdrop-filter: blur(49px) brightness(1.21);
}

#startModal label {
  color: #fff;
  font-family: 'Orbitron', sans-serif;
  font-size: 22px;
  letter-spacing: 2px;
  margin-bottom: 12px;
}

#playerNameInput {
  background: #0a1b2b;
  color: #00a5f2;
  border: 2px solid #00a5f2;
  border-radius: 6px;
  padding: 10px 20px;
  font-size: 20px;
  font-family: 'Orbitron', sans-serif;
  letter-spacing: 1.5px;
  text-transform: uppercase;
  outline: none;
  transition: border 0.2s;
  box-shadow: 0 2px 24px #00a5f2 inset;
}

#startBtn {
  margin-top: 14px;
  background: linear-gradient(90deg, #07d8ff, #005ea8 70%);
  color: #fff;
  font-family: 'Orbitron', sans-serif;
  font-size: 22px;
  border: none;
  border-radius: 8px;
  padding: 10px 44px;
  letter-spacing: 2px;
  box-shadow: 0 0 20px #0ff5, 0 2px 8px #000c inset;
  cursor: pointer;
  transition: background 0.3s;
}
#startBtn:hover {
  background: linear-gradient(90deg, #1ef3fc, #1e72ef 80%);
  color: #0ff;
}

/* HUD Superior */

#hudTop {
  width: 800px;
  min-width: 800px;
  max-width: 100vw;
  min-height: 64px;
  height: auto;
  display: flex;
  flex-direction: row;
  justify-content: flex-start;
  align-items: center;
  padding: 0 0 0 0;
  font-family: 'Orbitron', sans-serif;
  font-size: 18px;
  color: #fff;
  background: transparent;
  box-sizing: border-box;
  transition: opacity 0.2s;
  gap: 0;
}






#timerArea {
  width: 90px;
  min-width: 90px;
  max-width: 90px;
  text-align: left;
  font-family: 'Orbitron',sans-serif;
  font-size: 28px;
  color: #00a5f2;
  text-shadow: 0 0 14px #0ff8;
  flex-shrink: 0;
  margin-right: 18px;
  padding-left: 0;
}
#timerText {
  font-size:38px;
}
#legendArea {
  flex: 1 1 0%;
  width: auto;
  min-width: 680px;
  max-width: 900px;
  min-height: 64px;
  margin: 0;
  text-align: left;
  color: #00a5f2;
  font-family: 'Orbitron', sans-serif;
  font-size: 16px;
  letter-spacing: 0.1px;
  text-shadow: 0 0 9px #0ff6;
  white-space: nowrap;
  word-break: keep-all;
  line-height: 1.18;
  padding-left: 0;
  padding-right: 0;
  box-sizing: border-box;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: flex-start;
  flex-wrap: nowrap;
  white-space: nowrap;
}

/* Telas finais */
.end-screen {
  position: fixed;
  top: 0; left: 0; width: 100vw; height: 100vh;
  z-index: 10010;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  opacity: 0;
  transition: opacity 0.5s;
  pointer-events: none;
}
.end-screen[style*="display: flex"] {
  opacity: 1;
  pointer-events: auto;
}
.bg-full {
  position: absolute;
  top: 0; left: 0; width: 100vw; height: 100vh;
  object-fit: cover;
  z-index: 1;
  pointer-events: none;
}
.end-label {
  position: relative;
  z-index: 2;
  max-width: 60vw;
  max-height: 35vh;
  margin-bottom: 32px;
  margin-top: 12vh;
  display: block;
}
.end-btn {
  z-index: 3;
  margin-top: 50px;
  padding: 8px 24px;
  font-size: 1rem;
  font-family: 'Orbitron', sans-serif;
  background: linear-gradient(90deg, #FFD700, #ff8400 90%);
  border: none;
  border-radius: 10px;
  color: #333;
  font-weight: bold;
  letter-spacing: 2px;
  box-shadow: 0 0 32px #FFD70044;
  cursor: pointer;
  transition: background 0.2s;
}
.end-btn:hover {
  background: linear-gradient(90deg, #fff5a1, #ffbc00 100%);
  color: #000;
}

/* Scoreboard */
.score-board {
  position: relative;
  z-index: 2;
  color: #ffffff;
  font-family: 'Orbitron', sans-serif;
  font-size: 2.1em;
  font-weight: bold;
  text-align: center;
  margin-bottom: -46px;
  text-shadow: 0 0 14px #0ff9, 0 6px 11px #000b;
  letter-spacing: 4px;
}

/* Game Wrapper */
#gameWrapper {
  position: fixed;
  top: 0; left: 0;
  width: 100vw;
  height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding-top: 40px;
  z-index: 1;
}

/* Restante dos estilos do seu jogo, se houver... */

/* Responsivo para telas pequenas */
/* @media (max-width: 900px) {
  #hudTop, #timerArea, #legendArea {
    // Responsivo: adicione regras se necess√°rio
  }
} */
@media (max-width: 600px) {
  #thorspace-title {
    font-size: 32px;
    margin-bottom: 18px;
  }
  #startModal .modal-content {
    padding: 26px 12px 18px 12px;
    min-width: 180px;
    font-size: 15px;
  }
  .end-label {
    margin-top: 4vh;
    max-width: 94vw;
    max-height: 30vh;
  }
  .end-btn {
    padding: 12px 8vw;
    font-size: 1.2rem;
  }
}

@keyframes glow-pulse {
  0% {
    filter:
      drop-shadow(0 0 1px #0ff)
      drop-shadow(0 0 0px #0ff9)
      drop-shadow(0 0 0px #0ff8);
  }
  100% {
    filter:
      drop-shadow(0 0 0px #00f6ff)
      drop-shadow(0 0 0px #14ffff)
      drop-shadow(0 0 10px #1cfff7);
  }
}

#thorspace-logo {
    width: 550px;
    max-width: 80vw;
    height: auto;
    margin-bottom: -94px;
  filter: drop-shadow(0 0 28px #0ff5);
  /* Adapte outros efeitos se quiser */
}

.nave-card {
  background: rgba(0, 165, 242, 0.07);
  border: 2px solid #0ff;
  border-radius: 20px;
  padding: 24px;
  width: 200px;
  text-align: center;
  box-shadow: 0 0 20px #0ff5;
  backdrop-filter: blur(14px);
  -webkit-backdrop-filter: blur(14px);
  cursor: pointer;
  transition: transform 0.3s, box-shadow 0.3s;
  position: relative; /* importante */
  overflow: visible; /* antes estava hidden */
  z-index: 1;
}
.nave-card:hover {
  transform: scale(1.06);
}
.nave-card:hover {
  z-index: 10;
  position: relative;
}


.nave-img {
  width: 170px;
  margin-top: -70px; /* Subida sutil */
  margin-bottom: 12px;
  transition: transform 0.3s ease;
  z-index: 5;
  position: relative;
}

.nave-card:hover > .nave-img {
  transform: scale(1.12);
}




.bar-label {
  font-family: 'Orbitron', sans-serif;
  color: #fff;
  margin-top: 6px;
  font-size: 14px;
  letter-spacing: 1px;
}
.bar-container {
  background: rgba(255,255,255,0.08);
  border-radius: 6px;
  height: 10px;
  margin: 4px 0 12px;
  overflow: hidden;
}
.bar {
  height: 100%;
  background: linear-gradient(to right, #0ff, #14ffff);
}

.remove-icon {
  position: absolute;
  top: -10px;
  right: -10px;
  background: #0ff;
  color: #000;
  border-radius: 50%;
  width: 22px;
  height: 22px;
  text-align: center;
  line-height: 22px;
  font-size: 14px;
  font-weight: bold;
  cursor: pointer;
  display: none;
  box-shadow: 0 0 8px #0ff8;
}
#previewArea div:hover .remove-icon {
  display: none;
}

#previewArea div:hover img:not([src*="placeholder"]) + .remove-icon {
  display: block;
}

.nave-description {
  margin-top: 14px;
  color: #0ff;
  font-family: 'Orbitron', sans-serif;
  font-size: 14px;
  line-height: 1.4;
  opacity: 0;
  max-height: 0;
  overflow: hidden;
  transition: opacity 0.4s ease, max-height 0.4s ease;
}

.nave-description {
  pointer-events: none;
}

.nave-card:hover .nave-description {
  opacity: 1;
  max-height: 120px;
  pointer-events: auto;
  position: relative;
  z-index: 2;
}

#loadingScreen {
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  background: #000;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 5000;
}

#loadingLogo {
  width: 340px;
  filter: drop-shadow(0 0 12px #0ff);
  margin-bottom: 32px;
}

#loadingBarWrapper {
  width: 60vw;
  max-width: 480px;
  height: 16px;
  background: #022b35;
  border: 1px solid #0ff4;
  border-radius: 20px;
  overflow: hidden;
  box-shadow: 0 0 20px #0ff3;
}

#loadingBar {
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg, #07d8ff, #005ea8);
  box-shadow: 0 0 12px #0ff;
  transition: width 0.2s ease-out;
}

#matchmakingScreen {
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  background: rgba(0, 0, 0, 0.85);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 3000;
  font-family: 'Orbitron', sans-serif;
  color: #0ff;
  backdrop-filter: blur(12px) brightness(1.3);
}

#matchmakingBox {
  background: rgba(0, 20, 30, 0.3);
  border: 2px solid #00a5f2;
  border-radius: 20px;
  padding: 40px 50px;
  box-shadow: 0 0 24px #0ff6;
  text-align: center;
  animation: pulse 2s infinite ease-in-out;
}

#searchStatus {
  font-size: 28px;
  margin-bottom: 32px;
  text-shadow: 0 0 8px #0ff8;
}

#rollingNames {
  font-size: 24px;
  color: #14ffff;
  opacity: 0.8;
  animation: scrollNames 3s linear infinite;
  white-space: nowrap;
  overflow: hidden;
  width: 320px;
  text-overflow: ellipsis;
  text-align: center;
}

@keyframes scrollNames {
  0% { transform: translateX(100%); }
  100% { transform: translateX(-100%); }
}

@keyframes pulse {
  0%, 100% {
    box-shadow: 0 0 20px #0ff2, 0 0 40px #0ff4 inset;
  }
  50% {
    box-shadow: 0 0 40px #14ffff, 0 0 60px #14ffff inset;
  }
}

@keyframes blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.3; }
}

@keyframes slideNames {
  0% { transform: translateX(100%); }
  100% { transform: translateX(-100%); }
}

#multiplayerBtn {
  padding: 12px 24px;
  font-size: 16px;
  margin-top: 14px;
  background: #021d33;
  color: #0ff;
  border: 2px solid #0ff6;
  cursor: pointer;
  border-radius: 12px;
  transition: 0.3s;
}
#multiplayerBtn:hover {
  background: #0ff2;
}


.mode-btn {
  padding: 12px 30px;
  font-family: 'Orbitron', sans-serif;
  font-size: 16px;
  border-radius: 10px;
  border: none;
  margin: 10px 0;
  box-shadow: 0 0 20px #0ff5;
  transition: background 0.3s, color 0.3s;
  width: 240px;
  text-align: center;
}
.mode-btn:disabled {
  background: #222;
  color: #666;
  border: 2px solid #444;
  cursor: not-allowed;
  box-shadow: 0 0 12px #0004;
}
#practiceBtn.mode-btn {
  background: linear-gradient(90deg, #07d8ff, #005ea8);
  color: #0ff;
}
#multiplayerBtn.mode-btn {
  background: linear-gradient(90deg, #ff0a94, #5f00ff);
  color: #0ff;
}

.match-vs-box {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 40px;
  height: 100vh;
  font-family: 'Orbitron', sans-serif;
  background: rgba(0,0,0,0.88);
  backdrop-filter: blur(16px);
}

.player-box, .opponent-box {
  width: 240px;
  height: 200px;
  padding: 20px;
  border-radius: 20px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  position: relative;
}

.player-box {
  background: linear-gradient(90deg, #002244, #005ea8);
  box-shadow: 0 0 16px #0ff8;
}

.opponent-box {
  background: linear-gradient(90deg, #440000, #880022);
  box-shadow: 0 0 16px #ff3866;
}

.team-label {
  color: #0ff;
  font-size: 18px;
  margin-bottom: 12px;
  text-shadow: 0 0 8px #0ff8;
}

.team-label.red {
  color: #ff5b6e;
  text-shadow: 0 0 8px #ff3866;
}

.team-score {
  font-size: 42px;
  font-weight: bold;
  color: #fff;
  text-shadow: 0 0 16px #0ff;
}

.slot-wrapper {
  width: 160px;
  height: 42px;
  overflow: hidden;
  position: relative;
  border: 2px solid #ff3866;
  border-radius: 8px;
  background: rgba(0,0,0,0.3);
}

.slot-names {
  display: flex;
  flex-direction: column;
  animation: spinNames 2s ease-in-out infinite;
}

.slot-names div {
  height: 42px;
  line-height: 42px;
  font-size: 22px;
  color: #fff;
  text-align: center;
}


@keyframes spinNames {
  0% { transform: translateY(0); }
  100% { transform: translateY(-294px); } /* 7 passos √ó 42px = 294px */
}


.match-container {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 40px;
  background: rgba(0, 0, 0, 0.6);
  padding: 40px;
  border-radius: 20px;
  box-shadow: 0 0 40px #0ff4;
  z-index: 9999;
}

.player-slot {
  display: flex;
  flex-direction: column;
  align-items: center;
  min-width: 180px;
  padding: 24px;
  border-radius: 12px;
  font-family: 'Orbitron', sans-serif;
  text-align: center;
  box-shadow: 0 0 20px #0ff4;
}

.player1 {
  background: linear-gradient(90deg, #0ff, #0044ff);
  color: #000;
}

.player2 {
  background: linear-gradient(90deg, #ff0033, #8f0022);
  color: #fff;
}

.player-title {
  font-size: 18px;
  margin-bottom: 12px;
  text-shadow: 0 0 4px #000;
}

.player-name,
.opponent-names {
  font-size: 24px;
  height: 32px;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
}

.opponent-names > div {
  animation: spinNames 2s linear infinite;
}

@keyframes spinNames {
  0% { transform: translateY(0); }
  100% { transform: translateY(-100%); }
}

.vs-text {
  font-size: 40px;
  font-weight: bold;
  color: #fff;
  text-shadow: 0 0 10px #0ff, 0 0 20px #0ff;
}

.user-header-name,
.player-name,
#userHeaderName,
#playerSlot,
.opponent-names,
.slot-name,
.score-board
{
  text-transform: uppercase;
}

#userHeader {
    display: none;
    position: fixed;
    top: 20px;
    right: 12px;
    z-index: 9000;
    align-items: center;
    gap: 13px;
    background: rgba(12, 26, 48, 0.3);
    border-radius: 93px;
    box-shadow: 0 2px 65px #0ff6;
    padding: 10px 30px 10px 16px;
    font-family: 'Orbitron', sans-serif;
    font-size: 15px;
}

.user-header-ship {
  width: 36px;
  height: auto;
  margin-right: 7px;
}

.user-header-name {
  color: #0ff;
  font-weight: bold;
  text-transform: uppercase; /* Mant√©m sempre em mai√∫sculo */
}

#modeSelectionScreen {
    position: fixed;
    flex-direction: column;
    justify-content: center;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: transparent;
    align-items: center;
    z-index: 99999;
}

/* ===== END SCORE (HEX GRID) ===== */
.end-content{
  position: relative;
  z-index: 2;
  width: 100%;
  height: 100%;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  padding-top: 0;
  gap: 35px;
}

.end-emblem{
  margin-top: 1vh;
  font-family: 'Orbitron', sans-serif;
  font-weight: 800;
  letter-spacing: 3px;
  font-size: 22px;
  color: #ffd34f;
  text-shadow: 0 0 20px rgba(255,211,79,.35);
}
.end-emblem.defeat{ color:#ff6b6b; text-shadow:0 0 20px rgba(255,107,107,.35); }
.end-emblem.draw{ color:#c7d2ff; text-shadow:0 0 20px rgba(199,210,255,.35); }

.score-board.big{
  margin-top: 0;
  font-size: 24px;
  color:#14ffff;
  text-shadow: 0 0 18px rgba(20,255,255,.55), 0 8px 20px rgba(0,0,0,.55);
  letter-spacing: 10px;
}

/* Grid dos hex√°gonos (3 em cima, 3 embaixo) */
.score-grid{
  margin-top: 38px;
  display:grid;
  grid-template-columns: repeat(3, 137px);
  gap: 20px 22px;
  align-items:center;
  justify-content:center;
}

/* Hex shape */
.score-hex{
  width:137px;
  height:110px;
  position:relative;
  clip-path: polygon(25% 6%, 75% 6%, 98% 50%, 75% 94%, 25% 94%, 2% 50%);
  background: rgba(0,0,0,.30);
  border: 2px solid rgba(255,255,255,.10);
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  text-align:center;
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  box-shadow: 0 0 0 rgba(0,0,0,0);
}

.score-hex .hex-outline{
  position:absolute;
  inset: -2px;
  clip-path: polygon(25% 6%, 75% 6%, 98% 50%, 75% 94%, 25% 94%, 2% 50%);
  border: 2px solid rgba(255,255,255,.10);
  pointer-events:none;
}

.score-hex.active{
  border-color: rgba(20,255,255,.55);
  box-shadow: 0 0 28px rgba(20,255,255,.25);
}
.score-hex.active .hex-outline{
  border-color: rgba(20,255,255,.75);
  box-shadow: 0 0 26px rgba(20,255,255,.22) inset;
}

.score-hex.inactive{
  opacity:.38;
  filter: saturate(.75);
}

.hex-title{
  font-family:'Orbitron', sans-serif;
  font-size: 10px;
  line-height: 1.2;
  letter-spacing: 0.5px;
  color: rgba(255,255,255,.85);
  margin: 0 9px 5px 9px;
  text-shadow: 0 0 12px rgba(0,0,0,.55);
}

.hex-points{
  font-family:'Orbitron', sans-serif;
  font-size: 28px;
  letter-spacing: 1px;
  color:#ffffff;
  text-shadow: 0 0 18px rgba(20,255,255,.25);
}

.score-total{
  margin-top: 0;
  font-family:'Orbitron', sans-serif;
  font-size: 34px;
  letter-spacing: 3px;
  color:#14ffff;
  text-shadow: 0 0 18px rgba(20,255,255,.55);
}

.user-header-pts{
  margin-left: 10px;
  color:#14ffff;
  font-weight:700;
  letter-spacing:1px;
  text-shadow:0 0 12px rgba(20,255,255,.55);
}

.user-logout-btn {
  margin-left: 12px;
  background: transparent;
  border: 1px solid rgba(255,77,77,.85);
  color: #ff4d4d;
  padding: 6px 12px;
  border-radius: 18px;
  font-family: 'Orbitron', sans-serif;
  font-size: 13px;
  cursor: pointer;
  box-shadow: 0 0 12px rgba(255,77,77,.18);
  text-transform: uppercase;
}
.user-logout-btn:hover {
  box-shadow: 0 0 18px rgba(255,77,77,.35);
}


    </style>
    <link href="https://fonts.googleapis.com/css?family=Orbitron:wght@700" rel="stylesheet" />
  
  <!-- Banner central de round -->
  <div id="roundBanner" style="
    display: none;
    position: fixed;
    top: 0; left: 0; width: 100vw; height: 100vh;
    z-index: 20000;
    align-items: center; justify-content: center;
    pointer-events: none;
  ">
    <div style="
      margin: auto;
      font-family: 'Orbitron', sans-serif;
      font-size: 54px;
      color: #FFD34F;
      text-shadow: 0 0 32px #0ffb, 0 0 18px #FFD700, 0 0 8px #000;
      background: rgba(0,0,0,0.72);
      border-radius: 24px;
      padding: 38px 64px;
      box-shadow: 0 0 44px #FFD70044;
      letter-spacing: 2.5px;
      text-align: center;
      min-width: 340px;
      max-width: 90vw;
      user-select: none;
    " id="roundBannerText"></div>
  </div>


</head>
<body>
    <!-- Header removed: parent app renders a single UserHeader in the protected layout -->

  <!-- üåå FUNDO DA GAL√ÅXIA (sempre no topo e no fundo visual) -->
  <div id="galaxyBg"></div>

  <!-- ‚è≥ TELA DE LOADING -->
  <div id="loadingScreen" style="display:flex;">
    <img src="images/thorspace.png" id="loadingLogo" alt="Logo" />
    <div id="loadingBarWrapper">
      <div id="loadingBar"></div>
    </div>
  </div>

  <!-- üîê TELA DE LOGIN -->
  <div id="startContainer" style="display:none;">
    <img id="thorspace-logo" src="images/thorspace.png" alt="ThorSpace Logo" />
    
    <div id="startModal">
      <div class="modal-content">
        <label for="playerNameInput">Enter your name:</label>
        <input type="text" id="playerNameInput" maxlength="16" autocomplete="off" />
        <button id="startBtn">Login</button>
      </div>
    </div>
  </div> <!-- ‚úÖ AQUI FECHA o startContainer -->

  <!-- üéÆ TELA DE MODOS DE JOGO ‚Äì FORA do startContainer -->
  <div id="modeSelectionScreen" style="display:none;">
    <h2 style="font-family:'Orbitron',sans-serif; color:#0ff; font-size:32px; text-shadow:0 0 16px #0ff9; margin-bottom:50px;">Escolha o modo de jogo</h2>

    <div style="display: flex; flex-direction: column; align-items: center; gap: 20px;">
    <button id="practiceBtn" class="mode-btn">Praticar</button>
    <button id="multiplayerBtn" class="mode-btn">Multiplayer</button>
    <button id="campaignBtn" class="mode-btn" disabled>Modo Campanha</button>

    </div>
  </div>

<div id="matchmakingScreen" style="display: none;">
  <div class="match-container">
    <div class="player-slot player1">
      <div class="player-name" id="playerSlot">Player 1</div>
    </div>
    <div class="vs-text">VS</div>
    <div class="player-slot player2">
      <div class="opponent-names" id="opponentNames"></div>
    </div>
  </div>
  <!-- Legenda din√¢mica -->
  <div id="matchLegend" style="margin-top:32px; font-family:'Orbitron',sans-serif; color:#0ff; font-size:1.4em; letter-spacing:1.5px; text-align:center; text-shadow:0 0 12px #00e7ffb9;"></div>
</div>



<!-- Tela de Vit√≥ria -->
<div id="victoryScreen" class="end-screen" style="display: none;">
  <img src="images/bg_victory.png" class="bg-full" alt="Victory Background">
  <div class="end-content">
    <div class="end-emblem" id="victoryText">VICTORY</div>

    <div class="score-board big"></div>

    <div class="score-details"></div>

    <div class="score-total"></div>

    <button id="restartVictory" class="end-btn">Return to Lobby</button>
  </div>
</div>

<!-- Tela de Derrota -->
<div id="defeatScreen" class="end-screen" style="display: none;">
  <img src="images/bg_defeat.png" class="bg-full" alt="Defeat Background">
  <div class="end-content">
    <div class="end-emblem defeat" id="defeatText">DEFEAT</div>

    <div class="score-board big"></div>

    <div class="score-details"></div>

    <div class="score-total"></div>

    <button id="restartDefeat" class="end-btn">Return to Lobby</button>
  </div>
</div>

<!-- Tela de Empate -->
<div id="drawScreen" class="end-screen" style="display: none;">
  <img src="images/bg_draw.png" class="bg-full" alt="Draw Background">
  <div class="end-content">
    <div class="end-emblem draw" id="drawText">DRAW</div>

    <div class="score-board big"></div>

    <div class="score-details"></div>

    <div class="score-total"></div>

    <button id="restartDraw" class="end-btn">Return to Lobby</button>
  </div>
</div>



<!-- HUD Superior: Timer e Legenda -->
<div id="gameWrapper">
 <div style="display: flex; flex-direction: column; align-items: center; gap: 0;">
  
  <div id="hudTop" style="width: 800px; margin: 0px auto 8px; position: relative; z-index: 3; user-select:none; display: flex; visibility: hidden; opacity: 0;">
    <div id="hudLine" style="display: flex; flex-direction: row; align-items: center; width: 100%;">
      <div id="timerArea">
        <span id="timerText">10</span>
      </div>
      <div id="legendArea"></div>
    </div>
  </div>
  <div id="shipTypeArea"
    style="width:800px; margin-top:10px; text-align:center; color:#fff; font-family:'Orbitron',sans-serif; font-size:18px; letter-spacing:1px; text-shadow:0 0 9px #0ff8;">
  </div>
    
  </div>
  
  <div style="position: relative; width: 800px; height: 600px;">
   <canvas id="gameCanvas" width="800" height="600"
     style="display: none; clip-path: polygon(24px 0%, 776px 0%, 800px 24px, 800px 576px, 776px 600px, 24px 600px, 0px 576px, 0px 24px);"></canvas>
   
   <!-- Frame decorativo do jogo -->
   <img id="gameContour" src="/game/images/frame_game.png" width="1120" height="750" style="position: absolute; top: -120px; left: -40px; pointer-events: none; visibility: hidden; user-select: none;" alt="" draggable="false" />
  </div>

  <!-- Banner de Matchup (apenas em multiplayer) -->
  <div id="matchupBanner" style="display: none; width: 100%; max-width: 800px; margin-top: 16px; padding: 12px 24px; border-radius: 12px; text-align: center; font-family: 'Orbitron', sans-serif; backdrop-filter: blur(10px);">
    <div style="display: flex; align-items: center; justify-content: center; gap: 16px;">
      <span id="playerNameDisplay" style="font-size: 18px; font-weight: 700; color: #00E5FF; text-shadow: 0 0 10px rgba(0, 229, 255, 0.6); letter-spacing: 1px;">Player</span>
      <span style="font-size: 14px; font-weight: 400; color: rgba(255, 255, 255, 0.5); text-transform: lowercase; letter-spacing: 2px;">vs</span>
      <span id="opponentNameDisplay" style="font-size: 18px; font-weight: 700; color: #FF4444; text-shadow: 0 0 10px rgba(255, 68, 68, 0.6); letter-spacing: 1px;">Opponent</span>
    </div>
  </div>
 </div>
</div>




<!-- Sons -->
<audio id="sfx-hit" src="sounds/sfx-hit.mp3"></audio>
<audio id="sfx-shot" src="sounds/sfx-shot.mp3"></audio>
<audio id="sfx-explode" src="sounds/sfx-explode.mp3"></audio>



<!-- Tela de Sele√ß√£o de Naves -->
<div id="naveSelectScreen" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0); backdrop-filter: blur(0px); z-index:3000; flex-direction:column; align-items:center; justify-content:flex-start; padding-top:12vh;">
  <div id="previewArea" style="display:flex; gap:38px; justify-content:center; margin-bottom:-10px;">
    <div style="position:relative;" onclick="removeNave(0)">
      <img id="preview1" src="images/placeholder_nave.png" alt="Posi√ß√£o 1" style="width:90px; height:auto; opacity:0.4; transition:opacity 0.3s;">
      <span class="remove-icon">‚úï</span>
    </div>
    <div style="position:relative;" onclick="removeNave(1)">
      <img id="preview2" src="images/placeholder_nave.png" alt="Posi√ß√£o 2" style="width:90px; height:auto; opacity:0.4; transition:opacity 0.3s;">
      <span class="remove-icon">‚úï</span>
    </div>
    <div style="position:relative;" onclick="removeNave(2)">
      <img id="preview3" src="images/placeholder_nave.png" alt="Posi√ß√£o 3" style="width:90px; height:auto; opacity:0.4; transition:opacity 0.3s;">
      <span class="remove-icon">‚úï</span>
    </div>
  </div>
  <div style="display: flex; align-items: center; justify-content: center; gap: 18px; margin-bottom: 70px;">
    <!-- Timer e legenda agora sempre no HUD superior (hudTop) -->
  </div>
  




 <div style="display:flex; gap:28px; justify-content:center; flex-wrap: wrap;">
  <div style="position: relative; z-index: 1;">
    <div class="nave-card" data-nave="1">
      <img src="images/nave_alcance.png" class="nave-img" alt="Nave 1">
      <div class="bar-label ship-label-range">Alcance</div>
      <div class="bar-container"><div class="bar" style="width: 95%;"></div></div>
      <div class="bar-label ship-label-protection">Prote√ß√£o</div>
      <div class="bar-container"><div class="bar" style="width: 33%;"></div></div>
      <div class="nave-description">
        <strong>Maya V1</strong><br>
        <span class="ship-desc-text" data-ship="1">Especialista em ataques de longa dist√¢ncia. Ideal para surpreender inimigos fora do alcance deles.</span>
      </div>
    </div>
  </div>

  <div style="position: relative; z-index: 1;">
    <div class="nave-card" data-nave="2">
      <img src="images/nave_protecao.png" class="nave-img" alt="Nave 2">
      <div class="bar-label ship-label-range">Alcance</div>
      <div class="bar-container"><div class="bar" style="width: 45%;"></div></div>
      <div class="bar-label ship-label-protection">Prote√ß√£o</div>
      <div class="bar-container"><div class="bar" style="width: 95%;"></div></div>
      <div class="nave-description">
        <strong>Aegis JK-05</strong><br>
        <span class="ship-desc-text" data-ship="2">Blindagem refor√ßada e resist√™ncia extrema. Perfeita para absorver dano e proteger sua frota.</span>
      </div>
    </div>
  </div>

  <div style="position: relative; z-index: 1;">
    <div class="nave-card" data-nave="3">
      <img src="images/spaceschip.png" class="nave-img" alt="Nave 3">
      <div class="bar-label ship-label-range">Alcance</div>
      <div class="bar-container"><div class="bar" style="width: 75%;"></div></div>
      <div class="bar-label ship-label-protection">Prote√ß√£o</div>
      <div class="bar-container"><div class="bar" style="width: 75%;"></div></div>
      <div class="nave-description">
        <strong>Orion-7</strong><br>
        <span class="ship-desc-text" data-ship="3">Equil√≠brio entre mobilidade e defesa. Vers√°til em qualquer situa√ß√£o de combate.</span>
      </div>
    </div>
  </div>
</div>




  <button id="startGameBtn" onclick="startGameAfterSelection()" style="display:none; margin-top:34px; background: linear-gradient(90deg, #07d8ff, #005ea8 70%); color: #fff; font-family: 'Orbitron', sans-serif; font-size: 22px; border: none; border-radius: 8px; padding: 10px 44px; letter-spacing: 2px; box-shadow: 0 0 20px #0ff5; cursor: pointer; transition: background 0.3s;">Iniciar Jogo</button>

  <!-- Timer de sele√ß√£o multiplayer -->
  <div id="selectionTimerWrapper" style="display:flex; align-items:center; justify-content:center; gap:10px; margin-top:10px;">
    <span id="selectionTimerText" style="font-family:'Orbitron',sans-serif; font-size:22px; color:#FFB84D; min-width:32px; text-align:center; letter-spacing:1px; display:inline-block; visibility:hidden;"></span>
  </div>
</div>


<script>
// ============================================
// üé® SISTEMA DE BACKGROUNDS RANDOMIZADOS
// ============================================
// Para adicionar novos fundos:
// 1. Coloque o arquivo em: public/game/images/backgrounds/
// 2. Adicione o nome do arquivo no array abaixo
// 3. Pronto! O fundo entrar√° automaticamente no sistema aleat√≥rio
const GAME_BACKGROUNDS = [
  'galaxia.png',
  'galaxia2.png',
  'galaxia3.png',
  'galaxia4.png',
  'galaxia5.png',
  // Adicione mais fundos aqui conforme necess√°rio
];

// Aplica um fundo aleat√≥rio ao canvas a cada nova partida
function applyGameBackground() {
  // Escolhe um fundo aleat√≥rio A CADA PARTIDA
  const randomBackground = GAME_BACKGROUNDS[Math.floor(Math.random() * GAME_BACKGROUNDS.length)];
  // Atualiza a imagem de fundo que √© desenhada no canvas
  if (window.backgroundGalaxy) {
    window.backgroundGalaxy.src = `images/backgrounds/${randomBackground}`;
    console.log('[BACKGROUND] Fundo aplicado:', randomBackground);
  }
}

// Detecta se o jogo est√° embedado num iframe

// Utilit√°rio AAA: Controle centralizado do HUD do jogo
function showGameHUD(timerValue, legendText) {
  const hudTop = document.getElementById('hudTop');
  const timerText = document.getElementById('timerText');
  const legendArea = document.getElementById('legendArea');
  // S√≥ mostra se a sele√ß√£o de naves N√ÉO est√° ativa
  const naveSelectScreen = document.getElementById('naveSelectScreen');
  if (naveSelectScreen && naveSelectScreen.style.display !== 'none') {
    hideGameHUD();
    return;
  }
  // LOG AAA: identificar montagem do HUD
  console.log('[HUD][showGameHUD] timerValue:', timerValue, '| legendText:', legendText, '| hudTop display:', hudTop?.style.display, '| legendArea:', legendArea?.textContent);
  if (hudTop && timerText && legendArea) {
    hudTop.style.display = 'flex';
    hudTop.style.visibility = 'visible';
    hudTop.style.opacity = '1';
    timerText.textContent = timerValue || '';
    legendArea.textContent = legendText || '';
  }
}
function hideGameHUD() {
  const hudTop = document.getElementById('hudTop');
  const timerText = document.getElementById('timerText');
  const legendArea = document.getElementById('legendArea');
  if (hudTop) {
    hudTop.style.display = 'none';
    hudTop.style.visibility = 'hidden';
    hudTop.style.opacity = '0';
  }
  if (timerText) timerText.textContent = '';
  if (legendArea) legendArea.textContent = '';
}
// --- TIMER DE SELE√á√ÉO DE NAVES AAA ---
let selectionTimer = null;
let selectionTimerInterval = null;
let selectionTimeRemaining = 15;
let selectionTimerStarted = false;
// AAA: Sempre sincronizar timer multiplayer via handleMatchUpdate
// O startSelectionTimer s√≥ √© chamado localmente em modo solo

function showSelectionTimer(seconds) {
  console.log('[TIMER] showSelectionTimer:', seconds);
  const selectionTimerText = document.getElementById('selectionTimerText');
  if (selectionTimerText) {
    selectionTimerText.textContent = seconds > 0 ? seconds : 0;
    selectionTimerText.style.color = seconds <= 5 ? '#FF4444' : '#FFB84D';
    selectionTimerText.style.visibility = 'visible';
  } else {
    console.warn('[TIMER] selectionTimerText n√£o encontrado no DOM');
  }
}
function hideSelectionTimer() {
  console.log('[TIMER] hideSelectionTimer');
  const selectionTimerText = document.getElementById('selectionTimerText');
  if (selectionTimerText) {
    selectionTimerText.textContent = '';
    selectionTimerText.style.visibility = 'hidden';
  } else {
    console.warn('[TIMER] selectionTimerText n√£o encontrado no DOM');
  }
}

function startSelectionTimer() {
  if (!multiplayerMode || !matchData) {
    // Solo: fallback para timer local
    console.log('[TIMER][SOLO] startSelectionTimer called');
    cancelSelectionTimer();
    selectionTimerStarted = true;
    selectionTimeRemaining = 15;
    showSelectionTimer(selectionTimeRemaining);
    selectionTimerInterval = setInterval(() => {
      selectionTimeRemaining--;
      showSelectionTimer(selectionTimeRemaining);
      if (selectionTimeRemaining <= 0) {
        clearInterval(selectionTimerInterval);
        selectionTimerInterval = null;
      }
    }, 1000);
    selectionTimer = setTimeout(async () => {
      if (!selectedNaves || selectedNaves.length < 3) {
        selectedNaves = [1, 1, 1];
        updatePreviews();
      }
      await saveShipSelection();
      updatePhaseAndStartBattle();
    }, 15000);
    return;
  }
  // Multiplayer: usar countdown_started_at do banco
  const startedAt = matchData.countdown_started_at ? new Date(matchData.countdown_started_at).getTime() : null;
  const now = Date.now();
  let secondsElapsed = startedAt ? Math.floor((now - startedAt) / 1000) : 0;
  let secondsLeft = 15 - secondsElapsed;
  if (secondsLeft < 0) secondsLeft = 0;
  cancelSelectionTimer();
  selectionTimerStarted = true;
  selectionTimeRemaining = secondsLeft;
  showSelectionTimer(secondsLeft);
  if (selectionTimerInterval) clearInterval(selectionTimerInterval);
  selectionTimerInterval = setInterval(() => {
    selectionTimeRemaining--;
    showSelectionTimer(selectionTimeRemaining);
    if (selectionTimeRemaining <= 0) {
      clearInterval(selectionTimerInterval);
      selectionTimerInterval = null;
    }
  }, 1000);
  if (selectionTimer) clearTimeout(selectionTimer);
  selectionTimer = setTimeout(async () => {
    if (!selectedNaves || selectedNaves.length < 3) {
      selectedNaves = [1, 1, 1];
      updatePreviews();
    }
    await saveShipSelection();
    updatePhaseAndStartBattle();
  }, secondsLeft * 1000);
}

function cancelSelectionTimer() {
  console.log('[TIMER] cancelSelectionTimer called');
  if (selectionTimer) {
    clearTimeout(selectionTimer);
    selectionTimer = null;
    console.log('[TIMER] selectionTimer timeout limpo');
  }
  if (selectionTimerInterval) {
    clearInterval(selectionTimerInterval);
    selectionTimerInterval = null;
    console.log('[TIMER] selectionTimerInterval limpo');
  }
  hideSelectionTimer();
  selectionTimerStarted = false;
}

// Fun√ß√£o para mostrar o banner central de round
function showRoundBanner(roundNumber) {
  const banner = document.getElementById('roundBanner');
  const bannerText = document.getElementById('roundBannerText');
  if (!banner || !bannerText) return;
  // Always reset to the original style for every round (canvas style)
  banner.style.display = 'flex';
  banner.style.position = 'fixed';
  banner.style.top = '0';
  banner.style.left = '0';
  banner.style.width = '100vw';
  banner.style.height = '100vh';
  banner.style.zIndex = '20000';
  banner.style.alignItems = 'center';
  banner.style.justifyContent = 'center';
  banner.style.pointerEvents = 'none';

  // Remove all extra background, border, shadow, gold, yellow, etc.
  bannerText.style.margin = 'auto';
  bannerText.style.fontFamily = "'Orbitron', sans-serif";
  bannerText.style.fontWeight = 'bold';
  bannerText.style.fontSize = '60px';
  bannerText.style.color = '#fff';
  bannerText.style.textShadow = '0 0 0 #000, 0 0 0 #FFD700, 0 0 0 #0ffb';
  bannerText.style.background = 'none';
  bannerText.style.borderRadius = '0';
  bannerText.style.padding = '0';
  bannerText.style.boxShadow = 'none';
  bannerText.style.letterSpacing = '0px';
  bannerText.style.textAlign = 'center';
  bannerText.style.minWidth = '0';
  bannerText.style.maxWidth = '100vw';
  bannerText.style.userSelect = 'none';

  // Add blue outline to match canvas stroke
  bannerText.style.webkitTextStroke = '4px #0ff';
  bannerText.style.textStroke = '4px #0ff';

  bannerText.innerHTML = `Round ${roundNumber}`;
  setTimeout(() => {
    banner.style.display = 'none';
  }, 1200);
}

function showSelectionTimer(seconds) {
  console.log('[TIMER] showSelectionTimer:', seconds);
  const selectionTimerText = document.getElementById('selectionTimerText');
  if (selectionTimerText) {
    selectionTimerText.textContent = seconds > 0 ? seconds : 0;
    selectionTimerText.style.color = seconds <= 5 ? '#FF4444' : '#FFB84D';
    selectionTimerText.style.visibility = 'visible';
  } else {
    console.warn('[TIMER] selectionTimerText n√£o encontrado no DOM');
  }
}
function hideSelectionTimer() {
  console.log('[TIMER] hideSelectionTimer');
  const selectionTimerText = document.getElementById('selectionTimerText');
  if (selectionTimerText) {
    selectionTimerText.textContent = '';
    selectionTimerText.style.visibility = 'hidden';
  } else {
    console.warn('[TIMER] selectionTimerText n√£o encontrado no DOM');
  }
}

function startSelectionTimer() {
  console.log('[TIMER] startSelectionTimer called');
  cancelSelectionTimer();
  selectionTimerStarted = true;
  selectionTimeRemaining = 15;
  showSelectionTimer(selectionTimeRemaining);

  selectionTimerInterval = setInterval(() => {
    selectionTimeRemaining--;
    console.log('[TIMER] Interval tick, time remaining:', selectionTimeRemaining);
    showSelectionTimer(selectionTimeRemaining);
    if (selectionTimeRemaining <= 0) {
      console.log('[TIMER] Timer chegou a zero, limpando intervalo');
      clearInterval(selectionTimerInterval);
      selectionTimerInterval = null;
    }
  }, 1000);

  selectionTimer = setTimeout(async () => {
    console.log('[TIMER] Timeout de 15s atingido');
    // Sempre auto-selecionar naves se n√£o houver 3
    if (!selectedNaves || selectedNaves.length < 3) {
      console.log('[TIMER] Menos de 3 naves, selecionando padr√£o [1,1,1]');
      selectedNaves = [1, 1, 1];
      updatePreviews();
    }
    await saveShipSelection();
    // Ap√≥s salvar, for√ßa transi√ß√£o para o jogo
    updatePhaseAndStartBattle();
  }, 15000);
}

function cancelSelectionTimer() {
  console.log('[TIMER] cancelSelectionTimer called');
  if (selectionTimer) {
    clearTimeout(selectionTimer);
    selectionTimer = null;
    console.log('[TIMER] selectionTimer timeout limpo');
  }
  if (selectionTimerInterval) {
    clearInterval(selectionTimerInterval);
    selectionTimerInterval = null;
    console.log('[TIMER] selectionTimerInterval limpo');
  }
  hideSelectionTimer();
  selectionTimerStarted = false;
}

// Atualizar tradu√ß√µes e iniciar/cancelar timer ao mostrar/esconder sele√ß√£o
const originalShowNaveSelect = showOnly;
window.showOnly = function(screenName) {
  originalShowNaveSelect(screenName);
  if (screenName === 'naveSelectScreen') {
    // AAA: Resetar locks/ready das naves do jogador ao mostrar sele√ß√£o (sempre, inclusive round 1)
    if (Array.isArray(playerNaves)) {
      playerNaves.forEach((ship, i) => {
        ship.locked = false;
        ship.ready = false;
        ship.hasOrder = false;
        if (multiplayerMode && currentTurnNumber === 1) {
          console.log('[TURN][RESET][SELECT][ROUND1][FIX] playerNave', i, 'locked/ready/hasOrder =', ship.locked, ship.ready, ship.hasOrder);
        } else {
          console.log('[TURN][RESET][SELECT][FIX] playerNave', i, 'locked/ready/hasOrder =', ship.locked, ship.ready, ship.hasOrder);
        }
      });
    }
    setTimeout(() => {
      updateUITranslations();
      if (multiplayerMode && currentPhase === 'select') {
        startSelectionTimer();
      } else {
        cancelSelectionTimer();
      }
    }, 100);
  } else {
    cancelSelectionTimer();
  }
};

const isEmbedded = (window.self !== window.top);

// Se embedado, remove completamente o header antigo do DOM para o Next.js controlar o header
if (isEmbedded) {
  const oldHeader = document.getElementById('userHeader');
  if (oldHeader) oldHeader.remove();
}

// ============================================
// TRADU√á√ïES (i18n)
// ============================================
const translations = {
  pt: {
    selectShips: 'Escolha as suas naves:',
    range: 'Alcance',
    protection: 'Prote√ß√£o',
    ready: 'Pronto!',
    startGame: 'Iniciar Jogo',
    waitingSync: 'Aguardando sincroniza√ß√£o‚Ä¶',
    ship1Desc: 'Especialista em ataques de longa dist√¢ncia. Ideal para surpreender inimigos fora do alcance deles.',
    ship2Desc: 'Blindagem refor√ßada e resist√™ncia extrema. Perfeita para absorver dano e proteger sua frota.',
    ship3Desc: 'Equil√≠brio entre mobilidade e defesa. Vers√°til em qualquer situa√ß√£o de combate.',
    victory: 'VIT√ìRIA',
    defeat: 'DERROTA',
    draw: 'EMPATE',
    practiceXpWarning: 'XP ganho neste modo n√£o afeta Ranking ou Level competitivo',
    returnToLobby: 'Retornar ao Lobby',
    buildYourTurn: 'Monte sua jogada! Voc√™ tem',
    seconds: 'segundos',
    chooseDestination: 'Escolha o destino para mover esta nave.',
    chooseTarget: 'Agora, clique para escolher o alvo do disparo.',
    attentionCommander: 'Aten√ß√£o, comandante: batalha espacial em curso!',
    enemyShips: 'Naves inimigas<br>neutralizadas',
    enemyCollision: 'Auto-colis√£o<br>inimiga',
    ownCollision: 'Colis√£o na<br>pr√≥pria frota',
    shipsDestroyed: 'Naves<br>destru√≠das',
    tripleElimination: 'Tripla<br>elimina√ß√£o',
    victoryNoLoss: 'Vit√≥ria sem<br>perdas',
    waitingOpponent: 'Aguardando',
    finishTurn: 'finalizar a jogada...',
    yourTurn: 'üöÄ Sua vez! Clique em uma nave para mover e atirar.',
    waitingOpponentShort: '‚è≥ Aguardando oponente...',
    clickShipToMove: 'Selecione uma nave',
    selectAnotherShip: 'Selecione outra nave para mover.',
    nextTurn: 'Selecione uma nave',
    logout: 'Sair',
    searchingOpponent: 'Procurando oponente...',
    opponentFound: 'Oponente encontrado, prepare-se para a batalha!',
    won: 'Venceu!'
  },
  en: {
    selectShips: 'Select your ships:',
    range: 'Range',
    protection: 'Protection',
    ready: 'Ready!',
    startGame: 'Start Game',
    waitingSync: 'Waiting for sync‚Ä¶',
    ship1Desc: 'Long-range attack specialist. Ideal for surprising enemies out of their reach.',
    ship2Desc: 'Reinforced armor and extreme endurance. Perfect for absorbing damage and protecting your fleet.',
    ship3Desc: 'Balance between mobility and defense. Versatile in any combat situation.',
    victory: 'VICTORY',
    defeat: 'DEFEAT',
    draw: 'DRAW',
    practiceXpWarning: 'XP earned in this mode does not affect Ranking or Competitive Level',
    returnToLobby: 'Return to Lobby',
    buildYourTurn: 'Build your turn! You have',
    seconds: 'seconds',
    chooseDestination: 'Choose the destination to move this ship.',
    chooseTarget: 'Now, click to choose the firing target.',
    attentionCommander: 'Attention, commander: space battle in progress!',
    enemyShips: 'Enemy ships<br>neutralized',
    enemyCollision: 'Enemy<br>self-collision',
    ownCollision: 'Collision in<br>own fleet',
    shipsDestroyed: 'Ships<br>destroyed',
    tripleElimination: 'Triple<br>elimination',
    victoryNoLoss: 'Victory without<br>losses',
    waitingOpponent: 'Waiting for',
    finishTurn: 'to finish turn...',
    yourTurn: 'üöÄ Your turn! Click a ship to move and fire.',
    waitingOpponentShort: '‚è≥ Waiting for opponent...',
    clickShipToMove: 'Select a ship',
    selectAnotherShip: 'Select another ship to move.',
    nextTurn: 'Select a ship',
    logout: 'Logout',
    searchingOpponent: 'Searching for opponent...',
    opponentFound: 'Opponent found, prepare for battle!',
    won: 'Won!'
  },
  es: {
    selectShips: 'Elige tus naves:',
    range: 'Alcance',
    protection: 'Protecci√≥n',
    ready: '¬°Listo!',
    startGame: 'Iniciar Juego',
    waitingSync: 'Esperando sincronizaci√≥n‚Ä¶',
    ship1Desc: 'Especialista en ataques de largo alcance. Ideal para sorprender enemigos fuera de su alcance.',
    ship2Desc: 'Blindaje reforzado y resistencia extrema. Perfecta para absorber da√±o y proteger tu flota.',
    ship3Desc: 'Equilibrio entre movilidad y defensa. Vers√°til en cualquier situaci√≥n de combate.',
    victory: 'VICTORIA',
    defeat: 'DERROTA',
    draw: 'EMPATE',
    practiceXpWarning: 'El XP ganado en este modo no afecta el Ranking ni el Nivel competitivo',
    returnToLobby: 'Volver al Lobby',
    buildYourTurn: '¬°Construye tu turno! Tienes',
    seconds: 'segundos',
    chooseDestination: 'Elige el destino para mover esta nave.',
    chooseTarget: 'Ahora, haz clic para elegir el objetivo de disparo.',
    attentionCommander: '¬°Atenci√≥n, comandante: batalla espacial en curso!',
    enemyShips: 'Naves enemigas<br>neutralizadas',
    enemyCollision: 'Auto-colisi√≥n<br>enemiga',
    ownCollision: 'Colisi√≥n en<br>propia flota',
    shipsDestroyed: 'Naves<br>destruidas',
    tripleElimination: 'Triple<br>eliminaci√≥n',
    victoryNoLoss: 'Victoria sin<br>p√©rdidas',
    waitingOpponent: 'Esperando a',
    finishTurn: 'que termine su turno...',
    yourTurn: 'üöÄ ¬°Tu turno! Haz clic en una nave para mover y disparar.',
    waitingOpponentShort: '‚è≥ Esperando al oponente...',
    clickShipToMove: 'Selecciona una nave',
    yourTurn: 'Selecciona una nave',
    selectAnotherShip: 'Selecciona otra nave para mover.',
    nextTurn: 'Selecciona una nave',
    logout: 'Cerrar sesi√≥n',
    searchingOpponent: 'Buscando oponente...',
    opponentFound: '¬°Oponente encontrado, prep√°rate para la batalla!',
    won: '¬°Gan√≥!'
  }
};

function getLanguage() {
  try {
    const settings = localStorage.getItem('thor_settings_v1');
    if (settings) {
      return JSON.parse(settings)?.ui?.language || 'pt';
    }
  } catch (e) {
    return 'pt';
  }
  return 'pt';
}

function t(key) {
  const lang = getLanguage();
  return translations[lang]?.[key] || translations.pt[key] || key;
}

// ============================================
// PLAYER DATA (recebido via postMessage)
// ============================================
window.THOR_PLAYER = null; // { userId, username, matchId }

// ============================================
// MULTIPLAYER REAL (PVP) - Configura√ß√£o
// ============================================
let multiplayerMode = false; // true se for PVP real
let myTeam = null; // 'blue' ou 'red'
let myUserId = null;
let opponentUserId = null;
let opponentUsername = "Oponente";
let matchData = null;

// Sistema de Turnos
let matchStateChannel = null;
let matchEventsChannel = null; // Canal para eventos de a√ß√µes (tiros/movimento)
let currentPhase = 'select'; // select | battle | finished
let isMyTurn = false;
let waitingForOpponent = false;
let supabaseClient = null;

// Sistema de heartbeat para detectar desconex√£o
let heartbeatInterval = null;
let opponentLastSeenCheck = null;

// IDs dos jogadores (determin√≠stico via DB)
let player1_id = null; // UUID do player 1 (BLUE)
let player2_id = null; // UUID do player 2 (RED)

// Turnos baseados em user_id (determin√≠stico)
let currentTurnNumber = 1;
let turnUserId = null; // UUID de quem tem o turno atual
let turnDeadline = null; // Date object do deadline do turno
let turnTimer = null; // setTimeout para deadline
let turnTimerInterval = null; // setInterval para countdown visual
let isResolvingTurn = false; // Guard para evitar resolu√ß√£o duplicada
let turnTimeRemaining = 15; // segundos restantes
let myActionSubmitted = false; // se eu j√° enviei minha a√ß√£o
let myPendingAction = null; // a√ß√£o que estou montando localmente
let turnWindowActive = false; // se a janela de 15s est√° ativa
let waitingForTurnResolution = false; // se estou aguardando resolu√ß√£o ap√≥s enviar

// PVP State Object (evita duplica√ß√µes de vari√°veis)
const PVP = {
  hasInitialized: false,
  hasSavedSelection: false,
  battleStarted: false,
  selectionTimer: null,
  selectionTimerStarted: false,
  selectionTimerInterval: null,
  selectionTimeRemaining: 15,
  opponentUsernameCache: new Map(),
  usernameErrorLogged: new Set()
};

// Backward compatibility aliases (deprecated - use PVP.* instead)
const usernameCache = PVP.opponentUsernameCache;
const usernameErrorLogged = PVP.usernameErrorLogged;

// Sincroniza√ß√£o Realtime (broadcast - deprecated, usar match state)
let syncChannel = null;
let lastSyncTime = 0;
const SYNC_INTERVAL = 100; // ms
let remotePlayerLastSeen = 0;
let remotePlayerConnected = true;

// ===============================
// AAA: Multiplayer Interactive Phase Guard
// ===============================
function ensurePvpInteractivePhase(context) {
  try {
    if (!multiplayerMode) return;
    // Only force phase to 'select' if it's not already interactive
    if (typeof phase !== 'undefined' && phase !== 'select') {
      console.log('[PVP][PHASE][GUARD] For√ßando phase="select" no in√≠cio do turno multiplayer. Contexto:', context, '| phase antes:', phase);
      phase = 'select';
    }
    if (typeof currentPhase !== 'undefined' && currentPhase !== 'select') {
      console.log('[PVP][PHASE][GUARD] For√ßando currentPhase="select" no in√≠cio do turno multiplayer. Contexto:', context, '| currentPhase antes:', currentPhase);
      currentPhase = 'select';
    }
  } catch (err) {
    console.error('[PVP][PHASE][GUARD] Erro ao garantir phase select:', err);
  }
}

// Iniciar janela de turno (15s simult√¢neos)
function startTurnWindow(deadlineISO) {
  // Garantir que roundLocked est√° destravado no in√≠cio de cada round
  roundLocked = false;
  console.log('[LOCK] roundLocked destravado no startTurnWindow');
  // AAA: Garantir fase interativa no multiplayer
  ensurePvpInteractivePhase('startTurnWindow');


  if (!multiplayerMode) {
    console.log("[TURN] N√£o √© multiplayer, ignorando startTurnWindow");
    return;
  }

  // Exibir banner de round sempre que iniciar um novo turno (exceto o primeiro)
  if (typeof showRoundBanner === 'function' && currentTurnNumber > 1) {
    showRoundBanner(currentTurnNumber);
  }
  
  // GUARD: Se √© o mesmo deadline, ignorar (j√° est√° rodando)
  if (window.__currentTurnDeadline === deadlineISO) {
    console.log('[TURN] ‚ö†Ô∏è Mesmo deadline j√° est√° ativo, ignorando:', deadlineISO);
    return;
  }
  
  // GUARD FORTE: Prevenir m√∫ltiplas chamadas simult√¢neas com debounce
  const now = Date.now();
  if (window.__lastTurnWindowStart && (now - window.__lastTurnWindowStart) < 1000) {
    console.log('[TURN] ‚ö†Ô∏è startTurnWindow chamado muito rapidamente, ignorando (debounce)');
    return;
  }
  window.__lastTurnWindowStart = now;
  
  // Armazenar deadline atual
  window.__currentTurnDeadline = deadlineISO;

  // =========================
  // AAA: RESET DO NOVO ROUND
  // =========================

  // 1) Destravar input do setup do round
  inputLocked = false;

  // 2) MUITO IMPORTANTE: zerar sele√ß√£o do round (sen√£o Round 2 fica travado)
  selectedNaves = [];
  // [TURN][RESET] Resetando locks/ready das naves do jogador
  if (Array.isArray(playerNaves)) {
    playerNaves.forEach((ship, i) => {
      ship.locked = false;
      ship.ready = false;
      ship.hasOrder = false;
      console.log('[TURN][RESET] playerNave', i, 'locked/ready/hasOrder =', ship.locked, ship.ready, ship.hasOrder);
    });
  }

  // 3) Resetar flags relacionadas ao setup (se existirem)
  if (window.PVP) {
    PVP.selectionComplete = false;

    // Se voc√™ tiver essas flags no seu PVP, √© seguro resetar aqui:
    if ("localTurnSubmitted" in PVP) PVP.localTurnSubmitted = false;
    if ("waitingOpponent" in PVP) PVP.waitingOpponent = false;
  }
  
  // Limpar timer global se existir
  if (window.__activeTurnTimer) {
    console.log('[TURN] ‚ö†Ô∏è Limpando timer global existente');
    clearInterval(window.__activeTurnTimer);
    window.__activeTurnTimer = null;
  }
  
  // GUARD: Se j√° existe um timer ativo, limpar antes de criar novo
  if (turnTimerInterval) {
    console.log('[TURN] ‚ö†Ô∏è Timer j√° existe, limpando antes de criar novo');
    clearInterval(turnTimerInterval);
    turnTimerInterval = null;
  }
  
  if (turnTimer) {
    clearTimeout(turnTimer);
    turnTimer = null;
  }
  
  // Resetar flags do turno anterior
  myActionSubmitted = false;
  waitingForTurnResolution = false;
  window.__lastAppliedTurnKey = null; // Limpar guard de aplica√ß√£o
  
  console.log('[TURN] ========================================');
  console.log('[TURN] Iniciando janela de turno #' + currentTurnNumber);
  console.log('[TURN] Deadline:', deadlineISO);
  
  // Parse deadline do servidor
  turnDeadline = deadlineISO ? new Date(deadlineISO) : new Date(Date.now() + 15000);
  turnWindowActive = true;
  myActionSubmitted = false;
  myPendingAction = null;
  waitingForTurnResolution = false;
  
  // Calcular tempo restante (reusar vari√°vel now do debounce)
  const deadlineMs = turnDeadline.getTime();
  const remainingMs = Math.max(0, deadlineMs - now);
  turnTimeRemaining = Math.ceil(remainingMs / 1000);
  
  console.log('[TURN] Tempo restante:', turnTimeRemaining + 's');
  
  // Mostrar timer visual
  const timerText = document.getElementById('timerText');
  const legendArea = document.getElementById('legendArea');
  const hudTop = document.getElementById('hudTop');
  
  if (timerText && hudTop) {
    hudTop.style.display = 'flex';
    hudTop.style.visibility = 'visible';
    hudTop.style.opacity = '1';
    timerText.textContent = turnTimeRemaining;
    timerText.style.color = '#00D4FF';
  }
  
  // Countdown visual (atualiza a cada segundo)
  // Armazenar o deadlineISO original para recalcular em cada itera√ß√£o
  const deadlineISOStored = deadlineISO;
  
  // GUARD FORTE: Garantir que s√≥ um interval est√° ativo por vez
  if (window.__activeTurnTimer) {
    console.log('[TURN] ‚ö†Ô∏è J√° existe um timer global ativo, limpando...');
    clearInterval(window.__activeTurnTimer);
    window.__activeTurnTimer = null;
  }
  
  turnTimerInterval = setInterval(() => {
    // Recalcular deadline a partir do ISO string em cada itera√ß√£o
    // para garantir que n√£o haja problemas de sincroniza√ß√£o
    const now = Date.now();
    const deadline = new Date(deadlineISOStored);
    const deadlineMs = deadline.getTime();
    const remainingMs = Math.max(0, deadlineMs - now);
    turnTimeRemaining = Math.ceil(remainingMs / 1000);
    
    if (timerText) {
      timerText.textContent = turnTimeRemaining;
      
      // Mudar cor nos √∫ltimos 5s
      if (turnTimeRemaining <= 5) {
        timerText.style.color = '#FF4444';
      }
    }
    
    if (turnTimeRemaining <= 0) {
      clearInterval(turnTimerInterval);
      turnTimerInterval = null;
      window.__activeTurnTimer = null; // Limpar refer√™ncia global
    }
  }, 1000);
  
  // Registrar o timer globalmente
  window.__activeTurnTimer = turnTimerInterval;
  console.log('[TURN] ‚úÖ Timer registrado globalmente');
  
  // Timer principal para deadline
  const timeoutMs = Math.max(0, remainingMs);
  turnTimer = setTimeout(() => {
    console.log('[TURN] ‚è∞ Deadline atingido!');
    console.log('[TURN] myUserId:', myUserId);
    console.log('[TURN] matchData.player1_id:', matchData?.player1_id);
    const isPlayer1 = myUserId === matchData?.player1_id;
    console.log('[TURN] Sou Player 1 (host)?', isPlayer1);
    
    // Limpar sele√ß√£o de nave quando tempo acaba
    selectedNave = null;
    isInteracting = false;
    // Se ainda n√£o enviei, enviar a√ß√£o idle
    if (!myActionSubmitted) {
      console.log('[TURN] Auto-enviando a√ß√£o idle (timeout)');
      submitMyAction({ type: 'idle' });
    } else {
      console.log('[TURN] J√° havia enviado a√ß√£o antes do timeout.');
    }
    // Tentar resolver turno repetidamente at√© sucesso (m√°x 5 tentativas)
    // APENAS Player 1 (host) resolve turnos (vari√°vel j√° declarada acima)
    if (isPlayer1) {
      console.log('[TURN] üî¥ Player 1 iniciando loop de resolu√ß√£o ap√≥s timeout');
      let resolveAttempts = 0;
      function tryResolveLoop() {
        resolveAttempts++;
        console.log(`[TURN] [TIMEOUT] Player 1 tentando resolver turno, tentativa #${resolveAttempts}`);
        maybeResolveTurn();
        if (resolveAttempts < 5 && phase !== 'wait') {
          setTimeout(tryResolveLoop, 700);
        } else if (phase === 'wait') {
          console.log('[TURN] [TIMEOUT] Turno resolvido com sucesso ap√≥s timeout.');
        } else {
          console.warn('[TURN] [TIMEOUT] Player 1 n√£o conseguiu resolver turno ap√≥s 5 tentativas.');
        }
      }
      tryResolveLoop();
    } else {
      console.log('[TURN] üîµ Player 2 aguardando Player 1 resolver via Realtime (timeout)');
    }
  }, timeoutMs + 500);
  
  console.log('[TURN] ========================================');
}

// Enviar minha a√ß√£o do turno
async function submitMyAction(actionPayload) {
  if (!multiplayerMode || !supabaseClient || !matchData || myActionSubmitted) {
    console.log('[TURN] N√£o pode enviar a√ß√£o:', {
      multiplayerMode,
      supabaseClient: !!supabaseClient,
      matchData: !!matchData,
      myActionSubmitted
    });
    return false;
  }
  
  console.log('[TURN] ========================================');
  console.log('[TURN] Enviando a√ß√£o do turno #' + currentTurnNumber);
  console.log('[TURN] Meu time:', myTeam);
  console.log('[TURN] A√ß√£o:', actionPayload);
  
  try {
    const updateData = {};
    
    if (myTeam === 'blue') {
      updateData.action_blue = actionPayload;
      updateData.submitted_blue = true;
    } else {
      updateData.action_red = actionPayload;
      updateData.submitted_red = true;
    }
    
    console.log('[TURN] Salvando a√ß√£o em action_' + myTeam);
    console.log('[TURN] Update data:', JSON.stringify(updateData));
    
    const { error } = await supabaseClient
      .from('matches')
      .update(updateData)
      .eq('id', matchData.id);
    
    if (error) {
      console.error('[TURN] ‚ùå Erro ao enviar a√ß√£o:', error);
      return false;
    }
    
    console.log('[TURN] ‚úÖ A√ß√£o salva no banco de dados');
    console.log('[TURN] Campo usado: action_' + myTeam);
    console.log('[TURN] Payload:', JSON.stringify(actionPayload));
    
    myActionSubmitted = true;
    waitingForTurnResolution = true;

    // Travar todas as naves at√© o pr√≥ximo round
    if (playerNaves) playerNaves.forEach(n => n.locked = true);

    console.log('[TURN] ‚úÖ A√ß√£o enviada com sucesso');

    // Travar UI e mostrar "Aguardando oponente..."
    const legendArea = document.getElementById('legendArea');
    if (legendArea) {
      legendArea.textContent = t('waitingOpponent') + ' ' + opponentUsername + ' ' + t('finishTurn');
      legendArea.style.color = '#FFB84D';
    }

    // Removido: banner central de aguarde. S√≥ usar legendArea no HUD.

    // Cancelar timers de countdown (mas n√£o o timer principal)
    if (turnTimerInterval) {
      clearInterval(turnTimerInterval);
      turnTimerInterval = null;
    }

    // Tentar resolver turno agora (se ambos j√° enviaram)
    console.log('[TURN] Verificando se pode resolver turno imediatamente...');
    setTimeout(() => maybeResolveTurn(), 300);

    console.log('[TURN] ========================================');
    return true;
  } catch (err) {
    console.error('[TURN] ‚ùå Exce√ß√£o ao enviar a√ß√£o:', err);
    return false;
  }
}

// Tentar resolver o turno (se ambos enviaram OU deadline passou)
async function maybeResolveTurn() {
  if (!multiplayerMode || !supabaseClient || !matchData) {
    console.log('[TURN] ‚ö†Ô∏è N√£o pode resolver:', { multiplayerMode, hasClient: !!supabaseClient, hasMatchData: !!matchData });
    return;
  }
  
  // Guard: evitar m√∫ltiplas tentativas simult√¢neas de resolu√ß√£o
  if (isResolvingTurn) {
    console.log('[TURN] ‚ö†Ô∏è J√° est√° resolvendo turno, ignorando chamada duplicada');
    return;
  }
  
  isResolvingTurn = true;
  
  console.log('[TURN] ========================================');
  console.log('[TURN] Verificando se pode resolver turno #' + currentTurnNumber);
  console.log('[TURN] matchData.id:', matchData.id);
  
  try {
    // Buscar estado atual do match
    const { data: match, error } = await supabaseClient
      .from('matches')
      .select('*')
      .eq('id', matchData.id)
      .maybeSingle();
    
    if (error || !match) {
      console.error('[TURN] Erro ao buscar match:', error);
      isResolvingTurn = false;
      return;
    }
    
    // ‚úÖ ETAPA 1: APENAS player1_id resolve turnos (evita race condition)
    // player2_id aguarda o Realtime detectar turn_resolved_at
    const isPlayer1 = myUserId === match.player1_id;
    if (!isPlayer1) {
      console.log('[TURN] üîµ Sou Player 2, aguardando Player 1 resolver turno via Realtime');
      isResolvingTurn = false;
      return;
    }
    console.log('[TURN] üî¥ Sou Player 1 (host), vou resolver o turno');
    
    // Ler a√ß√µes de action_blue/action_red
    const action_blue = match.action_blue;
    const action_red = match.action_red;
    const submitted_blue = match.submitted_blue;
    const submitted_red = match.submitted_red;
    
    console.log('[TURN] Dados brutos do banco:');
    console.log('[TURN]   - action_blue:', JSON.stringify(action_blue));
    console.log('[TURN]   - action_red:', JSON.stringify(action_red));
    console.log('[TURN]   - submitted_blue:', submitted_blue);
    console.log('[TURN]   - submitted_red:', submitted_red);
    
    const turn_resolved_at = match.turn_resolved_at;
    const turn_deadline_at = match.turn_deadline_at;
    const currentTurnInDb = match.turn_number || 1;
    
    console.log('[TURN] Estado atual:');
    console.log('[TURN]   - turn_number(db):', currentTurnInDb);
    console.log('[TURN]   - turn_resolved_at:', turn_resolved_at);
    console.log('[TURN]   - turn_deadline_at:', turn_deadline_at);
    
    // IMPORTANTE: turn_resolved_at pode referir-se ao TURNO ANTERIOR (pois incrementamos turn_number).
    // Portanto, n√£o usar turn_resolved_at como guard de "turno j√° resolvido".
    
    // Verificar se ambos enviaram
    const bothSubmitted = submitted_blue && submitted_red;
    
    // Verificar se deadline passou
    const now = new Date();
    const deadline = turn_deadline_at ? new Date(turn_deadline_at) : null;
    const deadlinePassed = deadline && now >= deadline;
    
    console.log('[TURN] bothSubmitted:', bothSubmitted);
    console.log('[TURN] deadlinePassed:', deadlinePassed);
    console.log('[TURN] now:', now.toISOString());
    console.log('[TURN] deadline:', deadline ? deadline.toISOString() : 'null');
    
    // S√≥ resolver se ambos enviaram OU deadline passou
    if (!bothSubmitted && !deadlinePassed) {
      console.log('[TURN] Aguardando... (nem ambos enviaram nem deadline passou)');
      isResolvingTurn = false;
      return;
    }
    
    console.log('[TURN] üéØ Resolvendo turno agora!');
    
    // Usar a√ß√µes diretamente ou idle se n√£o submetido
    const final_action_blue = submitted_blue ? action_blue : { type: 'idle' };
    const final_action_red = submitted_red ? action_red : { type: 'idle' };
    
    console.log('[TURN] A√ß√µes a serem aplicadas:');
    console.log('[TURN]   - final_action_blue:', JSON.stringify(final_action_blue));
    console.log('[TURN]   - final_action_red:', JSON.stringify(final_action_red));
    
    // Marcar como resolvido e avan√ßar turno
    const nextTurnNumber = currentTurnInDb + 1;
    const newDeadline = new Date(Date.now() + 15000).toISOString();
    
    // IMPORTANTE: Salvar as a√ß√µes em last_action_* ANTES de limpar
    // para que o Realtime UPDATE possa ler elas
    let updateQuery = supabaseClient
      .from('matches')
      .update({
        turn_resolved_at: new Date().toISOString(),
        turn_number: nextTurnNumber,
        turn_deadline_at: newDeadline,
        last_action_blue: final_action_blue,
        last_action_red: final_action_red,
        action_blue: null,
        action_red: null,
        submitted_blue: false,
        submitted_red: false
      })
      .eq('id', matchData.id)
      // Guard at√¥mico por turno: s√≥ um cliente consegue avan√ßar ESTE turn_number
      .eq('turn_number', currentTurnInDb);

    const { data: updateData, error: updateError } = await updateQuery.select();
    
    if (updateError) {
      console.error('[TURN] Erro ao atualizar match:', updateError);
      isResolvingTurn = false;
      return;
    }
    
    // Se n√£o retornou dados, outro cliente j√° resolveu (ou o turno j√° avan√ßou)
    if (!updateData || updateData.length === 0) {
      console.log('[TURN] ‚ö†Ô∏è Outro cliente j√° resolveu o turno (ou turn_number j√° avan√ßou)');
      isResolvingTurn = false;
      return;
    }
    
    console.log('[TURN] ‚úÖ Turno resolvido e avan√ßado para #' + nextTurnNumber);
    
    // N√ÉO aplicar a√ß√µes aqui - o Realtime vai detectar turn_resolved_at
    // e chamar applyResolvedTurn em AMBOS os clientes

    // AAA: Removido fallback local. A anima√ß√£o e tela de resultado s√≥ devem ser disparadas via evento do backend (phase=finished) pelo Realtime.

    // N√ÉO atualizar currentTurnNumber aqui - deixar o Realtime detectar e iniciar novo turno

    console.log('[TURN] ========================================');
    isResolvingTurn = false;
  } catch (err) {
    console.error('[TURN] ‚ùå Exce√ß√£o ao resolver turno:', err);
    isResolvingTurn = false;
  }
}

// Aplicar turno resolvido (executar a√ß√µes de ambos simultaneamente)
function applyResolvedTurn(actions) {
  if (!multiplayerMode) return;
  
  // Guard: prevenir m√∫ltiplas aplica√ß√µes do mesmo turno
  const turnKey = JSON.stringify(actions);
  if (window.__lastAppliedTurnKey === turnKey) {
    console.log('[TURN] ‚ö†Ô∏è Turno j√° foi aplicado, ignorando duplicata');
    return;
  }
  window.__lastAppliedTurnKey = turnKey;
  
  console.log('[TURN] ========================================')
  console.log('[TURN] üéÆ COME√áANDO applyResolvedTurn');
  console.log('[TURN] action_blue:', JSON.stringify(actions.action_blue));
  console.log('[TURN] action_red:', JSON.stringify(actions.action_red));
  console.log('[TURN] myTeam:', myTeam);
  console.log('[TURN] phase atual:', phase);
  console.log('[TURN] ‚ö†Ô∏è ESTA FUN√á√ÉO DEVE SER EXECUTADA EM AMBOS OS CLIENTES!');
  
  turnWindowActive = false;
  waitingForTurnResolution = false;
  phase = 'wait';
  
  console.log('[TURN] üéØ Phase mudou para WAIT - movimento deve come√ßar');
  
  // Determinar quais s√£o minhas a√ß√µes e quais s√£o do oponente
  const myAction = (myTeam === 'blue') ? actions.action_blue : actions.action_red;
  const oppAction = (myTeam === 'blue') ? actions.action_red : actions.action_blue;
  
  console.log('[TURN] Minha a√ß√£o (' + myTeam + '):', JSON.stringify(myAction));
  console.log('[TURN] A√ß√£o oponente:', JSON.stringify(oppAction));
  
  // Aplicar MINHAS a√ß√µes em playerNaves
  if (myAction && myAction.type === 'play' && myAction.ships) {
    console.log('[TURN] Aplicando minhas a√ß√µes em playerNaves');
    myAction.ships.forEach(shipData => {
      const nave = playerNaves[shipData.index];
      if (nave && nave.hp > 0) {
        nave.target = shipData.target;
        nave.shot = shipData.shot;
        console.log('[TURN]   - Nave #' + shipData.index + ': target=', shipData.target, 'shot=', shipData.shot);
      }
    });
  } else {
    console.log('[TURN] ‚ö†Ô∏è Minha a√ß√£o inv√°lida ou idle');
  }
  
  // Aplicar a√ß√µes do OPONENTE em cpuNaves
  if (oppAction && oppAction.type === 'play' && oppAction.ships) {
    console.log('[TURN] Aplicando a√ß√µes do oponente em cpuNaves');
    oppAction.ships.forEach(shipData => {
      const nave = cpuNaves[shipData.index];
      if (nave && nave.hp > 0) {
        nave.target = shipData.target;
        nave.shot = shipData.shot;
        // Aplicar √¢ngulo salvo pelo oponente (sem recalcular)
        if (shipData.angle !== undefined) {
          nave.angle = shipData.angle;
        }
        console.log('[TURN]   - Nave oponente #' + shipData.index + ': target=', shipData.target, 'shot=', shipData.shot, 'angle=', shipData.angle);
      }
    });
  } else {
    console.log('[TURN] ‚ö†Ô∏è A√ß√£o do oponente inv√°lida ou idle');
  }
  
  // Iniciar anima√ß√£o simult√¢nea (movimento + tiros)
  console.log('[TURN] üöÄ Iniciando anima√ß√£o de combate simult√¢neo');
  console.log('[TURN] playerNaves:', playerNaves.map(n => ({ index: playerNaves.indexOf(n), hp: n.hp, target: n.target, shot: n.shot })));
  console.log('[TURN] cpuNaves:', cpuNaves.map(n => ({ index: cpuNaves.indexOf(n), hp: n.hp, target: n.target, shot: n.shot })));
  
  fireProjectiles();
  
  // Atualizar UI
  const legendArea = document.getElementById('legendArea');
  if (legendArea) {
    legendArea.textContent = t('attentionCommander');
    legendArea.style.color = '#FFB84D';
  }
  
  console.log('[TURN] ‚úÖ A√ß√µes aplicadas e anima√ß√µes iniciadas');
  console.log('[TURN] ========================================');
}

// Sincronizar HP das naves no banco ap√≥s combate
async function syncShipsHP() {
  if (!multiplayerMode || !supabaseClient || !matchData) return;
  
  try {
    console.log('[SYNC] Sincronizando HP das naves...');
    
    // Coletar HP das minhas naves
    const myShipsHP = playerNaves.map(n => n.hp);
    
    console.log('[SYNC] Meu HP:', myShipsHP);
    console.log('[SYNC] Meu time:', myTeam);
    
    // Atualizar no banco baseado no meu time
    const updateData = {};
    if (myTeam === 'blue') {
      updateData.player1_hp = myShipsHP;
    } else {
      updateData.player2_hp = myShipsHP;
    }
    
    const { error } = await supabaseClient
      .from('matches')
      .update(updateData)
      .eq('id', matchData.id);
    
    if (error) {
      console.error('[SYNC] Erro ao sincronizar HP:', error);
      return;
    }
    
    console.log('[SYNC] ‚úÖ HP sincronizado');
  } catch (err) {
    console.error('[SYNC] Exce√ß√£o ao sincronizar HP:', err);
  }
}

// ========================================
// SISTEMA OFICIAL DE XP
// ========================================

// Defini√ß√£o dos eventos de XP
const XP_EVENTS = {
  // Eventos positivos
  DESTROY_ENEMY_SHIP: { name: 'Nave inimiga destru√≠da', xp: 25 },
  PRECISION_HIT_STREAK: { name: 'Precis√£o absoluta', xp: 20 },
  DOUBLE_KILL_ROUND: { name: 'Double Kill', xp: 40 },
  TRIPLE_KILL_ROUND: { name: 'Triple Kill', xp: 80 },
  PERFECT_ROUND: { name: 'Vit√≥ria Perfeita', xp: 30 },
  CLUTCH_KILL: { name: 'Clutch', xp: 25 },
  COMEBACK_WIN: { name: 'Virada √©pica', xp: 20 },
  MATCH_VICTORY: { name: 'Vit√≥ria', xp: 30 },
  MATCH_DRAW: { name: 'Empate', xp: 20 },
  MATCH_DEFEAT: { name: 'Derrota', xp: 0 },
  
  // Eventos negativos (agora valem 0 - n√£o subtraem XP)
  FRIENDLY_COLLISION: { name: 'Colis√£o com nave aliada', xp: 0 },
  ENEMY_COLLISION: { name: 'Colis√£o com nave inimiga', xp: 0 },
  LOSE_ONE_SHIP: { name: 'Nave perdida', xp: 0 },
  LOSE_TWO_SHIPS_ROUND: { name: 'Perda dupla', xp: 0 },
  LOSE_THREE_SHIPS_ROUND: { name: 'Derrota cr√≠tica', xp: 0 }
};

// Tracking de eventos por round e partida
let xpEvents = [];
let xpTotalMatch = 0;
let finalXpForChat = 0; // üéØ XP final para enviar ao chat (salvo no fim do jogo)
let xpAlreadyApplied = false; // üîí Flag para evitar aplicar XP m√∫ltiplas vezes
let roundKills = 0;
let roundLosses = 0;
let roundCollisionLosses = 0; // Perdas por colis√£o (n√£o contar para LOSE_X_SHIPS_ROUND)
let roundHitStreaks = {}; // { naveIndex: consecutiveHits }
let wasLosingBeforeRound = false;

// Registrar evento de XP
function registerXPEvent(eventKey) {
  const event = XP_EVENTS[eventKey];
  if (!event) {
    console.warn('[XP] Evento desconhecido:', eventKey);
    return;
  }
  
  xpEvents.push({ key: eventKey, name: event.name, xp: event.xp });
  xpTotalMatch += event.xp;
  
  console.log(`[XP] +${event.xp} XP - ${event.name}`);
}

// Resetar contadores de round
function resetRoundXPTracking() {
  roundKills = 0;
  roundLosses = 0;
  roundCollisionLosses = 0;
  roundHitStreaks = {};
  wasLosingBeforeRound = (cpuDestroyed - playerDestroyed) < 0;
}

// Processar eventos de round (chamado no final do round)
function processRoundXPEvents() {
  // Verificar multi-kills
  if (roundKills === 2) {
    registerXPEvent('DOUBLE_KILL_ROUND');
  } else if (roundKills === 3) {
    registerXPEvent('TRIPLE_KILL_ROUND');
  }
  
  // Verificar m√∫ltiplas perdas - valores TOTAIS, n√£o cumulativos
  if (roundLosses === 3) {
    registerXPEvent('LOSE_THREE_SHIPS_ROUND');
  } else if (roundLosses === 2) {
    registerXPEvent('LOSE_TWO_SHIPS_ROUND');
  } else if (roundLosses === 1) {
    registerXPEvent('LOSE_ONE_SHIP');
  }
  // Se roundLosses === 0, n√£o registrar nada
}

// Processar eventos de fim de partida
function processMatchEndXPEvents(result) {
  console.log('[XP] üìä processMatchEndXPEvents chamada com result:', result);
  console.log('[XP] üìä xpEvents ANTES:', JSON.parse(JSON.stringify(xpEvents)));
  console.log('[XP] üìä xpTotalMatch ANTES:', xpTotalMatch);
  
  // Resultado da partida
  if (result === 'win') {
    registerXPEvent('MATCH_VICTORY');
    
    // Verificar vit√≥ria sem perdas (Perfect Round)
    if (playerNaves.every(n => n.hp > 0)) {
      registerXPEvent('PERFECT_ROUND');
    }
    
    // Verificar comeback
    if (wasLosingBeforeRound) {
      registerXPEvent('COMEBACK_WIN');
    }
  } else if (result === 'draw') {
    registerXPEvent('MATCH_DRAW');
  } else if (result === 'defeat') {
    registerXPEvent('MATCH_DEFEAT');
    // ‚ùå DERROTA: Zerar todo o XP acumulado
    console.log('[XP] üíÄ DERROTA: Zerando XP total (era:', xpTotalMatch, ')');
    xpTotalMatch = 0;
  }
  
  console.log('[XP] üìä xpEvents DEPOIS:', JSON.parse(JSON.stringify(xpEvents)));
  console.log('[XP] üìä xpTotalMatch ANTES do CAP:', xpTotalMatch);
  
  // Aplicar CAP HARD de 450 XP e garantir que nunca seja negativo (apenas se n√£o for derrota)
  if (result !== 'defeat') {
    xpTotalMatch = Math.min(450, Math.max(0, xpTotalMatch));
  }
  console.log('[XP] üìä xpTotalMatch DEPOIS do CAP:', xpTotalMatch);
}

// Aplicar XP total ao jogador
async function applyMatchXP() {
  // üîí Bloqueia XP, vit√≥rias e progresso no modo pr√°tica
  if (!multiplayerMode) {
    console.log('[XP] ‚ö†Ô∏è Modo pr√°tica: n√£o aplica XP, vit√≥rias ou progresso.');
    return;
  }
  // üîí Evitar m√∫ltiplas execu√ß√µes
  if (xpAlreadyApplied) {
    console.log('[XP] ‚ö†Ô∏è XP j√° foi aplicado nesta partida, ignorando duplicata');
    return;
  }
  if (!supabaseClient || !myUserId) {
    console.warn('[XP] N√£o √© poss√≠vel aplicar XP - sem cliente ou userId');
    return;
  }
  if (xpTotalMatch === 0) {
    console.log('[XP] Nenhum XP para aplicar');
    return;
  }
  
  // üîí Marcar como aplicado ANTES de qualquer opera√ß√£o async
  xpAlreadyApplied = true;
  
  try {
    console.log('[XP] üöÄ IN√çCIO applyMatchXP');
    console.log('[XP] üöÄ xpTotalMatch:', xpTotalMatch);
    console.log('[XP] üöÄ xpEvents.length:', xpEvents.length);
    console.log('[XP] üöÄ xpEvents:', JSON.parse(JSON.stringify(xpEvents)));
    
    // Buscar progresso atual
    let { data: progress, error: fetchError } = await supabaseClient
      .from('player_progress')
      .select('level, xp, xp_to_next')
      .eq('user_id', myUserId)
      .maybeSingle();
    
    if (fetchError) {
      console.error('[XP] Erro ao buscar progresso:', fetchError);
      return;
    }
    
    // Se n√£o existe progresso, criar
    if (!progress) {
      const defaultProgress = {
        user_id: myUserId,
        level: 1,
        xp: 0,
        xp_to_next: 300,
        total_xp: 0
      };
      const { error: insertError } = await supabaseClient
        .from('player_progress')
        .insert(defaultProgress);
      if (insertError) {
        console.error('[XP] Erro ao criar progresso:', insertError);
        return;
      }
      progress = defaultProgress;
    }
    
    // Calcular novo XP e n√≠vel
    console.log('[XP] üîç progress recebido do DB:', JSON.parse(JSON.stringify(progress)));
    let level = progress.level || 1;
    console.log('[XP] üîç progress.xp:', progress.xp);
    console.log('[XP] üîç xpTotalMatch neste momento:', xpTotalMatch);
    let xp = (progress.xp || 0) + xpTotalMatch;
    console.log('[XP] üîç XP CALCULADO (progress.xp + xpTotalMatch):', xp);
    let xp_to_next = progress.xp_to_next || 300;
    let levelUps = 0;
    
    // XP curve: 300 * (1.25 ^ (level - 1))
    const computeXpToNext = (lvl) => Math.round(300 * Math.pow(1.25, lvl - 1));
    
    // Calcular level ups
    while (xp >= xp_to_next) {
      xp -= xp_to_next;
      level++;
      levelUps++;
      xp_to_next = computeXpToNext(level);
    }
    
    // Atualizar no banco
    const { error: updateError } = await supabaseClient
      .from('player_progress')
      .update({ level, xp, xp_to_next })
      .eq('user_id', myUserId);
    
    if (updateError) {
      console.error('[XP] Erro ao atualizar progresso:', updateError);
      return;
    }
    
    // ‚úÖ INCREMENTAR TOTAL_XP (sistema de ranks)
    console.log('[XP] üìä Incrementando total_xp via RPC:', xpTotalMatch);
    
    // üîç DEBUG: Buscar total_xp atual ANTES do incremento
    const { data: beforeData } = await supabaseClient
      .from('player_progress')
      .select('total_xp')
      .eq('user_id', myUserId)
      .single();
    console.log('[XP] üîç total_xp no DB ANTES do RPC:', beforeData?.total_xp ?? 0);
    
    try {
      const { error: rpcError } = await supabaseClient.rpc('increment_total_xp', {
        p_user_id: myUserId,
        p_xp_gain: Math.max(0, Math.floor(xpTotalMatch))
      });
      
      if (rpcError) {
        console.warn('[XP] ‚ö†Ô∏è Erro ao incrementar total_xp (n√£o cr√≠tico):', rpcError);
      } else {
        console.log('[XP] ‚úÖ total_xp incrementado com sucesso!');
        
        // üîç DEBUG: Buscar total_xp atual DEPOIS do incremento
        const { data: afterData } = await supabaseClient
          .from('player_progress')
          .select('total_xp')
          .eq('user_id', myUserId)
          .single();
        console.log('[XP] üîç total_xp no DB DEPOIS do RPC:', afterData?.total_xp ?? 0);
      }
    } catch (rpcErr) {
      console.warn('[XP] ‚ö†Ô∏è Exce√ß√£o ao incrementar total_xp:', rpcErr);
    }
    
    console.log('[XP] ‚úÖ XP aplicado:', { level, xp, xp_to_next, levelUps, xpGain: xpTotalMatch });
    
    // Disparar eventos para atualizar o header
    window.dispatchEvent(new CustomEvent('thor_progress_updated', {
      detail: { level, xp, xp_to_next }
    }));
    window.dispatchEvent(new Event('thor_match_finalized'));
    window.dispatchEvent(new Event('thor_stats_updated')); // ‚úÖ For√ßa refresh do UserHeader
    
    // Atualizar header disparando evento (legado)
    window.dispatchEvent(new CustomEvent('thor_xp_updated', {
      detail: { 
        userId: myUserId, 
        xpGain: xpTotalMatch,
        level,
        xp,
        xp_to_next,
        levelUps
      }
    }));
    
    // Postar eventos de XP no chat
    await postXPEventsToChat();
    
  } catch (err) {
    console.error('[XP] Exce√ß√£o ao aplicar XP:', err);
  }
}

// Postar eventos de XP no chat
async function postXPEventsToChat() {
  if (!supabaseClient || !myUserId || xpEvents.length === 0) return;
  
  try {
    const username = localStorage.getItem('thor_username') || 'Player';
    
    // Agrupar eventos por positivos e negativos
    const positiveEvents = xpEvents.filter(e => e.xp > 0);
    const negativeEvents = xpEvents.filter(e => e.xp < 0);
    
    // Mensagem de eventos positivos
    if (positiveEvents.length > 0) {
      const eventsList = positiveEvents.map(e => `+${e.xp} ${e.name}`).join(', ');
      const totalPositive = positiveEvents.reduce((sum, e) => sum + e.xp, 0);
      
      await supabaseClient.from('chat_messages').insert({
        user_id: myUserId,
        username: username,
        message: `üí´ ${eventsList} (Total: +${totalPositive} XP)`,
        type: 'system_xp',
        avatar: null,
        meta: {}
      });
    }
    
    // Mensagem de eventos negativos
    if (negativeEvents.length > 0) {
      const eventsList = negativeEvents.map(e => `${e.xp} ${e.name}`).join(', ');
      const totalNegative = negativeEvents.reduce((sum, e) => sum + e.xp, 0);
      
      await supabaseClient.from('chat_messages').insert({
        user_id: myUserId,
        username: username,
        message: `‚ö†Ô∏è ${eventsList} (Total: ${totalNegative} XP)`,
        type: 'system_xp',
        avatar: null,
        meta: {}
      });
    }
    
    console.log('[XP] Eventos postados no chat');
  } catch (err) {
    console.error('[XP] Erro ao postar no chat:', err);
  }
}

// Resetar sistema de XP para nova partida
function resetMatchXP() {
  xpEvents = [];
  xpTotalMatch = 0;
  xpAlreadyApplied = false; // üîì Resetar flag para nova partida
  resetRoundXPTracking();
}

// Buscar username do oponente (com cache)
async function getOpponentUsername(opponentId) {
  // Verificar cache primeiro
  if (usernameCache.has(opponentId)) {
    return usernameCache.get(opponentId);
  }
  
  try {
    const { data, error } = await supabaseClient
      .from('profiles')
      .select('username')
      .eq('id', opponentId)
      .maybeSingle();
    
    if (error) {
      // Logar erro apenas UMA vez
      if (!usernameErrorLogged.has(opponentId)) {
        console.warn('[PVP] ‚ö†Ô∏è Erro ao buscar username do oponente:', error.message);
        usernameErrorLogged.add(opponentId);
      }
      usernameCache.set(opponentId, 'Opponent');
      return 'Opponent';
    }
    
    const username = data?.username ?? 'Opponent';
    usernameCache.set(opponentId, username);
    return username;
  } catch (err) {
    if (!usernameErrorLogged.has(opponentId)) {
      console.warn('[PVP] ‚ö†Ô∏è Exce√ß√£o ao buscar username:', err.message);
      usernameErrorLogged.add(opponentId);
    }
    usernameCache.set(opponentId, 'Opponent');
    return 'Opponent';
  }
}

// Ler par√¢metros da URL com valida√ß√£o
function getUrlParams() {
  const params = new URLSearchParams(window.location.search);
  
  // UUID regex (8-4-4-4-12)
  const UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
  
  const mode = params.get('mode')?.trim() || null;
  const matchId = params.get('matchId')?.trim() || null;
  const supabaseUrl = params.get('supabaseUrl') ? decodeURIComponent(params.get('supabaseUrl')).trim() : null;
  const supabaseKey = params.get('supabaseKey') ? decodeURIComponent(params.get('supabaseKey')).trim() : null;
  const access_token = params.get('access_token') ? decodeURIComponent(params.get('access_token')).trim() : null;
  const refresh_token = params.get('refresh_token') ? decodeURIComponent(params.get('refresh_token')).trim() : null;
  const userId = params.get('userId') ? decodeURIComponent(params.get('userId')).trim() : null;
  
  // Validar matchId como UUID
  if (matchId && !UUID_REGEX.test(matchId)) {
    console.error('[URL] ‚ùå matchId inv√°lido (n√£o √© UUID):', matchId);
    return { mode, matchId: null, supabaseUrl, supabaseKey, access_token, refresh_token, userId, error: 'matchId inv√°lido' };
  }
  
  // Validar userId como UUID (se presente)
  if (userId && !UUID_REGEX.test(userId)) {
    console.error('[URL] ‚ùå userId inv√°lido (n√£o √© UUID):', userId);
    return { mode, matchId, supabaseUrl, supabaseKey, access_token, refresh_token, userId: null, error: 'userId inv√°lido' };
  }
  
  return { mode, matchId, supabaseUrl, supabaseKey, access_token, refresh_token, userId };
}

// Inicializar modo multiplayer real
async function initMultiplayerMode(matchId) {
  // ‚úÖ XP: Resetar sistema de XP para nova partida
  resetMatchXP();
  console.log('[PVP] ‚úÖ Sistema de XP resetado para nova partida');
  
  // (A1) GUARD: N√£o inicializar duas vezes para o mesmo match
  if (window.__pvpInitializedForMatchId === matchId) {
    console.log('[PVP] ‚ö†Ô∏è J√° inicializado para matchId:', matchId, '- ignorando');
    return true;
  }
  
  // (A2) Limpar channels anteriores antes de criar novos
  if (window.__pvpChannel) {
    console.log('[PVP] Limpando channel anterior...');
    try {
      await window.__pvpChannel.unsubscribe();
      window.__pvpChannel = null;
    } catch (err) {
      console.warn('[PVP] Erro ao limpar channel anterior:', err);
    }
  }
  
  try {
    console.log('[PVP] ========================================');
    console.log('[PVP] Inicializando modo multiplayer');
    console.log('[PVP] matchId recebido:', matchId);
    
    // STEP 1: Ler par√¢metros da URL
    console.log('[PVP STEP 1] Lendo par√¢metros da URL...');
    const urlParams = getUrlParams();
    console.log('[PVP STEP 1] Params:', {
      mode: urlParams.mode,
      matchId: urlParams.matchId,
      supabaseUrl: urlParams.supabaseUrl ? 'presente' : 'ausente',
      supabaseKey: urlParams.supabaseKey ? 'presente' : 'ausente',
      access_token: urlParams.access_token ? 'presente' : 'ausente',
      refresh_token: urlParams.refresh_token ? 'presente' : 'ausente',
      userId: urlParams.userId
    });
    
    // Validar params cr√≠ticos
    if (urlParams.error) {
      console.error('[PVP] ‚ùå Erro nos par√¢metros da URL:', urlParams.error);
      alert('Erro: ' + urlParams.error);
      multiplayerMode = false;
      return;
    }
    
    if (!urlParams.matchId) {
      console.error('[PVP] ‚ùå matchId ausente ou inv√°lido');
      alert('Erro: matchId n√£o fornecido na URL');
      multiplayerMode = false;
      return;
    }
    
    if (!urlParams.supabaseUrl || !urlParams.supabaseKey) {
      console.error('[PVP] ‚ùå supabaseUrl ou supabaseKey ausente');
      alert('Erro: Configura√ß√£o do Supabase ausente');
      multiplayerMode = false;
      return;
    }
    
    // STEP 2: Criar Supabase client com tokens
    console.log('[PVP STEP 2] Criando Supabase client...');
    
    if (typeof supabase === 'undefined') {
      throw new Error('Supabase SDK n√£o carregado');
    }
    
    const { createClient } = supabase;
    if (!createClient) {
      throw new Error('supabase.createClient n√£o encontrado');
    }
    
    // Criar client sem persist session
    supabaseClient = createClient(urlParams.supabaseUrl, urlParams.supabaseKey, {
      auth: {
        persistSession: false,
        autoRefreshToken: false
      }
    });
    console.log('[PVP] ‚úì Supabase client criado');
    
    // STEP 3: Autenticar via tokens (se dispon√≠veis) - ANTES de qualquer query
    let authenticatedUser = null;
    
    if (urlParams.access_token && urlParams.refresh_token) {
      console.log('[PVP STEP 3] Autenticando via setSession...');
      
      try {
        const { data: sessionData, error: sessionError } = await supabaseClient.auth.setSession({
          access_token: urlParams.access_token,
          refresh_token: urlParams.refresh_token
        });
        
        if (sessionError) {
          console.warn('[PVP] ‚ö†Ô∏è setSession falhou (token expirado?):', sessionError.message);
          // Continuar com userId da URL mesmo se setSession falhar
          myUserId = urlParams.userId;
        } else if (!sessionData?.session) {
          console.warn('[PVP] ‚ö†Ô∏è setSession n√£o retornou sess√£o');
          myUserId = urlParams.userId;
        } else {
          console.log('[PVP] ‚úì Sess√£o estabelecida');
          
          const { data: userData, error: userError } = await supabaseClient.auth.getUser();
          
          if (!userError && userData?.user) {
            authenticatedUser = userData.user;
            myUserId = authenticatedUser.id;
            console.log('[PVP] ‚úì Autenticado como:', myUserId);
          } else {
            console.warn('[PVP] ‚ö†Ô∏è getUser falhou:', userError?.message);
            myUserId = urlParams.userId;
          }
        }
        
        // Limpar tokens da URL (manter s√≥ mode e matchId)
        const cleanUrl = new URL(window.location.href);
        cleanUrl.searchParams.delete('access_token');
        cleanUrl.searchParams.delete('refresh_token');
        window.history.replaceState({}, document.title, cleanUrl.toString());
        
      } catch (authErr) {
        console.warn('[PVP] ‚ö†Ô∏è Exce√ß√£o ao autenticar (usando userId da URL):', authErr.message);
        myUserId = urlParams.userId;
      }
    } else {
      console.log('[PVP STEP 3] Tokens n√£o dispon√≠veis, usando userId da URL');
      myUserId = urlParams.userId || window.THOR_PLAYER?.userId;
    }
    
    if (!myUserId) {
      console.error('[PVP] ‚ùå userId n√£o dispon√≠vel');
      alert('Erro: N√£o foi poss√≠vel identificar o usu√°rio');
      multiplayerMode = false;
      return;
    }
    
    console.log('[PVP] ‚úì userId final:', myUserId);
    
    // STEP 4: Buscar dados do match via supabase-js
    console.log('[PVP STEP 4] Buscando match id=' + matchId + '...');
    
    const { data: match, error: matchError } = await supabaseClient
      .from('matches')
      .select('*')
      .eq('id', matchId)
      .maybeSingle();
    
    if (matchError) {
      console.error('[PVP] ‚ùå Erro ao buscar match:', matchError);
      alert('Erro ao carregar partida: ' + (matchError.message || 'Erro desconhecido'));
      multiplayerMode = false;
      return false;
    }
    
    if (!match) {
      console.error('[PVP] ‚ùå Match n√£o encontrado (id: ' + matchId + ')');
      console.error('[PVP] Poss√≠vel problema: match foi deletado ou RLS bloqueando acesso');
      alert('Partida n√£o encontrada. Ela pode ter sido cancelada ou voc√™ n√£o tem permiss√£o para acess√°-la.');
      multiplayerMode = false;
      return false;
    }
    
    console.log('[PVP] ‚úì Match carregado:', {
      id: match.id,
      player1_id: match.player1_id,
      player2_id: match.player2_id,
      state: match.state,
      phase: match.phase,
      turn_user_id: match.turn_user_id,
      turn_number: match.turn_number
    });
    
    matchData = match;
    currentPhase = match.phase || 'select';
    currentTurn = match.turn || 'blue';
    
    // STEP 5: Determinar meu time DETERMINISTICAMENTE via player1_id/player2_id
    console.log('[PVP STEP 5] Determinando times (determin√≠stico)...');
    
    // Usar EXCLUSIVAMENTE player1_id e player2_id (ignorar invite_from/invite_to)
    player1_id = match.player1_id || match.player1;
    player2_id = match.player2_id || match.player2;
    
    if (!player1_id || !player2_id) {
      throw new Error(`Match sem player1_id ou player2_id definidos (player1_id: ${player1_id}, player2_id: ${player2_id})`);
    }
    
    // Valida√ß√£o de permiss√£o - BLOQUEAR se n√£o for participante
    if (myUserId !== player1_id && myUserId !== player2_id) {
      throw new Error(`‚ùå ACESSO NEGADO: Voc√™ n√£o √© participante deste match\nmyUserId: ${myUserId}\nplayer1_id: ${player1_id}\nplayer2_id: ${player2_id}`);
    }
    
    // Determinar time deterministicamente
    if (myUserId === player1_id) {
      myTeam = 'blue';
      opponentUserId = player2_id;
      console.log('[PVP] ‚úì EU SOU BLUE (player1_id)');
    } else if (myUserId === player2_id) {
      myTeam = 'red';
      opponentUserId = player1_id;
      console.log('[PVP] ‚úì EU SOU RED (player2_id)');
    }
    
    // Determinar turno baseado em turn_user_id (n√£o turn_team)
    turnUserId = match.turn_user_id || player1_id; // Default: player1 come√ßa
    isMyTurn = (turnUserId === myUserId);
    
    console.log('[PVP] ‚úì Meu time:', myTeam.toUpperCase());
    console.log('[PVP] ‚úì player1_id (BLUE):', player1_id);
    console.log('[PVP] ‚úì player2_id (RED):', player2_id);
    console.log('[PVP] ‚úì turn_user_id:', turnUserId);
    console.log('[PVP] ‚úì isMyTurn:', isMyTurn);
    
    // STEP 6: Buscar username do oponente (com cache e maybeSingle)
    console.log('[PVP STEP 6] Buscando username do oponente...');
    opponentUsername = await getOpponentUsername(opponentUserId);
    console.log('[PVP] ‚úì Oponente:', opponentUsername);
    
    // STEP 7: Ativar modo multiplayer
    multiplayerMode = true;
    PVP.hasInitialized = true;
    console.log('[PVP] ‚úì‚úì‚úì MODO MULTIPLAYER ATIVADO (DETERMIN√çSTICO) ‚úì‚úì‚úì');
    console.log('[PVP] Resumo:');
    console.log('[PVP]   - Meu time:', myTeam.toUpperCase());
    console.log('[PVP]   - Meu ID:', myUserId);
    console.log('[PVP]   - Oponente:', opponentUsername, '('+opponentUserId+')');
    console.log('[PVP]   - player1_id (BLUE):', player1_id);
    console.log('[PVP]   - player2_id (RED):', player2_id);
    console.log('[PVP]   - Fase:', currentPhase);
    console.log('[PVP]   - turn_user_id:', turnUserId);
    console.log('[PVP]   - √â meu turno?', isMyTurn);
    console.log('[PVP] CPU DESABILITADA - PVP REAL');
    console.log('[PVP] ========================================');
    
    // Salvar no localStorage
    localStorage.setItem('thor_match_opponent_name', opponentUsername);
    
    // Configurar realtime para sincroniza√ß√£o de estado e eventos
    setupMatchStateSync(matchId);
    setupMatchEventsSync(matchId);
    
    // Iniciar sistema de heartbeat para detectar desconex√£o
    startHeartbeat();
    
    // F) Se j√° estiver em battle (recarga de p√°gina), iniciar sync de movimento
    if (currentPhase === 'battle') {
      console.log('[PVP] Match j√° em battle, inicializando syncChannel...');
      setupMultiplayerSync(matchId);
    }
    
    // (A3) Marcar como inicializado para este matchId
    window.__pvpInitializedForMatchId = matchId;
    console.log('[PVP] ‚úÖ Inicializa√ß√£o completa para matchId:', matchId);
    
    return true;
  } catch (err) {
    console.error('[PVP] ========================================');
    console.error('[PVP] ‚ùå EXCE√á√ÉO FATAL na inicializa√ß√£o do multiplayer:');
    console.error('[PVP]', err);
    console.error('[PVP] Stack:', err.stack);
    console.error('[PVP] ========================================');
    return false;
  }
}

// ============================================
// SISTEMA DE HEARTBEAT (detectar desconex√£o)
// ============================================

// Enviar heartbeat a cada 3 segundos
function startHeartbeat() {
  if (!multiplayerMode || !supabaseClient || !matchData) return;
  
  console.log('[HEARTBEAT] Iniciando sistema de heartbeat');
  
  // Enviar heartbeat imediatamente
  sendHeartbeat();
  
  // Enviar heartbeat a cada 3s
  heartbeatInterval = setInterval(() => {
    sendHeartbeat();
  }, 3000);
  
  // Verificar √∫ltimo heartbeat do oponente a cada 5s
  opponentLastSeenCheck = setInterval(() => {
    checkOpponentHeartbeat();
  }, 5000);
}

// Enviar meu heartbeat
async function sendHeartbeat() {
  if (!supabaseClient || !matchData || currentPhase === 'finished') return;
  
  try {
    const isPlayer1 = myUserId === matchData.player1_id;
    const field = isPlayer1 ? 'player1_last_seen' : 'player2_last_seen';
    
    await supabaseClient
      .from('matches')
      .update({ [field]: new Date().toISOString() })
      .eq('id', matchData.id);
    
    console.log('[HEARTBEAT] ‚ù§Ô∏è Enviado');
  } catch (err) {
    console.error('[HEARTBEAT] Erro ao enviar:', err);
  }
}

// Verificar se oponente est√° desconectado
async function checkOpponentHeartbeat() {
  if (!supabaseClient || !matchData || currentPhase === 'finished') return;
  
  try {
    const { data, error } = await supabaseClient
      .from('matches')
      .select('player1_last_seen, player2_last_seen, phase')
      .eq('id', matchData.id)
      .single();
    
    if (error || !data) return;
    
    // S√≥ verificar se match ainda est√° ativo
    if (data.phase === 'finished') {
      stopHeartbeat();
      return;
    }
    
    const isPlayer1 = myUserId === matchData.player1_id;
    const opponentLastSeen = isPlayer1 ? data.player2_last_seen : data.player1_last_seen;
    
    if (!opponentLastSeen) return;
    
    const lastSeenTime = new Date(opponentLastSeen).getTime();
    const now = Date.now();
    const secondsSinceLastSeen = (now - lastSeenTime) / 1000;
    
    console.log('[HEARTBEAT] Oponente visto h√°', Math.floor(secondsSinceLastSeen), 's');
    
    // Se n√£o vejo o oponente h√° mais de 10s, aplicar WO
    if (secondsSinceLastSeen > 10) {
      console.log('[HEARTBEAT] üö® Oponente desconectado! Aplicando WO...');
      stopHeartbeat();
      await applyWalkover();
    }
  } catch (err) {
    console.error('[HEARTBEAT] Erro ao verificar:', err);
  }
}

// Parar heartbeat
function stopHeartbeat() {
  if (heartbeatInterval) {
    clearInterval(heartbeatInterval);
    heartbeatInterval = null;
    console.log('[HEARTBEAT] Parando envio de heartbeat');
  }
  if (opponentLastSeenCheck) {
    clearInterval(opponentLastSeenCheck);
    opponentLastSeenCheck = null;
    console.log('[HEARTBEAT] Parando verifica√ß√£o de oponente');
  }
}

// ============================================
// REALTIME SYNC
// ============================================

// Configurar sincroniza√ß√£o de estado do match via Realtime
function setupMatchStateSync(matchId) {
  if (!supabaseClient) {
    console.error('[REALTIME] supabaseClient n√£o existe');
    return;
  }
  
  if (matchStateChannel) {
    console.log('[REALTIME] ‚ö†Ô∏è matchStateChannel j√° existe, n√£o criar duplicado');
    return;
  }
  
  try {
    console.log('[REALTIME] üîó Criando canal de estado para match:', matchId);
    matchStateChannel = supabaseClient.channel(`match-state:${matchId}`)
      .on('postgres_changes', {
        event: 'UPDATE',
        schema: 'public',
        table: 'matches',
        filter: `id=eq.${matchId}`
      }, (payload) => {
        console.log('[REALTIME] üì® UPDATE recebido no match:', payload);
        handleMatchUpdate(payload);
      })
      .on('presence', { event: 'sync' }, () => {
        const presenceState = matchStateChannel.presenceState();
        console.log('[PRESENCE] Estado sincronizado:', presenceState);
        
        // Contar jogadores online
        const onlineUsers = Object.keys(presenceState);
        console.log('[PRESENCE] Jogadores online:', onlineUsers.length, onlineUsers);
        
        // Se estou no jogo e s√≥ eu estou online (oponente desconectou)
        if (multiplayerMode && matchData && currentPhase !== 'finished') {
          const amIOnline = onlineUsers.includes(myUserId);
          const isOpponentOnline = onlineUsers.includes(opponentUserId);
          
          console.log('[PRESENCE] Eu online?', amIOnline);
          console.log('[PRESENCE] Oponente online?', isOpponentOnline);
          
          // Se eu estou online mas oponente n√£o est√°
          if (amIOnline && !isOpponentOnline && onlineUsers.length === 1) {
            console.log('[PRESENCE] üö™ Oponente desconectou! Aplicando WO em 3s...');
            // Delay de 3s para garantir que n√£o √© falso positivo
            setTimeout(() => {
              // Verificar novamente ap√≥s delay
              const stateAfterDelay = matchStateChannel.presenceState();
              const usersAfterDelay = Object.keys(stateAfterDelay);
              const opponentStillOffline = !usersAfterDelay.includes(opponentUserId);
              
              if (opponentStillOffline && currentPhase !== 'finished') {
                console.log('[PRESENCE] Confirmado: oponente desconectado. Aplicando WO...');
                applyWalkover();
              }
            }, 3000);
          }
        }
      })
      .on('presence', { event: 'join' }, ({ key, newPresences }) => {
        console.log('[PRESENCE] Jogador entrou:', key, newPresences);
      })
      .on('presence', { event: 'leave' }, ({ key, leftPresences }) => {
        console.log('[PRESENCE] Jogador saiu:', key, leftPresences);
        
        // Se o oponente saiu durante a partida
        if (key === opponentUserId && multiplayerMode && matchData && currentPhase !== 'finished') {
          console.log('[PRESENCE] üö™ Oponente saiu! Aplicando WO em 2s...');
          // Delay curto para evitar falso positivo de reconex√£o
          setTimeout(() => {
            if (currentPhase !== 'finished') {
              applyWalkover();
            }
          }, 2000);
        }
      })
      .subscribe(async (status) => {
        console.log('[REALTIME] üîî Status da conex√£o:', status);
        if (status === 'SUBSCRIBED') {
          console.log('[REALTIME] ‚úÖ Canal de estado SUBSCRIBED');
          window.__pvpChannel = matchStateChannel;
          
          // Registrar minha presen√ßa com track
          const trackStatus = await matchStateChannel.track({
            user_id: myUserId,
            username: localStorage.getItem('thor_username') || 'Player',
            online_at: new Date().toISOString()
          });
          
          console.log('[PRESENCE] ‚úÖ Track status:', trackStatus);
          console.log('[PRESENCE] Minha presen√ßa registrada como:', myUserId);
          
          // Log estado inicial
          setTimeout(() => {
            const initialState = matchStateChannel.presenceState();
            console.log('[PRESENCE] Estado inicial:', initialState);
          }, 1000);
        } else if (status === 'CHANNEL_ERROR') {
          console.error('[REALTIME] ‚ùå Erro no canal');
        } else if (status === 'TIMED_OUT') {
          console.error('[REALTIME] ‚è∞ Timeout na conex√£o');
        }
      });
  } catch (err) {
    console.error('[REALTIME] Erro ao configurar sync de estado:', err);
  }
}

// Aplicar walkover quando oponente desconecta
async function applyWalkover() {
  if (!supabaseClient || !matchData || currentPhase === 'finished') {
    console.log('[WO] Ignorando WO - match j√° finalizado ou sem dados');
    return;
  }
  
  console.log('[WO] üèÜ Aplicando WO - oponente desconectou');
  
  try {
    const { error } = await supabaseClient
      .from('matches')
      .update({
        phase: 'finished',
        winner_id: myUserId,
        wo: true,
        finished_at: new Date().toISOString()
      })
      .eq('id', matchData.id)
      .eq('phase', 'battle'); // Apenas se ainda estiver em battle
    
    if (error) {
      console.error('[WO] Erro ao aplicar WO:', error);
    } else {
      console.log('[WO] ‚úÖ WO aplicado com sucesso');
    }
  } catch (err) {
    console.error('[WO] Exce√ß√£o ao aplicar WO:', err);
  }
}

// Configurar sincroniza√ß√£o de eventos do match (tiros/movimentos) via Realtime
function setupMatchEventsSync(matchId) {
  if (!supabaseClient || matchEventsChannel) return;
  
  try {
    matchEventsChannel = supabaseClient.channel(`match-events:${matchId}`)
      .on('postgres_changes', {
        event: 'INSERT',
        schema: 'public',
        table: 'match_events',
        filter: `match_id=eq.${matchId}`
      }, handleMatchEvent)
      .subscribe((status) => {
        if (status === 'SUBSCRIBED') {
          console.log('[EVENTS] Canal de eventos do match conectado');
        }
      });
  } catch (err) {
    console.error('[EVENTS] Erro ao configurar sync de eventos:', err);
  }
}

// Handler para eventos do match (tiros, movimentos, etc)
function handleMatchEvent(payload) {
  const event = payload.new;
  
  console.log('[EVENTS] üì® Evento recebido:', event);
  console.log('[EVENTS] Type:', event.type);
  console.log('[EVENTS] Payload:', event.payload);
  console.log('[EVENTS] Turn:', event.turn_number);
  console.log('[EVENTS] User:', event.user_id);
  
  // Ignorar meus pr√≥prios eventos (j√° executei localmente)
  if (event.user_id === myUserId) {
    console.log('[EVENTS] ‚è≠Ô∏è Ignorando meu pr√≥prio evento');
    return;
  }
  
  // Reproduzir evento do oponente
  try {
    switch (event.type) {
      case 'move':
        console.log('[EVENTS] üöÄ Reproduzindo movimento do oponente');
        applyOpponentMove(event.payload);
        break;
      
      case 'shoot':
        console.log('[EVENTS] üí• Reproduzindo tiro do oponente');
        applyOpponentShoot(event.payload);
        break;
      
      case 'damage':
        console.log('[EVENTS] üíî Aplicando dano');
        applyDamage(event.payload);
        break;
      
      default:
        console.warn('[EVENTS] ‚ö†Ô∏è Tipo de evento desconhecido:', event.type);
    }
  } catch (err) {
    console.error('[EVENTS] ‚ùå Erro ao processar evento:', err);
  }
}

// Enviar evento de a√ß√£o para o match
async function sendMatchEvent(type, payload) {
  if (!supabaseClient || !matchData) {
    console.error('[EVENTS] ‚ùå N√£o √© poss√≠vel enviar evento sem supabaseClient ou matchData');
    return false;
  }
  
  try {
    const event = {
      match_id: matchData.id,
      user_id: myUserId,
      turn_number: currentTurnNumber,
      type: type,
      payload: payload
    };
    
    console.log('[EVENTS] üì§ Enviando evento:', event);
    
    const { error } = await supabaseClient
      .from('match_events')
      .insert([event]);
    
    if (error) {
      console.error('[EVENTS] ‚ùå Erro ao enviar evento:', error);
      return false;
    }
    
    console.log('[EVENTS] ‚úÖ Evento enviado com sucesso');
    return true;
  } catch (err) {
    console.error('[EVENTS] ‚ùå Exce√ß√£o ao enviar evento:', err);
    return false;
  }
}

// Aplicar movimento do oponente (placeholder - implementar l√≥gica real)
function applyOpponentMove(payload) {
  console.log('[EVENTS] Aplicando movimento:', payload);
  // TODO: Implementar l√≥gica de movimento baseada em payload
  // payload deve conter: { shipIndex, fromX, fromY, toX, toY }
}

// Aplicar tiro do oponente (placeholder - implementar l√≥gica real)
function applyOpponentShoot(payload) {
  console.log('[EVENTS] Aplicando tiro:', payload);
  // TODO: Implementar l√≥gica de tiro baseada em payload
  // payload deve conter: { shipIndex, targetX, targetY, weaponType }
}

// Aplicar dano (placeholder - implementar l√≥gica real)
function applyDamage(payload) {
  console.log('[EVENTS] Aplicando dano:', payload);
  // TODO: Implementar l√≥gica de dano baseada em payload
  // payload deve conter: { targetShipIndex, damage, isDestroyed }
}

// (A) Turn transition guard global - evita aplicar transi√ß√£o m√∫ltiplas vezes
let lastAppliedTurnIndex = null;
let lastAppliedTurnUserId = null;
let isApplyingTurnTransition = false;
let lastResolvedAt = null; // Rastrear √∫ltimo turno resolvido

// (A) Battle start guards - evita iniciar batalha m√∫ltiplas vezes
let battleStartApplied = false;
let lastPhase = null;
let isFetchingMatchFallback = false;

// (C) Fallback: buscar match via REST quando payload vier incompleto
async function fetchMatchRow(matchId) {
  if (isFetchingMatchFallback) {
    console.log('[üîé] J√° buscando match via REST, ignorando');
    return null;
  }
  
  isFetchingMatchFallback = true;
  try {
    const { data, error } = await supabaseClient
      .from('matches')
      .select('*')
      .eq('id', matchId)
      .single();
    
    if (error) throw error;
    
    const phase = data?.phase ?? data?.match_phase ?? data?.game_phase ?? data?.state?.phase ?? null;
    console.log('üîé [MATCH] Fallback REST OK:', {
      phase,
      keys: Object.keys(data || {})
    });
    
    return data;
  } catch (e) {
    console.warn('‚ùå [MATCH] Fallback REST falhou:', e);
    return null;
  } finally {
    isFetchingMatchFallback = false;
  }
}

// Handler para updates do match
async function handleMatchUpdate(payload) {
  // (B) Extrair row com fallbacks
  const row = payload?.new || {};
  // (B) Ler phase com m√∫ltiplos fallbacks
  const phase = row.phase ?? row.match_phase ?? row.game_phase ?? row.state?.phase ?? null;
  const state = row.state ?? null;
  // Log SEM SPAM
  console.log('üì® [REALTIME] Match UPDATE recebido:', { 
    phase, 
    hasState: !!state,
    ready_blue: row.ready_blue,
    ready_red: row.ready_red,
    turn_number: row.turn_number,
    turn_resolved_at: row.turn_resolved_at,
    lastResolvedAt: lastResolvedAt,
    countdown_started_at: row.countdown_started_at
  });

  // --- TIMER DE SELE√á√ÉO MULTIPLAYER SYNC ---
  // Se estamos na fase de sele√ß√£o e countdown_started_at foi definido, iniciar timer sincronizado
  if (phase === 'select' && multiplayerMode && row.countdown_started_at) {
    // Calcular segundos restantes a partir do timestamp do banco
    const startedAt = new Date(row.countdown_started_at).getTime();
    const now = Date.now();
    let secondsElapsed = Math.floor((now - startedAt) / 1000);
    let secondsLeft = 15 - secondsElapsed;
    if (secondsLeft < 0) secondsLeft = 0;
    if (!selectionTimerStarted || selectionTimeRemaining !== secondsLeft) {
      console.log('[TIMER][SYNC] Iniciando timer sincronizado para sele√ß√£o de naves:', { secondsLeft, startedAt, now });
      cancelSelectionTimer();
      selectionTimeRemaining = secondsLeft;
      selectionTimerStarted = true;
      showSelectionTimer(secondsLeft);
      if (selectionTimerInterval) clearInterval(selectionTimerInterval);
      selectionTimerInterval = setInterval(() => {
        selectionTimeRemaining--;
        showSelectionTimer(selectionTimeRemaining);
        if (selectionTimeRemaining <= 0) {
          clearInterval(selectionTimerInterval);
          selectionTimerInterval = null;
        }
      }, 1000);
      if (selectionTimer) clearTimeout(selectionTimer);
      selectionTimer = setTimeout(async () => {
        console.log('[TIMER][SYNC] Timeout de sele√ß√£o atingido (multiplayer sync)');
        if (!selectedNaves || selectedNaves.length < 3) {
          selectedNaves = [1, 1, 1];
          updatePreviews();
        }
        await saveShipSelection();
        updatePhaseAndStartBattle();
      }, secondsLeft * 1000);
    }
  }
  
  // (D) Detectar mudan√ßa de phase
  const phaseChanged = phase != null && phase !== lastPhase;
  if (phaseChanged) {
    console.log('üü£ [PHASE] mudou:', { from: lastPhase, to: phase });
    
    // Se phase mudou para 'finished', mostrar tela de resultado
    if (phase === 'finished') {
      console.log('[WIN] üèÅ Match finalizado via Realtime!');
      
      // ‚õî CR√çTICO: Prevenir processamento m√∫ltiplo de finaliza√ß√£o
      if (matchFinalizationProcessed) {
        console.log('[WIN] ‚è≠Ô∏è Finaliza√ß√£o j√° foi processada, ignorando evento Realtime duplicado');
        return;
      }
      matchFinalizationProcessed = true;
      console.log('[WIN] ‚úÖ Primeira finaliza√ß√£o, processando...');
      
      // Parar heartbeat quando jogo terminar
      stopHeartbeat();
      
      const winner_id = row.winner_id;
      const isWO = row.wo === true;
      
      if (isWO) {
        console.log('[WO] üö™ Match finalizado por WO (walkover)!');
        // For√ßar placar 3x0 para WO
        if (winner_id === myUserId) {
          // Eu ganhei por WO - oponente destru√≠do 3x0
          console.log('[WO] Eu ganhei por WO, for√ßando cpuNaves HP = 0');
          cpuNaves.forEach(nave => nave.hp = 0);
          playerNaves.forEach(nave => nave.hp = nave.maxHp || 100);
        } else {
          // Eu perdi por WO - minhas naves destru√≠das 3x0
          console.log('[WO] Eu perdi por WO, for√ßando playerNaves HP = 0');
          playerNaves.forEach(nave => nave.hp = 0);
          cpuNaves.forEach(nave => nave.hp = nave.maxHp || 100);
        }
      } else {
        // IMPORTANTE: Sincronizar HP do oponente ANTES de mostrar resultado
        const oppHP = (myTeam === 'blue') ? row.player2_hp : row.player1_hp;
        if (oppHP && Array.isArray(oppHP) && oppHP.length === 3) {
          console.log('[WIN] üì• Sincronizando HP final do oponente:', oppHP);
          cpuNaves.forEach((nave, idx) => {
            if (oppHP[idx] !== undefined) {
              nave.hp = oppHP[idx];
              console.log(`[WIN] cpuNaves[${idx}].hp = ${nave.hp}`);
            }
          });
        }
      }
      
      // Parar o jogo COMPLETAMENTE
      gameActive = false;
      
      // Limpar timers
      if (turnTimerInterval) {
        clearInterval(turnTimerInterval);
        turnTimerInterval = null;
      }
      if (turnTimer) {
        clearTimeout(turnTimer);
        turnTimer = null;
      }
      
      // Log para debug do placar
      console.log('[WIN] Placar final:', {
        myKills: getOppLost(),
        myDeaths: getMyLost(),
        playerNaves: playerNaves.map(n => n.hp),
        cpuNaves: cpuNaves.map(n => n.hp)
      });
      
      // üíæ Salvar placar final IMEDIATAMENTE quando jogo termina
      finalScoreSaved.myLost = getMyLost();
      finalScoreSaved.oppLost = getOppLost();
      console.log('[WIN] üíæ Placar salvo:', finalScoreSaved);
      

      // Fun√ß√£o para atualizar player_stats do usu√°rio
      async function updatePlayerStats({ userId, result, myKills, oppKills }) {
        // ‚õî Prevenir m√∫ltiplas atualiza√ß√µes na mesma partida
        if (statsUpdated) {
          console.log('[STATS] ‚è≠Ô∏è Stats j√° foram atualizados nesta partida, pulando...');
          return;
        }
        
        // ‚õî Prote√ß√£o adicional: verificar sessionStorage com matchId
        const statsLockKey = `stats_updated_${matchId}`;
        if (sessionStorage.getItem(statsLockKey)) {
          console.log('[STATS] ‚è≠Ô∏è Stats j√° foram atualizados para este matchId (sessionStorage), pulando...');
          return;
        }
        
        statsUpdated = true;
        sessionStorage.setItem(statsLockKey, 'true');
        console.log('[STATS] üìä Atualizando stats pela primeira vez nesta partida');
        console.log('[STATS] üîí Lock criado:', statsLockKey);
        
        if (!supabaseClient || !userId) return;
        let statsUpdate = {
          matches_played: 1,
          ships_destroyed: Number(myKills ?? 0),
          ships_lost: Number(oppKills ?? 0),
          wins: 0,
          losses: 0,
          draws: 0,
        };
        if (result === "win") statsUpdate.wins = 1;
        else if (result === "loss") statsUpdate.losses = 1;
        else statsUpdate.draws = 1;

        // Tenta atualizar stats existentes
        const { data: statsRow, error: statsError } = await supabaseClient
          .from("player_stats")
          .select("matches_played, wins, losses, draws, ships_destroyed, ships_lost")
          .eq("user_id", userId)
          .maybeSingle();

        if (statsRow) {
          // Atualiza somando os valores
          const updateObj = {
            matches_played: Number(statsRow.matches_played ?? 0) + 1,
            wins: Number(statsRow.wins ?? 0) + statsUpdate.wins,
            losses: Number(statsRow.losses ?? 0) + statsUpdate.losses,
            draws: Number(statsRow.draws ?? 0) + statsUpdate.draws,
            ships_destroyed: Number(statsRow.ships_destroyed ?? 0) + statsUpdate.ships_destroyed,
            ships_lost: Number(statsRow.ships_lost ?? 0) + statsUpdate.ships_lost,
          };
          console.log('[STATS] ‚úÖ Atualizando stats:', updateObj);
          await supabaseClient
            .from("player_stats")
            .update(updateObj)
            .eq("user_id", userId);
        } else {
          // Cria row se n√£o existir
          console.log('[STATS] ‚úÖ Criando stats:', statsUpdate);
          await supabaseClient
            .from("player_stats")
            .insert({
              user_id: userId,
              ...statsUpdate,
            });
        }
        // Disparar evento para atualizar header/react
        window.dispatchEvent(new Event('thor_stats_updated'));
      }

      // Determinar se eu ganhei ou perdi
      let matchResult = null;
      if (winner_id === myUserId) {
        console.log('[WIN] üéâ EU GANHEI!');
        winner = "VICTORY";
        matchResult = 'win';
        // ‚úÖ XP: Processar eventos de vit√≥ria
        processMatchEndXPEvents('win');
        applyMatchXP();
        finalXpForChat = xpTotalMatch; // üéØ Salvar XP para chat
        console.log('[REALTIME] üíæ finalXpForChat salvo (vit√≥ria):', finalXpForChat);
        // ‚úÖ Atualizar stats no ranking (para mim)
        updatePlayerStats({
          userId: myUserId,
          result: 'win',
          myKills: getOppLost(),
          oppKills: getMyLost(),
        });
        showVictoryScreen();
      } else if (winner_id === opponentUserId) {
        console.log('[WIN] üò¢ EU PERDI!');
        winner = "DEFEAT";
        matchResult = 'loss';
        // ‚úÖ XP: Processar eventos de derrota
        console.log('[WIN] üîç ANTES processMatchEndXPEvents(defeat) - xpTotalMatch:', xpTotalMatch);
        processMatchEndXPEvents('defeat');
        console.log('[WIN] üîç DEPOIS processMatchEndXPEvents(defeat) - xpTotalMatch:', xpTotalMatch);
        applyMatchXP();
        finalXpForChat = xpTotalMatch; // üéØ Salvar XP para chat (ser√° 0 em derrota)
        console.log('[REALTIME] üíæ finalXpForChat salvo (derrota):', finalXpForChat);
        // ‚úÖ Atualizar stats no ranking (para mim)
        updatePlayerStats({
          userId: myUserId,
          result: 'loss',
          myKills: getOppLost(),
          oppKills: getMyLost(),
        });
        showDefeatScreen();
      } else {
        console.log('[WIN] ü§ù EMPATE!');
        winner = "Empate!";
        matchResult = 'draw';
        // ‚úÖ XP: Processar eventos de empate
        processMatchEndXPEvents('draw');
        applyMatchXP();
        finalXpForChat = xpTotalMatch; // üéØ Salvar XP para chat
        console.log('[REALTIME] üíæ finalXpForChat salvo (empate):', finalXpForChat);
        // ‚úÖ Atualizar stats no ranking (para mim)
        updatePlayerStats({
          userId: myUserId,
          result: 'draw',
          myKills: getOppLost(),
          oppKills: getMyLost(),
        });
        showDrawScreen();
      }
      
      document.getElementById('gameCanvas').style.display = "none";
      
      // ‚úÖ Enviar GAME_OVER para o parent (Realtime sempre envia, n√£o usa gameOverSent)
      console.log("[THOR.HTML] üì° [REALTIME] Enviando THOR:GAME_OVER");
      console.log("[THOR.HTML] üì° [REALTIME] xpTotalMatch:", xpTotalMatch);
      if (window.parent && window.parent !== window) {
        const myLost = getMyLost();
        const oppLost = getOppLost();
        try {
            window.parent.postMessage({
              type: "THOR:GAME_OVER",
              payload: {
                myLost,
                oppLost,
                myKills: getOppLost(),
                oppKills: getMyLost(),
                xpGained: xpTotalMatch,
                matchId: localStorage.getItem("thor_match_id"),
                opponentName: localStorage.getItem("thor_match_opponent_name"),
              }
            }, window.location.origin);
          console.log("[THOR.HTML] üì° [REALTIME] THOR:GAME_OVER enviado com sucesso!", { myLost, oppLost, xpGained: xpTotalMatch });
        } catch (err) {
          console.error("[THOR.HTML] üì° [REALTIME] Error sending THOR:GAME_OVER:", err);
        }
      } else {
        console.warn("[THOR.HTML] üì° [REALTIME] THOR:GAME_OVER N√ÉO enviado. No parent window!");
      }
      
      // IMPORTANTE: Retornar para n√£o processar mais nada
      return;
    }
  }
  if (phase != null) lastPhase = phase;
  
  // Atualizar matchData
  matchData = { ...matchData, ...row };
  
  // Sincronizar HP do oponente se houver atualiza√ß√£o
  if (row.player1_hp || row.player2_hp) {
    const oppHP = (myTeam === 'blue') ? row.player2_hp : row.player1_hp;
    if (oppHP && Array.isArray(oppHP) && oppHP.length === 3) {
      console.log('[SYNC] üì• Recebendo HP do oponente do banco:', oppHP);
      // Aplicar HP em cpuNaves (naves do oponente)
      cpuNaves.forEach((nave, idx) => {
        if (oppHP[idx] !== undefined && nave.initialized) {
          const oldHP = nave.hp;
          // CORRE√á√ÉO: Sempre sincronizar HP do banco (fonte da verdade)
          // No in√≠cio do round, o banco tem HP cheio. Durante batalha, HP reduzido.
          nave.hp = oppHP[idx];
          if (oldHP !== nave.hp) {
            console.log('[SYNC]   - cpuNave #' + idx + ': ' + oldHP + ' ‚Üí ' + nave.hp);
          }
        }
      });
    }
  }
  
  // Detectar se o turno foi resolvido (turn_resolved_at mudou de null para timestamp)
  const turn_resolved_at = row.turn_resolved_at;
  const turn_number_db = row.turn_number || 1;
  
  if (turn_resolved_at && turn_resolved_at !== lastResolvedAt) {
    console.log('[TURN] üéØ Turno foi resolvido via Realtime! Aplicando a√ß√µes...');
    console.log('[TURN] turn_resolved_at:', turn_resolved_at);
    console.log('[TURN] turn_number_db:', turn_number_db);
    console.log('[TURN] currentTurnNumber local:', currentTurnNumber);
    
    lastResolvedAt = turn_resolved_at;
    
    // Ler as a√ß√µes do turno resolvido (de last_action_* que foram salvos)
    const action_blue = row.last_action_blue || { type: 'idle' };
    const action_red = row.last_action_red || { type: 'idle' };
    
    console.log('[TURN] A√ß√µes do turno resolvido (last_action_*):', { action_blue, action_red });
    
    // Aplicar as a√ß√µes
    applyResolvedTurn({ action_blue, action_red });
    
    // Atualizar turno local AP√ìS aplicar as a√ß√µes
    currentTurnNumber = turn_number_db;
    console.log('[TURN] Turno local atualizado para:', currentTurnNumber);
  }
  
  // (E) REGRA PRINCIPAL: se phase === 'battle', iniciar batalha 1 vez
  if (phase === 'battle' && !battleStartApplied) {
    battleStartApplied = true;
    console.log('üöÄ [BATTLE] phase=battle detectado. Iniciando batalha...');
    startBattleFromSelection();
    return;
  }
  
  // (F) Se phase veio null/undefined, fazer fallback REST
  if ((!phase || phase === undefined) && !battleStartApplied) {
    console.log('‚ö†Ô∏è [PHASE] Phase undefined, tentando fallback REST...');
    const fresh = await fetchMatchRow(matchData?.id);
    
    if (fresh) {
      const freshPhase = fresh.phase ?? fresh.match_phase ?? fresh.game_phase ?? fresh.state?.phase ?? null;
      
      if (freshPhase === 'battle' && !battleStartApplied) {
        battleStartApplied = true;
        console.log('üöÄ [BATTLE] phase=battle via REST fallback. Iniciando batalha...');
        startBattleFromSelection();
        return;
      }
    }
  }
  
  // L√≥gica de turnos (somente se batalha j√° come√ßou)
  if (phase === 'battle' && PVP.battleStarted) {
    const turn_index = row.turn_index;
    const turn_user_id = row.turn_user_id;
    const turn_number = row.turn_number;
    const turn_deadline_at = row.turn_deadline_at;
    const turn_resolved_at = row.turn_resolved_at;
    const currentIsMyTurn = (turn_user_id != null && turn_user_id === myUserId);
    
    const turnIndexChanged = (turn_index != null && turn_index !== lastAppliedTurnIndex);
    const turnUserChanged = (turn_user_id != null && turn_user_id !== lastAppliedTurnUserId);
    const turnNumberChanged = (turn_number != null && turn_number !== currentTurnNumber);
    
    // Se turn_number mudou, iniciar nova janela
    if (turnNumberChanged && turn_deadline_at) {
      console.log('[TURN] üÜï turn_number mudou via Realtime: ' + currentTurnNumber + ' ‚Üí ' + turn_number);
      currentTurnNumber = turn_number;
      
      // Resetar UI antes de iniciar novo turno
      resetTurnUI();
      
      // Iniciar nova janela de turno com novo deadline
      console.log('[TURN] üïê Iniciando janela para turno #' + turn_number + ' com deadline:', turn_deadline_at);
      startTurnWindow(turn_deadline_at);
    }
    
    // Apenas aplicar transi√ß√£o se turn_index mudou (novo round)
    // N√ÉO aplicar se apenas turn_user_id mudou (altern√¢ncia no mesmo round)
    if (turnIndexChanged) {
      // Guard: se j√° estiver aplicando transi√ß√£o, ignorar
      if (isApplyingTurnTransition) {
        console.log('[TURN] ‚ö†Ô∏è J√° aplicando transi√ß√£o, ignorando update duplicado');
        return;
      }
      
      isApplyingTurnTransition = true;
      lastAppliedTurnIndex = turn_index;
      lastAppliedTurnUserId = turn_user_id;
      
      console.log('üü¶ [TURN] NOVO ROUND detectado (turn_index mudou)', {
        turn_index,
        turn_user_id,
        isMyTurn: currentIsMyTurn
      });
      
      turnUserId = turn_user_id;
      isMyTurn = currentIsMyTurn;
      
      // S√ì resetar UI quando for novo round (turn_index mudou)
      applyTurnTransition(currentIsMyTurn);
      
      setTimeout(() => {
        isApplyingTurnTransition = false;
        console.log('[TURN] üîì Guard liberado');
      }, 50);
    } else if (turnUserChanged) {
      // Apenas atualizar quem √© o turno, SEM resetar UI
      lastAppliedTurnUserId = turn_user_id;
      turnUserId = turn_user_id;
      isMyTurn = currentIsMyTurn;
      
      console.log('üîÑ [TURN] Altern√¢ncia de jogador (sem reset UI)', {
        turn_user_id,
        isMyTurn: currentIsMyTurn
      });
      
      // Apenas atualizar mensagem, sem resetar estado
      updateTurnUI();
    }
    
    // Verificar se algum jogador submeteu a√ß√£o (para tentar resolver turno)
    const blue_data = row.ships_blue;
    const red_data = row.ships_red;
    
    console.log('[TURN] üì¨ Verificando submiss√µes via Realtime:');
    console.log('[TURN]   - blue_data:', blue_data ? JSON.stringify(blue_data).substring(0, 100) : 'null');
    console.log('[TURN]   - red_data:', red_data ? JSON.stringify(red_data).substring(0, 100) : 'null');
    
    const submitted_blue = blue_data && typeof blue_data === 'object' && blue_data.type === 'ACTION';
    const submitted_red = red_data && typeof red_data === 'object' && red_data.type === 'ACTION';
    
    if (submitted_blue || submitted_red) {
      console.log('[TURN] üì¨ Detec√ß√£o de submiss√£o via Realtime:', { submitted_blue, submitted_red });
      
      // Checar pelo banco se EU submetei (n√£o usar vari√°vel local myActionSubmitted que pode estar incorreta)
      const mySubmitted = (myTeam === 'blue') ? submitted_blue : submitted_red;
      const opponentSubmitted = (myTeam === 'blue') ? submitted_red : submitted_blue;
      
      console.log('[TURN] Status das submiss√µes (do banco):');
      console.log('[TURN]   - Eu (' + myTeam + ') enviei?', mySubmitted);
      console.log('[TURN]   - Oponente enviou?', opponentSubmitted);
      
      // Se AMBOS submeteram (checando o banco, n√£o vari√°veis locais)
      if (submitted_blue && submitted_red) {
        console.log('[TURN] ‚úÖ AMBOS SUBMETERAM! Tentando resolver turno via Realtime...');
        console.log('[TURN] Chamando maybeResolveTurn em 500ms...');
        setTimeout(() => maybeResolveTurn(), 500);
      } else if (!mySubmitted) {
        console.log('[TURN] ‚è≥ Eu ainda n√£o enviei minha a√ß√£o');
      } else {
        console.log('[TURN] ‚è≥ Aguardando oponente submeter...');
      }
    }
  }
}

// (C) Aplicar transi√ß√£o de turno
function applyTurnTransition(isMyTurn) {
  console.log('[TURN] üîÑ Aplicando transi√ß√£o de turno, isMyTurn:', isMyTurn);
  
  // 1) Resetar UI/estado
  resetTurnUI();
  // AAA: Garantir fase interativa no multiplayer
  ensurePvpInteractivePhase('applyTurnTransition');
  
  // 2) Voltar fase para planejamento
  phase = 'selectMove';
  selectedNave = null;
  
  // 3) Regras de input baseado em isMyTurn
  const legendArea = document.getElementById('legendArea');
  const endTurnBtn = document.getElementById('endTurnBtn');
  
  if (isMyTurn) {
    // Minha vez: liberar controles
    // Removido: banner central de aguarde. S√≥ usar legendArea no HUD.
    if (endTurnBtn) {
      endTurnBtn.disabled = false;
      endTurnBtn.style.opacity = '1';
    }
    if (legendArea) {
      legendArea.textContent = t('yourTurn');
      legendArea.style.color = '';
      // LOG AAA: identificar HUD no turno do jogador
      console.log('[HUD][applyTurnTransition] Minha vez! legendArea:', legendArea.textContent, '| timerArea:', document.getElementById('timerText')?.textContent);
    }
    console.log('‚úÖ [TURN] minha vez: controles liberados');
  } else {
    // Vez do oponente: bloquear controles
    // Nunca mostrar popup de aguardando oponente na sele√ß√£o de naves
    if (endTurnBtn) {
      endTurnBtn.disabled = true;
      endTurnBtn.style.opacity = '0.5';
    }
    if (legendArea) {
      legendArea.textContent = t('waitingOpponentShort');
      legendArea.style.color = '';
      // LOG AAA: identificar HUD no turno do oponente
      console.log('[HUD][applyTurnTransition] Oponente! legendArea:', legendArea.textContent, '| timerArea:', document.getElementById('timerText')?.textContent);
    }
    console.log('‚è≥ [TURN] vez do oponente: controles bloqueados');
  }
}

// Aplicar update do match (separado para permitir chamada manual)
function applyMatchUpdate(newMatch, oldPhase, oldTurnNumber, oldTurnUserId, oldTurnDeadline, oldTurnResolved) {
  console.log('[TURN] applyMatchUpdate chamado (turn logic desativada, usando handleMatchUpdate)');
  // MERGE de estado: atualizar campos cr√≠ticos sem apagar intera√ß√µes locais
  matchData = { ...matchData, ...newMatch };
  currentPhase = newMatch.phase;
  
  // TURNOS: Reagir a mudan√ßas de turno baseado em turn_user_id
  // [REMOVIDO/OBSOLETO] Bloco de l√≥gica de turno desativado. Toda l√≥gica de turno multiplayer agora √© controlada exclusivamente por handleMatchUpdate.
  
  // FIX 3: Se ready do oponente mudou E ambos enviaram a√ß√£o, esconder popup
  const opponentReady = myTeam === 'blue' ? newMatch.ready_red : newMatch.ready_blue;
  const mySubmitted = myTeam === 'blue' ? submitted_blue : submitted_red;
  const oppSubmitted = myTeam === 'blue' ? submitted_red : submitted_blue;
  
  // Esconder popup quando AMBOS enviaram
  // Removido: banner central de aguarde. S√≥ usar legendArea no HUD.
  
  // Atualizar UI de turno
  updateTurnUI();
}


// Removido: popup central de espera/aguarde. S√≥ usar legendArea no HUD.

// (C) Resetar UI/inputs para novo turno (Round 2+)
function resetTurnUI() {
  roundLocked = false; // üîì destrava sele√ß√£o no novo round
  console.log('[LOCK] roundLocked destravado no resetTurnUI');
  // AAA: Garantir fase interativa no multiplayer
  ensurePvpInteractivePhase('resetTurnUI');
  console.log('[TURN] üîÑ resetTurnUI chamada');
  
  // N√ÉO resetar se houver vencedor
  if (winner) {
    console.log('[TURN] Jogo terminado, n√£o resetar UI');
    return;
  }
  
  // IMPORTANTE: Limpar timer interval para evitar contador infinito
  if (typeof turnTimerInterval !== 'undefined' && turnTimerInterval) {
    clearInterval(turnTimerInterval);
    turnTimerInterval = null;
    window.__activeTurnTimer = null; // Limpar refer√™ncia global tamb√©m
    window.__currentTurnDeadline = null; // Limpar deadline atual
    console.log('[TURN] ‚úÖ turnTimerInterval limpo');
  }
  
  // Limpar timer principal se existir
  if (typeof turnTimer !== 'undefined' && turnTimer) {
    clearTimeout(turnTimer);
    turnTimer = null;
  }
  
  // 1) Limpar target/shot/moved de TODAS as naves
  playerNaves.forEach(n => {
    n.target = null;
    n.shot = null;
    if (typeof n.moved !== 'undefined') n.moved = false;
  });
  
  cpuNaves.forEach(n => {
    n.target = null;
    n.shot = null;
    if (typeof n.moved !== 'undefined') n.moved = false;
  });
  
  // Limpar sele√ß√£o e intera√ß√£o
  selectedNave = null;
  isInteracting = false;
  
  // Limpar flags de round
  if (typeof playerWonRound !== 'undefined') playerWonRound = false;
  if (typeof cpuWonRound !== 'undefined') cpuWonRound = false;
  if (typeof roundResultTimer !== 'undefined') roundResultTimer = 0;
  if (typeof isPaused !== 'undefined') isPaused = false;
  if (typeof showExplosionUI !== 'undefined') showExplosionUI = false;
  
  // Limpar proj√©teis e part√≠culas
  projectiles = [];
  if (typeof damageTexts !== 'undefined') damageTexts = [];
  if (typeof particles !== 'undefined') particles = [];
  
  // Limpar guard de aplica√ß√£o de turno
  window.__lastAppliedTurnKey = null;
  
  console.log('[TURN] ‚úÖ resetTurnUI completo - estado limpo');
}

// Iniciar timer de sele√ß√£o (15 segundos)

// Cancelar timer de sele√ß√£o
// Cancelar timer de sele√ß√£o
// (refatorado para AAA centralizado, ver bloco acima)

// Atualizar phase para battle e iniciar batalha (fun√ß√£o √∫nica)
async function updatePhaseAndStartBattle() {
  console.log('[PVP] üöÄ updatePhaseAndStartBattle chamada');
  console.log('[PVP] PVP.battleStarted:', PVP.battleStarted);
  
  // N√£o usar guard aqui - deixar o startBattleFromSelection controlar
  // Apenas atualizar o banco, o Realtime vai sincronizar para ambos
  
  try {
    const { error: phaseError } = await supabaseClient
      .from('matches')
      .update({ phase: 'battle' })
      .eq('id', matchData.id);
    
    if (phaseError) {
      console.error('[PVP] ‚ùå Erro ao atualizar phase:', phaseError);
    } else {
      console.log('[PVP] ‚úÖ Phase atualizada para battle no banco');
      console.log('[PVP] Aguardando Realtime sincronizar e chamar startBattleFromSelection()');
      cancelSelectionTimer();
      // Removido: banner central de aguarde. S√≥ usar legendArea no HUD.
    }
  } catch (err) {
    console.error('[PVP] ‚ùå Exce√ß√£o ao atualizar phase:', err);
  }
}

// Salvar naves selecionadas no banco
async function saveShipSelection() {
  if (!multiplayerMode || !supabaseClient || !matchData) {
    console.error('[PVP] saveShipSelection chamada mas falta:', {
      multiplayerMode,
      supabaseClient: !!supabaseClient,
      matchData: !!matchData
    });
    return false;
  }
  
  try {
    console.log('[PVP] ========================================');
    console.log('[PVP] Salvando sele√ß√£o de naves (DETERMIN√çSTICO)');
    console.log('[PVP] selectedNaves:', selectedNaves);
    console.log('[PVP] myTeam:', myTeam);
    console.log('[PVP] myUserId:', myUserId);
    console.log('[PVP] player1_id:', player1_id);
    console.log('[PVP] player2_id:', player2_id);
    
    // Usar array puro de n√∫meros (JSONB) e salvar em player1_ships/player2_ships
    const shipsData = selectedNaves; // [1, 2, 3] ou similar
    
    // Determinar campo baseado em player_id (n√£o team)
    const updateData = {};
    if (myUserId === player1_id) {
      updateData.player1_ships = shipsData;
      updateData.ready_blue = true;
      console.log('[PVP] Salvando em player1_ships (BLUE)');
    } else if (myUserId === player2_id) {
      updateData.player2_ships = shipsData;
      updateData.ready_red = true;
      console.log('[PVP] Salvando em player2_ships (RED)');
    }
    
    console.log('[PVP] Payload (JSONB array):', JSON.stringify(updateData));
    
    // Atualizar match com minhas naves, ready flag e countdown_started_at (se ainda null)
    const nowIso = new Date().toISOString();
    let updateCountdown = { ...updateData };
    // S√≥ grava countdown_started_at se ainda estiver null
    if (!matchData.countdown_started_at) {
      updateCountdown.countdown_started_at = nowIso;
    }
    let { data, error } = await supabaseClient
      .from('matches')
      .update(updateCountdown)
      .eq('id', matchData.id)
      .select('*')
      .single();
    
    if (error) {
      console.error('[PVP] ‚ùå Erro ao salvar sele√ß√£o:');
      console.error('[PVP] error.message:', error.message);
      console.error('[PVP] error.code:', error.code);
      console.error('[PVP] error.details:', error.details);
      console.error('[PVP] error.hint:', error.hint);
      console.error('[PVP] error completo:', JSON.stringify(error));
      console.error('[PVP] Payload enviado:', JSON.stringify(updateData));
      console.error('[PVP] ========================================');
      return false;
    }
    
    console.log('[PVP] ‚úÖ Sele√ß√£o salva');
    
    // Atualizar matchData local
    if (data) {
      matchData = data;
      
      const ready_blue = data.ready_blue;
      const ready_red = data.ready_red;
      
      console.log('[PVP] Status: ready_blue=' + ready_blue + ', ready_red=' + ready_red);
      
      if (ready_blue && ready_red) {
        console.log('[PVP] ‚úÖ Ambos prontos ‚Üí iniciando batalha');
        cancelSelectionTimer();
        updatePhaseAndStartBattle();
      } else {
        // Timer deve iniciar para o oponente assim que um clicar em pronto
        // AAA: Timer agora √© sincronizado via countdown_started_at, n√£o iniciar localmente
        // O handleMatchUpdate vai disparar o timer sincronizado para ambos
      }
    }
    
    console.log('[PVP] ========================================');
    return true;
  } catch (err) {
    console.error('[PVP] ‚ùå EXCE√á√ÉO ao salvar naves:');
    console.error('[PVP]', err);
    console.error('[PVP] message:', err.message);
    console.error('[PVP] code:', err.code);
    console.error('[PVP] Stack:', err.stack);
    console.error('[PVP] ========================================');
    return false;
  }
}

// Iniciar batalha com naves sincronizadas
function startBattleFromSelection() {
  if (!multiplayerMode || !matchData) {
    console.error('[PVP] startBattleFromSelection chamada mas multiplayerMode:', multiplayerMode, 'matchData:', matchData);
    return;
  }
  
  if (PVP.battleStarted) {
    console.log('[PVP] ‚ö†Ô∏è Batalha j√° iniciada, ignorando');
    return;
  }
  
  if (!PVP.hasInitialized) {
    console.error('[PVP] ‚ùå Tentativa de iniciar batalha sem inicializa√ß√£o completa');
    return;
  }
  
  PVP.battleStarted = true;
  console.log('[PVP] ========================================');
  console.log('[PVP] üöÄ INICIANDO BATALHA MULTIPLAYER (DETERMIN√çSTICO)');
  console.log('[PVP] matchData:', matchData);
  console.log('[PVP] myUserId:', myUserId);
  console.log('[PVP] myTeam:', myTeam);
  console.log('[PVP] player1_id:', player1_id);
  console.log('[PVP] player2_id:', player2_id);
  
  // GARANTIR que myTeam est√° definido
  if (!myTeam) {
    console.error('[PVP] ‚ùå ERRO CR√çTICO: myTeam n√£o foi definido!');
    if (myUserId === player1_id) {
      myTeam = 'blue';
      console.log('[PVP] üîß CORRE√á√ÉO: Definindo myTeam = blue');
    } else if (myUserId === player2_id) {
      myTeam = 'red';
      console.log('[PVP] üîß CORRE√á√ÉO: Definindo myTeam = red');
    }
  }
  
  console.log('[PVP] ‚úÖ myTeam confirmado:', myTeam);
  
  // Ler naves DETERMINISTICAMENTE de player1_ships/player2_ships
  const player1Ships = matchData.player1_ships || [];
  const player2Ships = matchData.player2_ships || [];
  
  console.log('[PVP] player1_ships (BLUE - raw):', player1Ships);
  console.log('[PVP] player2_ships (RED - raw):', player2Ships);
  
  // Determinar minhas naves e naves do oponente baseado em player_id
  let myShips, enemyShips;
  if (myUserId === player1_id) {
    myShips = player1Ships;
    enemyShips = player2Ships;
    console.log('[PVP] ‚úì EU SOU PLAYER1 (BLUE)');
  } else {
    myShips = player2Ships;
    enemyShips = player1Ships;
    console.log('[PVP] ‚úì EU SOU PLAYER2 (RED)');
  }
  
  const isP1 = (myUserId === player1_id);
  console.log('[PVP] ‚úì isP1:', isP1);
  console.log('[PVP] ‚úì myShips:', myShips);
  console.log('[PVP] ‚úì oppShips (enemyShips):', enemyShips);
  
  // Fix E: Valida√ß√£o arrays vazios/null
  if (!myShips || myShips.length !== 3) {
    console.warn('[PVP] Minhas naves inv√°lidas, for√ßando sele√ß√£o padr√£o [1,1,1]');
    myShips = [1, 1, 1];
  }
  
  if (!enemyShips || enemyShips.length !== 3) {
    console.warn('[PVP] Naves do oponente inv√°lidas, for√ßando sele√ß√£o padr√£o [1,1,1]');
    enemyShips = [1, 1, 1];
  }
  
  // CORRE√á√ÉO CR√çTICA: playerNaves = minhas (control√°veis), cpuNaves = oponente
  // Player1: playerNaves no TOPO (blue), cpuNaves embaixo (red)
  // Player2: playerNaves EMBAIXO (red), cpuNaves no topo (blue)
  console.log('[PVP] Aplicando minhas naves control√°veis (isP1=' + isP1 + ')...');
  console.log('[PVP] üîç ANTES DE APLICAR - myUserId:', myUserId, 'player1_id:', player1_id, 'isP1:', isP1);
  applyMyShips(myShips, isP1);
  
  console.log('[PVP] Aplicando naves do oponente (isP1=' + isP1 + ')...');
  applyEnemyShips(enemyShips, isP1);
  
  console.log('[PVP] ‚úì Naves aplicadas com sucesso');
  console.log('[PVP] üé® COR DAS NAVES FINAL:');
  console.log('[PVP]   - playerNaves (minhas):', playerNaves.map((n, i) => `#${i}: ${n.tint || 'AZUL'}`));
  console.log('[PVP]   - cpuNaves (oponente):', cpuNaves.map((n, i) => `#${i}: ${n.tint || 'AZUL'}`));
  console.log('[PVP]   - Resumo: EU sou', isP1 ? 'Player1 (BLUE no topo)' : 'Player2 (RED embaixo)');
  console.log('[PVP]   - Minhas naves devem ser:', isP1 ? 'AZUL' : 'VERMELHO');
  console.log('[PVP]   - Naves oponente devem ser:', isP1 ? 'VERMELHO' : 'AZUL');
  
  // Esconder tela de sele√ß√£o e mostrar jogo
  document.getElementById('naveSelectScreen').style.display = 'none';
  document.getElementById('gameCanvas').style.display = 'block';
  
  // Aplicar fundo aleat√≥rio ao iniciar o jogo
  applyGameBackground();
  
  var hudTop = document.getElementById('hudTop');
  hudTop.style.display = 'flex';
  hudTop.style.visibility = 'visible';
  hudTop.style.opacity = '1';
  document.getElementById('gameContour').style.visibility = 'visible';
  galaxyBg.style.opacity = '0.18';
  
  console.log('[PVP] ‚úì UI atualizada - canvas vis√≠vel');
  
  // Mostrar banner de matchup no multiplayer
  const matchupBanner = document.getElementById("matchupBanner");
  const playerNameDisplay = document.getElementById("playerNameDisplay");
  const opponentNameDisplay = document.getElementById("opponentNameDisplay");
  
  if (matchupBanner && playerNameDisplay && opponentNameDisplay) {
    const currentPlayerName = playerName || localStorage.getItem("thor_username") || "Player";
    playerNameDisplay.textContent = currentPlayerName;
    
    const displayOpponentName = opponentUsername || localStorage.getItem("thor_match_opponent_name") || "Opponent";
    opponentNameDisplay.textContent = displayOpponentName;
    opponentNameDisplay.style.color = "#FF4444"; // Vermelho para jogador real
    
    matchupBanner.style.display = "block";
    matchupBanner.style.visibility = "visible";
    
    console.log('[PVP] ‚úì Banner de matchup exibido:', currentPlayerName, 'vs', displayOpponentName);
  }
  
  // Iniciar game loop se necess√°rio
  canStartGame = true;
  if (!window._gameLoopStarted && spritesLoaded === 2) {
    window._gameLoopStarted = true;
    gameActive = true;
    console.log('[PVP] ‚úì Iniciando game loop');
    gameLoop();
  } else {
    console.log('[PVP] Game loop j√° iniciado ou aguardando sprites');
  }
  
  // Atualizar UI de turno
  updateTurnUI();
  
  // G) Log de turno iniciado
  console.log('[PVP] üîµ Turno iniciado - aguardando jogadas');
  
  // B) Ligar sincroniza√ß√£o de movimento agora que batalha iniciou
  console.log('[PVP] Batalha iniciada, configurando syncChannel...');
  setupMultiplayerSync(matchData.id);
  
  // Fix F: Logs finais de diagn√≥stico
  console.log('[PVP] ========================================');
  console.log('[PVP] READY: phase=' + currentPhase + ', myUserId=' + myUserId + ', isP1=' + isP1 + ', turn_user_id=' + turnUserId + ', canInput=' + isMyTurn);
  console.log('[PVP] Render: p1ShipsCount=' + (isP1 ? myShips.length : enemyShips.length) + ', p2ShipsCount=' + (isP1 ? enemyShips.length : myShips.length));
  console.log('[PVP] ========================================');
  
  // INICIAR PRIMEIRO TURNO (idempotente, sem race condition)
  // AAA: Garantir fase interativa no multiplayer
  ensurePvpInteractivePhase('startBattleFromSelection');
  (async () => {
    try {
      console.log('[PVP] üéÆ Configurando primeiro turno...');
      console.log('[PVP] matchId:', matchData.id, 'myUserId:', myUserId, 'myTeam:', myTeam);
      console.log('[PVP] player1_id:', player1_id, 'player2_id:', player2_id);
      
      // Buscar estado atual do match
      const { data: currentMatch, error: fetchError } = await supabaseClient
        .from('matches')
        .select('turn_user_id, turn_number, turn_deadline_at')
        .eq('id', matchData.id)
        .single();
      
      if (fetchError) {
        console.error('[PVP] ‚ùå Erro ao buscar match atual:', JSON.stringify(fetchError, null, 2));
        return;
      }
      
      console.log('[PVP] Estado atual:', JSON.stringify(currentMatch, null, 2));
      
      // Se turn_user_id j√° existe, n√£o sobrescrever (idempotente)
      if (currentMatch.turn_user_id) {
        console.log('[PVP] ‚úì Turno j√° configurado por outro jogador:', currentMatch.turn_user_id);
        turnUserId = currentMatch.turn_user_id;
        isMyTurn = (myUserId === turnUserId);
        currentTurnNumber = currentMatch.turn_number || 1;
        
        if (currentMatch.turn_deadline_at) {
          startTurnWindow(currentMatch.turn_deadline_at);
        }
        
        return;
      }
      
      // turn_user_id √© null, vou tentar setar (optimistic update)
      console.log('[PVP] turn_user_id √© null, configurando primeiro turno...');
      
      const firstDeadline = new Date(Date.now() + 15000).toISOString();
      const now = new Date().toISOString();
      
      // Update com condi√ß√£o: s√≥ setar se turn_user_id ainda for null (evita race)
      const { data: updateData, error: updateError } = await supabaseClient
        .from('matches')
        .update({
          turn_number: 1,
          turn_user_id: player1_id, // Player 1 sempre come√ßa
          turn_deadline_at: firstDeadline,
          turn_started_at: now,
          turn_resolved_at: null
        })
        .eq('id', matchData.id)
        .is('turn_user_id', null) // S√≥ atualizar se for null
        .select();
      
      if (updateError) {
        console.error('[PVP] ‚ùå Erro ao configurar turno:', JSON.stringify(updateError, null, 2));
        // Outro jogador pode ter configurado primeiro, buscar novamente
        const { data: refetch } = await supabaseClient
          .from('matches')
          .select('turn_user_id, turn_number, turn_deadline_at')
          .eq('id', matchData.id)
          .single();
        
        if (refetch?.turn_user_id) {
          console.log('[PVP] ‚úì Turno configurado por outro jogador:', refetch.turn_user_id);
          turnUserId = refetch.turn_user_id;
          isMyTurn = (myUserId === turnUserId);
          currentTurnNumber = refetch.turn_number || 1;
          if (refetch.turn_deadline_at) {
            startTurnWindow(refetch.turn_deadline_at);
          }
        }
        return;
      }
      
      if (!updateData || updateData.length === 0) {
        console.log('[PVP] ‚ö†Ô∏è Update n√£o afetou linhas (outro jogador j√° configurou)');
        // Buscar novamente
        const { data: refetch } = await supabaseClient
          .from('matches')
          .select('turn_user_id, turn_number, turn_deadline_at')
          .eq('id', matchData.id)
          .single();
        
        if (refetch?.turn_user_id) {
          console.log('[PVP] ‚úì Turno configurado:', refetch.turn_user_id);
          turnUserId = refetch.turn_user_id;
          isMyTurn = (myUserId === turnUserId);
          currentTurnNumber = refetch.turn_number || 1;
          if (refetch.turn_deadline_at) {
            startTurnWindow(refetch.turn_deadline_at);
          }
        }
        return;
      }
      
      // Sucesso! Eu configurei o turno
      console.log('[PVP] ‚úÖ Primeiro turno configurado com sucesso');
      console.log('[PVP] turn_user_id:', player1_id, 'turn_number: 1');
      console.log('[PVP] deadline:', firstDeadline);
      
      turnUserId = player1_id;
      isMyTurn = (myUserId === turnUserId);
      currentTurnNumber = 1;
      
      console.log('[PVP] isMyTurn:', isMyTurn);
      
      startTurnWindow(firstDeadline);
      
    } catch (err) {
      console.error('[PVP] ‚ùå Exce√ß√£o ao configurar turno:', err.message);
      console.error('[PVP] Stack:', err.stack);
    }
  })();
  
  console.log('[PVP] ========================================');
}

// Aplicar naves do OPONENTE (inimigas em cpuNaves)
function applyEnemyShips(shipsArray, myIsP1) {
  // POSI√á√ïES F√çSICAS REAIS DO OPONENTE:
  // Se eu sou P1 (topo), oponente √© P2 (baixo)
  // Se eu sou P2 (baixo), oponente √© P1 (topo)
  const posicoes = myIsP1 ? [
    { x: 700, y: 520 },  // Oponente P2 baixo
    { x: 540, y: 520 },
    { x: 700, y: 350 }
  ] : [
    { x: 100, y: 250 },  // Oponente P1 topo
    { x: 260, y: 80 },
    { x: 100, y: 80 }
  ];
  
  // Centro do MEU campo (para as naves advers√°rias apontarem)
  const myCenterX = myIsP1 ? 180 : 620;
  const myCenterY = myIsP1 ? 150 : 460;
  
  shipsArray.forEach((tipo, i) => {
    if (cpuNaves[i]) {
      cpuNaves[i].tipo = tipo;
      cpuNaves[i].x = posicoes[i].x;
      cpuNaves[i].y = posicoes[i].y;
      
      // Calcular √¢ngulo individual apontando para o meu centro
      const dx = myCenterX - cpuNaves[i].x;
      const dy = myCenterY - cpuNaves[i].y;
      cpuNaves[i].angle = Math.atan2(dy, dx) + Math.PI / 2;
      
      let sprite = new Image();
      let hp = 99;
      let alcance = 300;
      if (tipo === 1) {
        sprite.src = 'images/nave_alcance.png';
        hp = 66;
        alcance = 360;
      } else if (tipo === 2) {
        sprite.src = 'images/nave_protecao.png';
        hp = 132;
        alcance = 160;
      } else {
        sprite.src = 'images/spaceschip.png';
        hp = 99;
        alcance = 300;
      }
      
      console.log(`[HP-SYNC] üîç cpuNaves[${i}]: tipo=${tipo}, HP INICIAL=${hp}`);
      
      cpuNaves[i].sprite = sprite;
      cpuNaves[i].hp = hp;
      cpuNaves[i].alcance = alcance;
      
      // COR DO TIME OPONENTE
      if (multiplayerMode) {
        if (myIsP1) {
          cpuNaves[i].tint = 'red';
        }
      } else {
        cpuNaves[i].tint = 'red';
      }
    }
  });
  
  console.log('[PVP] cpuNaves aplicadas:', cpuNaves.map(n => ({ x: n.x, y: n.y, tipo: n.tipo, angle: n.angle, tint: n.tint })));
  console.log('[PVP] ‚úÖ RENDERIZA√á√ÉO COMPLETA');
  console.log('[PVP] Player1 (BLUE) sempre no TOPO, Player2 (RED) sempre EMBAIXO');
  console.log('[PVP] Cada jogador controla suas pr√≥prias naves (playerNaves)');
  console.log('[PVP] myTeam:', myTeam, '- Minhas naves:', playerNaves.map(n => n.tint || 'BLUE'), '- Oponente:', cpuNaves.map(n => n.tint || 'BLUE'));
}

// Mant√©m compatibilidade
function applyOpponentNavesFromSelection(shipsArray, isPlayer1Owner = true) {
  if (multiplayerMode) {
    // No contexto multiplayer, isPlayer1Owner indica se OPONENTE √© P1
    // Se oponente √© P1, ele est√° no topo
    applyEnemyShips(shipsArray, !isPlayer1Owner);
  } else {
    // Modo solo mant√©m l√≥gica original
    shipsArray.forEach((tipo, i) => {
      if (cpuNaves[i]) {
        cpuNaves[i].tipo = tipo;
        let sprite = new Image();
        let hp = 99;
        if (tipo === 1) {
          sprite.src = 'images/nave_alcance.png';
          hp = 66;
        } else if (tipo === 2) {
          sprite.src = 'images/nave_protecao.png';
          hp = 132;
        } else {
          sprite.src = 'images/spaceschip.png';
          hp = 99;
        }
        cpuNaves[i].sprite = sprite;
        cpuNaves[i].hp = hp;
      }
    });
  }
}

// Atualizar UI de turno
function updateTurnUI() {
  if (!multiplayerMode) return;
  
  const legendArea = document.getElementById('legendArea');
  const endTurnArea = document.getElementById('endTurnArea');
  const endTurnBtn = document.getElementById('endTurnBtn');
  
  if (!legendArea) return;
  
  // Em multiplayer, NUNCA mostrar bot√£o de finalizar turno (sistema autom√°tico)
  if (endTurnArea) endTurnArea.style.display = 'none';
  
  if (currentPhase !== 'battle') {
    return;
  }
  
  // Mostrar bot√£o de finalizar turno
  if (endTurnArea) {
    endTurnArea.style.display = isMyTurn ? 'block' : 'none';
  }
  
  // TURNOS SIMULT√ÇNEOS: sempre permitir input
  legendArea.textContent = t('clickShipToMove');
  legendArea.style.color = myTeam === 'blue' ? '#00D4FF' : '#FF4444';
  // Removido: banner central de aguarde. S√≥ usar legendArea no HUD.
  
  // Sempre habilitar em modo simult√¢neo
  if (endTurnBtn) {
    endTurnBtn.disabled = false;
    endTurnBtn.style.opacity = '1';
  }
}

// Finalizar turno - alternar turn_user_id de forma at√¥mica
async function endTurn() {
  if (!multiplayerMode || !supabaseClient || !matchData || !isMyTurn) {
    console.log('[TURN] N√£o √© poss√≠vel finalizar turno:', {
      multiplayerMode,
      hasClient: !!supabaseClient,
      hasMatch: !!matchData,
      isMyTurn
    });
    return;
  }
  
  try {
    // Alternar turn_user_id entre player1_id e player2_id
    const nextTurnUserId = (turnUserId === player1_id) ? player2_id : player1_id;
    
    console.log('[TURN] Finalizando turno...');
    console.log('[TURN] turnUserId atual:', turnUserId);
    console.log('[TURN] Pr√≥ximo turnUserId:', nextTurnUserId);
    
    const { error } = await supabaseClient
      .from('matches')
      .update({
        turn_user_id: nextTurnUserId,
        turn_index: (matchData.turn_index || 1) + 1,
        updated_at: new Date().toISOString()
      })
      .eq('id', matchData.id);
    
    if (error) {
      console.error('[TURN] ‚ùå Erro ao finalizar turno:', error);
      return;
    }
    
    console.log('[TURN] ‚úÖ Turno finalizado, turn_user_id agora √©:', nextTurnUserId);
    
    console.log('[PVP] Turno finalizado, pr√≥ximo:', nextTurn);
  } catch (err) {
    console.error('[PVP] Erro ao finalizar turno:', err);
  }
}

// Configurar sincroniza√ß√£o multiplayer
// Vari√°veis globais para turn-based
let myTurnAction = null;
let opponentTurnAction = null;
let turnSubmitted = false;

// Interaction lock: impede sobrescrita de estado durante intera√ß√£o do usu√°rio
let isInteracting = false;
let pendingRemoteState = null;
let roundLocked = false; // üîí trava inputs ap√≥s 3 naves READY at√© novo round


function setupMultiplayerSync(matchId) {
  if (!multiplayerMode) {
    console.warn('[PVP] setupMultiplayerSync chamado mas multiplayerMode=false');
    return;
  }
  
  // (E) Guard robusto: nunca criar duplicatas
  if (syncChannel) {
    console.log('[PVP] ‚ö†Ô∏è syncChannel j√° existe, n√£o recriar (evitando duplicata)');
    return;
  }
  
  if (!supabaseClient) {
    console.error('[PVP] ‚ùå setupMultiplayerSync: supabaseClient global n√£o existe!');
    return;
  }
  
  try {
    console.log('[PVP] üîó Criando syncChannel TURN-BASED para match:', matchId);
    
    syncChannel = supabaseClient.channel(`match:${matchId}`, {
      config: { broadcast: { self: false } }
    });
    
    // C1) Listener TURN_ACTION: receber jogada do oponente
    syncChannel.on('broadcast', { event: 'turn_action' }, ({ payload }) => {
      if (!payload || payload.userId === myUserId) return;
      
      console.log('[PVP] üì® Jogada recebida do oponente:', {
        userId: payload.userId,
        team: payload.team,
        actions: payload.actions?.length
      });
      
      // Salvar a jogada do oponente (n√£o aplicar ainda)
      opponentTurnAction = payload;
      
      // D) Se eu j√° enviei e recebi a dele, executar turno
      if (turnSubmitted && opponentTurnAction) {
        console.log('[PVP] Ambas jogadas prontas, executando turno...');
        executeTurn();
      }
    });
    
    // C2) Listener REALTIME_STATE: receber posicionamento/movimento em tempo real
    syncChannel.on('broadcast', { event: 'realtime_state' }, ({ payload }) => {
      if (!payload || payload.userId === myUserId) return;
      
      console.log('[REALTIME] üì® Estado em tempo real do oponente:', {
        userId: payload.userId,
        team: payload.team,
        phase: payload.phase,
        ships: payload.ships?.length,
        isInteracting: isInteracting
      });
      
      // Se usu√°rio est√° interagindo, n√£o aplicar
      if (isInteracting) {
        console.log('[REALTIME] üîí Ignorando update - usu√°rio interagindo');
        return;
      }
      
      // Aplicar posi√ß√µes do oponente em cpuNaves
      if (payload.ships && Array.isArray(payload.ships)) {
        payload.ships.forEach((shipData, idx) => {
          if (cpuNaves[idx] && shipData) {
            // Atualizar APENAS posi√ß√µes em tempo real
            if (shipData.x !== undefined) cpuNaves[idx].x = shipData.x;
            if (shipData.y !== undefined) cpuNaves[idx].y = shipData.y;
            // ‚ö†Ô∏è N√ÉO aplicar angle/target/hp em tempo real - s√≥ ap√≥s execu√ß√£o do turno (vazamento visual + desync)
            // if (shipData.angle !== undefined) cpuNaves[idx].angle = shipData.angle;
            // if (shipData.target) cpuNaves[idx].target = shipData.target;
            // if (shipData.hp !== undefined) cpuNaves[idx].hp = shipData.hp;
            if (shipData.shot) cpuNaves[idx].shot = shipData.shot;
          }
        });
        console.log('[REALTIME] ‚úÖ Posi√ß√µes do oponente aplicadas (angle/target/hp bloqueados)');
      }
    });
    
    syncChannel.subscribe((status) => {
      console.log('[PVP] syncChannel status:', status);
      
      if (status === 'SUBSCRIBED') {
        console.log('[PVP] ‚úÖ syncChannel TURN-BASED SUBSCRIBED', { matchId, myUserId, myTeam });
      } else if (status === 'CHANNEL_ERROR') {
        console.error('[PVP] ‚ùå CHANNEL_ERROR no syncChannel - tentando reconectar em 2s...');
        
        // Tentar reconectar ap√≥s 2 segundos
        setTimeout(() => {
          console.log('[PVP] üîÑ Tentando reconectar syncChannel...');
          if (syncChannel) {
            syncChannel.unsubscribe();
          }
          setupMultiplayerSync(); // Recriar canal
        }, 2000);
      } else if (status === 'TIMED_OUT') {
        console.error('[PVP] ‚è∞ TIMED_OUT no syncChannel - tentando reconectar...');
        
        setTimeout(() => {
          console.log('[PVP] üîÑ Tentando reconectar ap√≥s timeout...');
          if (syncChannel) {
            syncChannel.unsubscribe();
          }
          setupMultiplayerSync();
        }, 2000);
      } else if (status === 'CLOSED') {
        console.warn('[PVP] üîí syncChannel CLOSED');
      }
    });
    
    console.log('[PVP] setupMultiplayerSync TURN-BASED configurado');
  } catch (err) {
    console.error('[PVP] ‚ùå Erro ao configurar sincroniza√ß√£o:', err);
  }
}

// A) Broadcast de estado em tempo real (posicionamento/movimento)
function broadcastRealtimeState() {
  if (!multiplayerMode || !syncChannel) return;
  
  try {
    const ships = playerNaves.map((n, idx) => ({
      index: idx,
      x: n.x,
      y: n.y,
      angle: n.angle,
      target: n.target,
      shot: n.shot,
      hp: n.hp
    }));
    
    syncChannel.send({
      type: 'broadcast',
      event: 'realtime_state',
      payload: {
        userId: myUserId,
        team: myTeam,
        phase: phase,
        ships: ships
      }
    });
    
    console.log('[REALTIME] üì§ Estado em tempo real enviado');
  } catch (err) {
    console.error('[REALTIME] ‚ùå Erro ao enviar estado:', err);
  }
}

// B) Enviar jogada final do turno
function submitTurnAction() {
  if (!multiplayerMode || !syncChannel || turnSubmitted) return;
  
  console.log('[PVP] üì§ Enviando jogada do turno...');
  
  try {
    // Coletar a√ß√µes de todas as naves controladoras (playerNaves)
    const actions = playerNaves.map((n, idx) => ({
      index: idx,
      target: n.target ? { x: n.target.x, y: n.target.y } : null,
      shot: n.shot ? { x: n.shot.x, y: n.shot.y } : null,
      hp: n.hp
    }));
    
    myTurnAction = {
      type: 'turn_action',
      userId: myUserId,
      team: myTeam,
      actions: actions
    };
    
    syncChannel.send({
      type: 'broadcast',
      event: 'turn_action',
      payload: myTurnAction
    });
    
    turnSubmitted = true;
    console.log('[PVP] ‚úÖ Jogada enviada', myTeam, actions.length);
    
    // D) Se j√° recebi a do oponente, executar
    if (opponentTurnAction) {
      console.log('[PVP] Oponente j√° enviou, executando turno...');
      executeTurn();
    } else {
      console.log('[PVP] Aguardando jogada do oponente...');
    }
  } catch (err) {
    console.error('[PVP] ‚ùå Erro ao enviar jogada:', err);
  }
}

// D) Executar turno sincronizado
function executeTurn() {
  if (!myTurnAction || !opponentTurnAction) {
    console.warn('[PVP] executeTurn: faltam a√ß√µes', { my: !!myTurnAction, opp: !!opponentTurnAction });
    return;
  }
  
  console.log('[PVP] üéÆ Executando turno sincronizado');
  
  // Aplicar minhas a√ß√µes em playerNaves
  myTurnAction.actions.forEach(action => {
    const nave = playerNaves[action.index];
    if (nave && nave.hp > 0) {
      nave.target = action.target;
      nave.shot = action.shot;
    }
  });
  
  // Aplicar a√ß√µes do oponente em cpuNaves
  opponentTurnAction.actions.forEach(action => {
    const nave = cpuNaves[action.index];
    if (nave && nave.hp > 0) {
      nave.target = action.target;
      nave.shot = action.shot;
    }
  });
  
  // Disparar proj√©teis
  phase = 'wait';
  fireProjectiles();
  
  // Resetar para pr√≥ximo turno com limpeza completa
  myTurnAction = null;
  opponentTurnAction = null;
  turnSubmitted = false;
  isInteracting = false;
  pendingRemoteState = null;
  
 
  
  console.log('[PVP] ‚úÖ Turno finalizado e estado limpo para round 2');
}

// A) Fun√ß√£o removida - N√ÉO sincronizar movimento em tempo real
// Use submitTurnAction() para enviar jogada final do turno

// Enviar tiro (mantido para compatibilidade mas n√£o usado em turn-based)
function broadcastShot(x, y, vx, vy) {
  if (!multiplayerMode || !syncChannel) return;
  
  try {
    // (F) Fix: myTeam √© 'blue'/'red' (lowercase), n√£o 'BLUE'/'RED'
    const target = myTeam === 'blue' ? 'red' : 'blue';
    
    syncChannel.send({
      type: 'broadcast',
      event: 'shot',
      payload: {
        userId: myUserId,
        team: myTeam,
        target: target,
        x, y, vx, vy,
        t: Date.now()
      }
    });
  } catch (err) {
    console.error('[REALTIME] Erro ao enviar tiro:', err);
  }
}

// Checar desconex√£o do oponente
function checkRemoteConnection() {
  if (!multiplayerMode) return;
  
  const now = Date.now();
  if (now - remotePlayerLastSeen > 2000) {
    remotePlayerConnected = false;
  } else {
    remotePlayerConnected = true;
  }
}

function hideEndScreens() {
  document.getElementById('victoryScreen').style.display = 'none';
  document.getElementById('defeatScreen').style.display = 'none';
  document.getElementById('drawScreen').style.display = 'none';
}

function showOnly(screenId) {
  console.log('[showOnly] Chamado com screenId:', screenId);
  hideEndScreens(); // Garante que nenhuma tela de resultado est√° ativa
  // Lista das telas principais do jogo (ajuste se adicionar mais telas fullscreen)
  const telas = [
    "loadingScreen", "startContainer", "modeSelectionScreen",
    "naveSelectScreen", "matchmakingScreen",
    "victoryScreen", "defeatScreen", "drawScreen"
  ];
  telas.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.style.display = "none";
  });
  // Mostra s√≥ a desejada
  const target = document.getElementById(screenId);
  if (target) target.style.display = "flex";
  
  // FIX 1: Trocar SRC das imagens para vers√£o vermelha se o jogador for RED (player2)
  if (screenId === "naveSelectScreen" && multiplayerMode && myTeam === 'red') {
    console.log('[UI] Aplicando imagens VERMELHAS nas naves da tela de sele√ß√£o (myTeam=red)');
    document.querySelectorAll('.nave-img').forEach(img => {
      const originalSrc = img.src;
      // Trocar para vers√£o _red
      if (originalSrc.includes('nave_alcance.png')) {
        img.src = originalSrc.replace('nave_alcance.png', 'nave_alcance_red.png');
      } else if (originalSrc.includes('nave_protecao.png')) {
        img.src = originalSrc.replace('nave_protecao.png', 'nave_protecao_red.png');
      } else if (originalSrc.includes('spaceschip.png')) {
        img.src = originalSrc.replace('spaceschip.png', 'nave_normal_red.png');
      }
    });
    // Aplicar tamb√©m nos previews
    for (let i = 1; i <= 3; i++) {
      const preview = document.getElementById(`preview${i}`);
      if (preview && preview.src) {
        const originalSrc = preview.src;
        if (originalSrc.includes('nave_alcance.png')) {
          preview.src = originalSrc.replace('nave_alcance.png', 'nave_alcance_red.png');
        } else if (originalSrc.includes('nave_protecao.png')) {
          preview.src = originalSrc.replace('nave_protecao.png', 'nave_protecao_red.png');
        } else if (originalSrc.includes('spaceschip.png')) {
          preview.src = originalSrc.replace('spaceschip.png', 'nave_normal_red.png');
        }
      }
    }
  } else if (screenId === "naveSelectScreen") {
    // Resetar para vers√£o azul se for BLUE ou modo solo
    document.querySelectorAll('.nave-img').forEach(img => {
      const redSrc = img.src;
      if (redSrc.includes('_red.png')) {
        img.src = redSrc.replace('nave_alcance_red.png', 'nave_alcance.png')
                       .replace('nave_protecao_red.png', 'nave_protecao.png')
                       .replace('nave_normal_red.png', 'spaceschip.png');
      }
    });
    for (let i = 1; i <= 3; i++) {
      const preview = document.getElementById(`preview${i}`);
      if (preview && preview.src && preview.src.includes('_red.png')) {
        preview.src = preview.src.replace('nave_alcance_red.png', 'nave_alcance.png')
                                 .replace('nave_protecao_red.png', 'nave_protecao.png')
                                 .replace('nave_normal_red.png', 'spaceschip.png');
      }
    }
  }
  
  // Ocultar banner de matchup apenas em telas espec√≠ficas (n√£o durante o jogo)
  const matchupBanner = document.getElementById("matchupBanner");
  if (matchupBanner) {
    // Esconder apenas nas telas de menu, n√£o durante o jogo
    const hideInScreens = ["startContainer", "modeSelectionScreen", "matchmakingScreen", "loadingScreen"];
    if (hideInScreens.includes(screenId)) {
      matchupBanner.style.display = "none";
    }
    // Durante naveSelectScreen e o jogo, o banner permanece vis√≠vel (se j√° foi exibido)
  }
  
  // Header fica oculto apenas nas telas antigas de loading/login quando embedado
  try {
    const shouldShowHeader = !(screenId === 'loadingScreen' || screenId === 'startContainer');
    setHeaderVisible(shouldShowHeader);
  } catch (e) { /* silent */ }
}

// AAA: Input lock global para multiplayer
let inputLocked = false;

let playerScore = 0; // Pontua√ß√£o total do player
// Helper para garantir que o score exibido/enviado nunca seja negativo
function clampScore(val) {
  if (typeof val === 'undefined') val = playerScore;
  return Math.max(0, Number(val || 0));
}

// Fonte da verdade AAA para sele√ß√£o de naves
if (typeof PVP === 'object') {
  PVP.fleetSlots = [null, null, null]; // shipId em cada slot
  PVP.fleetLocked = false;
}

// 4) Garantir que PVP nunca √© recriado inteiro
// (Adicionar log em qualquer ponto que fa√ßa PVP = ...)
Object.defineProperty(window, 'PVP', {
  set(v) {
    console.log('[BUG] PVP object replaced!', v);
  },
  configurable: true
});

let roundBonus = 0;  // Pontua√ß√£o de b√¥nus a cada rodada
let cpuScore = 0;
let playerDestroyed = 0;  // ‚úÖ Minhas naves destru√≠das (perdas)
let cpuDestroyed = 0;     // ‚úÖ Naves do oponente destru√≠das (meus kills)
let showReadyGo = false;
let readyGoText = "";
let readyGoAlpha = 0;
let readyGoTimer = 0;
let readyGoStep = 0; // 0 = Ready?, 1 = Go!, 2 = Fim
let collisionCpuSolo = 0;     // Quantas vezes CPU colidiu sozinho
let collisionPlayerSolo = 0;  // Quantas vezes voc√™ colidiu suas pr√≥prias naves
let navesPerdidas = 0;        // Quantas naves voc√™ perdeu (abatidas pelo CPU)
let bonusAllAtOnce = false;
let bonusNoLoss = false;
let gameActive = true; // controle para saber se o loop do jogo est√° ativo
let gameOverSent = false; // Flag para garantir que THOR:GAME_OVER s√≥ seja enviado uma vez
let statsUpdated = false; // Flag para garantir que player_stats s√≥ seja atualizado uma vez por partida
let matchFinalizationProcessed = false; // Flag para garantir que finaliza√ß√£o s√≥ execute uma vez
let finalScoreSaved = { myLost: 0, oppLost: 0 }; // Salvar placar final quando jogo termina

// Fun√ß√µes para calcular perdas totais (combate + autocolis√£o)
function getMyLost() {
  // Contar MINHAS naves destru√≠das (playerNaves com hp <= 0)
  return playerNaves.filter(n => n.hp <= 0).length;
}

function getOppLost() {
  // Contar naves do OPONENTE destru√≠das (cpuNaves com hp <= 0)
  return cpuNaves.filter(n => n.hp <= 0).length;
}



let cpuDestroyedAntesDoRound = 0;   // <==== NOVA VARI√ÅVEL DO PASSO 1

// Lista global para part√≠culas de explos√£o
let particles = [];






function backToStartMenu() {
  console.log('[GAME] backToStartMenu chamado');
  console.log('[GAME] üéØ finalXpForChat:', finalXpForChat);
  
  // E) Cleanup: remover canais Realtime
  if (syncChannel) {
    try {
      console.log('[REALTIME] Removendo syncChannel');
      supabaseClient.removeChannel(syncChannel);
    } catch(e) {
      console.error('[REALTIME] Erro ao remover syncChannel:', e);
    }
    syncChannel = null;
  }
  
  if (matchStateChannel) {
    try {
      console.log('[REALTIME] Removendo matchStateChannel');
      supabaseClient.removeChannel(matchStateChannel);
    } catch(e) {
      console.error('[REALTIME] Erro ao remover matchStateChannel:', e);
    }
    matchStateChannel = null;
  }
  
  // 1) Fecha as telas finais (vit√≥ria/derrota/empate)
  hideEndScreens();

  // 2) Para o loop do jogo (evita sobreposi√ß√£o de canvas/loops)
  gameActive = false;
  window._gameLoopStarted = false;

  // 3) Limpa algumas coisas do jogo (opcional, mas recomendado)
  projectiles = [];
  explosions = [];
  particles = [];
  wrecks = [];

  // Preparar dados do resultado - usar valores salvos no momento da finaliza√ß√£o
  const matchId = matchData?.id || localStorage.getItem("thor_match_id");
  const opponentName = localStorage.getItem("thor_match_opponent_name") || 'Opponent';
  const myLost = finalScoreSaved.myLost;
  const oppLost = finalScoreSaved.oppLost;
  
  console.log('[GAME] üéØ finalXpForChat:', finalXpForChat);
  console.log('[GAME] üìä Placar a ser enviado:', { myKills: oppLost, oppKills: myLost });
  
  // Limpar dados do match multiplayer do localStorage
  localStorage.removeItem("thor_match_id");
  localStorage.removeItem("thor_match_opponent_name");
  localStorage.removeItem("thor_match_opponent_id");
  localStorage.removeItem("thor_match_source");

  // Enviar mensagem ao parent para navegar
  if (window.parent && window.parent !== window) {
    try {
      if (multiplayerMode && matchId) {
        // Em multiplayer: voltar para o chat com resultado
        console.log('[GAME] Enviando THOR:RETURN_TO_CHAT');
        window.parent.postMessage({
          type: "THOR:RETURN_TO_CHAT",
          payload: {
            matchId: matchId,
            result: winner, // "VICTORY", "DEFEAT", "Empate!"
            myKills: oppLost,
            oppKills: myLost,
            opponentName: opponentName,
            xpGained: finalXpForChat // üéØ Usar XP salvo no fim do jogo
          }
        }, window.location.origin);
      } else {
        // Modo solo: voltar para sele√ß√£o de modo
        console.log('[GAME] Enviando THOR:GAME_OVER (modo solo)');
        window.parent.postMessage(
          { type: "THOR:GAME_OVER", payload: { score: clampScore() } },
          window.location.origin
        );
      }
    } catch (err) {
      console.error('[GAME] Erro ao enviar mensagem:', err);
    }
  }
  
  // Resetar winner
  winner = null;
}



// Exemplo: evento do bot√£o
document.getElementById('restartVictory').onclick = backToStartMenu;
document.getElementById('restartDefeat').onclick = backToStartMenu;
document.getElementById('restartDraw').onclick = backToStartMenu;

// Fun√ß√£o para criar part√≠culas de explos√£o
function spawnExplosionParticles(x, y, color = "#fff") {
  for (let i = 0; i < 18; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 2 + Math.random() * 3;
    particles.push({
      x,
      y,
      dx: Math.cos(angle) * speed,
      dy: Math.sin(angle) * speed,
      life: 16 + Math.random() * 16,
      color,
      size: 2.5 + Math.random() * 2
    });
  }
}

// Atualiza e desenha part√≠culas
function updateParticles(ctx) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.dx;
    p.y += p.dy;
    p.dy += 0.05; // leve gravidade
    p.life--;
    if (p.life <= 0) {
      particles.splice(i, 1);
    }
  }
}
function drawParticles(ctx) {
  for (const p of particles) {
    ctx.save();
    ctx.globalAlpha = Math.max(0, p.life / 20);
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

  let screenShake = 0;
let shakeX = 0, shakeY = 0;
let round = 1; // come√ßa em 1
let showingRoundText = true;
let roundTextAlpha = 0;
let roundTextFadeIn = true;
let roundTextTimer = 0;
const ROUND_TEXT_DISPLAY = 35; // frames (2s)
let planningTimer = 10; // segundos
let lastTime = Date.now();

const backgroundGalaxy = new Image();
backgroundGalaxy.src = "images/galaxia.png"; // Ser√° atualizado por applyGameBackground()
window.backgroundGalaxy = backgroundGalaxy; // Expor globalmente para applyGameBackground

const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const sfxHit = document.getElementById("sfx-hit");
const sfxShot = document.getElementById("sfx-shot");
const sfxExplode = document.getElementById("sfx-explode");

const NAVY_SIZE = 50;
const SPEED = 1.5;
let projectiles = [];
let explosions = [];
let wrecks = [];
let winner = null;


const spritePlayer = new Image();
spritePlayer.src = "images/spaceschip.png";
const spriteCPU = new Image();
spriteCPU.src = "images/spaceschip.png";

// Sprites vermelhos pr√©-carregados
const redSprites = {
  basic: new Image(),
  alcance: new Image(),
  protecao: new Image()
};
redSprites.basic.src = "images/nave_normal_red.png";
redSprites.alcance.src = "images/nave_alcance_red.png";
redSprites.protecao.src = "images/nave_protecao_red.png";

let mouseX = 0;
let mouseY = 0;
let selectedNave = null;
let phase = "roundText"; // Come√ßa mostrando o texto "Round 1"
let turnTime = 0;


let playerNaves = [];

// Aplicar MINHAS naves (control√°veis em playerNaves)
function applyMyShips(selecao, isP1) {
  if (!myTeam) {
    console.error('[PVP] myTeam √© null ao aplicar naves!');
  }
  
  // POSI√á√ïES F√çSICAS CORRETAS:
  // Player1 (isP1=true): TOPO esquerda (posi√ß√µes BLUE)
  // Player2 (isP1=false): BAIXO direita (posi√ß√µes RED)
  const posicoes = isP1 ? [
    { x: 100, y: 250 },  // P1 topo
    { x: 260, y: 80 },
    { x: 100, y: 80 }
  ] : [
    { x: 700, y: 520 },  // P2 baixo
    { x: 540, y: 520 },
    { x: 700, y: 350 }
  ];
  
  // Centro do campo advers√°rio para apontar as naves
  const opponentCenterX = isP1 ? 620 : 180;
  const opponentCenterY = isP1 ? 460 : 150;

  playerNaves = selecao.map((tipo, index) => {
    let hp = 99;
    let alcance = 300;
    let sprite = new Image();

    if (tipo === 1) {
      hp = 66; // Nave Alcance: 2 tiros para destruir (66 / 33 = 2)
      alcance = 360;
      sprite.src = "images/nave_alcance.png";
    } else if (tipo === 2) {
      hp = 132; // Nave Prote√ß√£o: 4 tiros para destruir (132 / 33 = 4)
      alcance = 160;
      sprite.src = "images/nave_protecao.png";
    } else {
      hp = 99; // Nave Normal: 3 tiros para destruir (99 / 33 = 3)
      alcance = 300;
      sprite.src = "images/spaceschip.png";
    }

    const nave = {
      x: posicoes[index].x,
      y: posicoes[index].y,
      target: null,
      shot: null,
      hp,
      angle: 0, // ser√° calculado abaixo
      tipo,
      sprite,
      alcance
    };
    
    console.log('[NAVE-INIT] playerNave', index, '- Tipo:', tipo, 'HP inicial:', hp, 'Alcance:', alcance);
    
    // Calcular √¢ngulo individual apontando para o centro advers√°rio
    const dx = opponentCenterX - nave.x;
    const dy = opponentCenterY - nave.y;
    nave.angle = Math.atan2(dy, dx) + Math.PI / 2;
    
    // COR DO TIME: P1 = AZUL (sem tint), P2 = VERMELHO (tint='red')
    if (multiplayerMode && !isP1) {
      nave.tint = 'red';
    }
    
    return nave;
  });
  
  console.log('[PVP] playerNaves aplicadas (isP1=' + isP1 + '):', playerNaves.map(n => ({ x: n.x, y: n.y, tipo: n.tipo, angle: n.angle, tint: n.tint })));
}

// Mant√©m compatibilidade com modo solo
function applyPlayerNavesFromSelection(selecao = null, isPlayer1Owner = true) {
  selecao = selecao || JSON.parse(localStorage.getItem("navesSelecionadas") || "[3,3,3]");
  if (multiplayerMode) {
    applyMyShips(selecao, isPlayer1Owner);
  } else {
    // Modo solo original
    try {
      const posicoes = [
        { x: 100, y: 250 },
        { x: 260, y: 80 },
        { x: 100, y: 80 }
      ];

      playerNaves = selecao.map((tipo, index) => {
        let hp = 99;
        let alcance = 300;
        let sprite = new Image();

        if (tipo === 1) {
          hp = 66;
          alcance = 360;
          sprite.src = "images/nave_alcance.png";
        } else if (tipo === 2) {
          hp = 132;
          alcance = 160;
          sprite.src = "images/nave_protecao.png";
        } else {
          hp = 99;
          alcance = 300;
          sprite.src = "images/spaceschip.png";
        }

        return {
          x: posicoes[index].x,
          y: posicoes[index].y,
          target: null,
          shot: null,
          hp,
          angle: 0,
          tipo,
          sprite,
          alcance
        };
      });
    } catch (err) {
      console.error('[SOLO] Erro ao aplicar naves do jogador:', err);
    }
  }
}


// Criar cpuNaves placeholder (ser√£o preenchidas depois)
const cpuNaves = Array.from({ length: 3 }, (_, i) => {
  const posicoes = [
    { x: 700, y: 520 },
    { x: 540, y: 520 },
    { x: 700, y: 350 }
  ];

  return {
    x: posicoes[i].x,
    y: posicoes[i].y,
    target: null,
    shot: null,
    hp: 0, // Inicialmente sem HP (ser√° preenchido depois)
    angle: 0,
    tipo: 3,
    sprite: new Image(),
    initialized: false
  };
});

// Inicializar cpuNaves como CPU padr√£o (apenas para modo solo)
function initCpuNaves() {
  if (multiplayerMode) {
    console.log('[PVP] Modo multiplayer - n√£o inicializar CPU');
    return;
  }
  
  console.log('[SOLO] Inicializando CPU para modo solo');
  cpuNaves.forEach((n, i) => {
    const tipo = Math.floor(Math.random() * 3) + 1;
    let sprite = new Image();
    if (tipo === 1) sprite.src = "images/nave_alcance.png";
    else if (tipo === 2) sprite.src = "images/nave_protecao.png";
    else sprite.src = "images/spaceschip.png";

    const hp = tipo === 1 ? 50 : tipo === 2 ? 100 : 75;

    n.tipo = tipo;
    n.sprite = sprite;
    n.hp = hp;
    n.initialized = true;
  });
}




canvas.addEventListener("mousemove", (e) => {
  const rect = canvas.getBoundingClientRect();
  mouseX = e.clientX - rect.left;
  mouseY = e.clientY - rect.top;
});

// ===============================
// Canvas Click Handler - Sele√ß√£o de naves, movimento e tiro
// ===============================
function handleCanvasClick(event) {
  console.log('[CLICK] handleCanvasClick chamado. phase:', phase, 'roundLocked:', roundLocked, 'selectedNave:', selectedNave);
  
  // N√£o permitir cliques se round est√° travado (todas as naves configuradas)
  if (roundLocked) {
    console.log('[CLICK] Bloqueado: roundLocked = true');
    return;
  }
  
  // N√£o permitir cliques durante anima√ß√µes ou pausas
  if (phase === "wait" || phase === "roundText" || phase === "pauseReadyGo") {
    console.log('[CLICK] Bloqueado por phase:', phase);
    return;
  }
  
  const rect = canvas.getBoundingClientRect();
  const clickX = event.clientX - rect.left;
  const clickY = event.clientY - rect.top;
  
  console.log('[CLICK] Posi√ß√£o do clique:', clickX, clickY);

  // FASE 1: Selecionar nave (se ainda n√£o h√° nave selecionada)
  // Aceita tanto "select" (multiplayer) quanto "selectMove" (solo)
  if (selectedNave === null && (phase === "selectMove" || phase === "select")) {
    console.log('[CLICK] Tentando selecionar nave. playerNaves:', playerNaves.map((n, i) => ({ i, x: n.x, y: n.y, hp: n.hp, ready: (n.target && n.shot) })));
    
    for (let i = 0; i < playerNaves.length; i++) {
      const nave = playerNaves[i];
      if (nave.hp <= 0) continue; // Pula naves destru√≠das
      
      // N√ÉO permitir selecionar nave que j√° est√° READY (tem target E shot)
      if (nave.target && nave.shot) {
        console.log('[CLICK] Nave', i, 'j√° est√° READY, pulando...');
        continue;
      }
      
      // Verificar se clicou na nave (dist√¢ncia < 50px - aumentado para facilitar clique)
      const dist = Math.hypot(clickX - nave.x, clickY - nave.y);
      console.log('[CLICK] Nave', i, 'dist√¢ncia:', dist.toFixed(1), 'px');
      
      if (dist < 50) {
        selectedNave = nave;
        // Manter a fase como est√° (n√£o for√ßar "selectMove" se est√° em "select")
        document.getElementById("legendArea").textContent = t('chooseDestination');
        console.log('[CLICK] ‚úÖ Nave selecionada:', i);
        return;
      }
    }
    console.log('[CLICK] ‚ùå Nenhuma nave selecionada (todas fora do alcance de 50px ou j√° READY)');
    return; // Se n√£o clicou em nenhuma nave, ignora
  }

  // FASE 2: Definir movimento (target)
  // S√≥ entra aqui se o target ainda N√ÉO foi definido
  if (selectedNave !== null && (phase === "selectMove" || phase === "select") && !selectedNave.target) {
    // Calcular dist√¢ncia do clique at√© a posi√ß√£o atual da nave
    const distFromNave = Math.hypot(clickX - selectedNave.x, clickY - selectedNave.y);
    console.log('[CLICK] Fase 2 - Movimento. Dist√¢ncia:', distFromNave.toFixed(1), 'Alcance:', selectedNave.alcance);
    
    // Verificar se est√° dentro do alcance de movimento
    if (distFromNave <= selectedNave.alcance) {
      // Permitir clicar onde a nave est√° (target = posi√ß√£o atual = nave fica parada)
      selectedNave.target = { x: clickX, y: clickY };
      
      // Em modo solo, mudar para selectShot. Em multiplayer, manter "select"
      if (!multiplayerMode) {
        phase = "selectShot";
      }
      
      document.getElementById("legendArea").textContent = t('chooseTarget');
      console.log('[CLICK] ‚úÖ Target definido:', selectedNave.target);
    } else {
      // Fora do alcance - ignorar ou mostrar feedback
      console.log('[CLICK] ‚ùå Fora do alcance de movimento. Dist√¢ncia:', distFromNave, 'Alcance:', selectedNave.alcance);
    }
    return;
  }

  // FASE 3: Definir tiro (shot)
  // Em multiplayer phase fica "select", em solo muda para "selectShot"
  if (selectedNave !== null && (phase === "selectShot" || (phase === "select" && selectedNave.target !== null))) {
    selectedNave.shot = { x: clickX, y: clickY };
    console.log('[CLICK] Fase 3 - Shot definido');

    // Verificar se em multiplayer e se todas as naves j√° configuradas
    if (multiplayerMode) {
      const allShipsReady = playerNaves.filter(nav => nav.hp > 0).every(nav => nav.target && nav.shot);
      console.log('[CLICK] Todas as naves prontas?', allShipsReady);
      console.log('[CLICK] playerNaves status:', playerNaves.map((n, i) => ({ 
        index: i, hp: n.hp, hasTarget: !!n.target, hasShot: !!n.shot 
      })));
  
      if (allShipsReady) {
        console.log('[PVP] ‚úÖ Todas as naves configuradas! Enviando a√ß√£o via Supabase...');
        console.log('[PVP] myUserId:', myUserId);
        console.log('[PVP] matchData.player1_id:', matchData?.player1_id);
        console.log('[PVP] Sou Player 1?', myUserId === matchData?.player1_id);
    
        // Coletar a√ß√µes de todas as naves
        const ships = playerNaves.map((n, idx) => ({
          index: idx,
          target: n.target ? { x: n.target.x, y: n.target.y } : null,
          shot: n.shot ? { x: n.shot.x, y: n.shot.y } : null,
          hp: n.hp,
          angle: n.angle
        }));
    
        // Enviar via sistema de database
        submitMyAction({
          type: 'play',
          ships: ships
        });
    
        roundLocked = true; // Travar cliques mas manter phase
        selectedNave = null;
        document.getElementById("legendArea").textContent = t('waitingOpponentShort');
        console.log('[CLICK] ‚úÖ A√ß√£o enviada, aguardando oponente...');
      } else {
        // Algumas naves configuradas, continuar
        broadcastRealtimeState();
        selectedNave = null;
        // Manter phase = "select" em multiplayer
        document.getElementById("legendArea").textContent = t('selectAnotherShip');
      }
    } else {
      // Modo solo
      selectedNave = null;
      if (playerNaves.filter(n => n.hp > 0).every(n => n.shot)) {
        phase = "wait";
        generateCpuOrders();
        fireProjectiles();
        document.getElementById("legendArea").textContent = t('attentionCommander');
      } else {
        phase = "selectMove";
        document.getElementById("legendArea").textContent = t('selectAnotherShip');
      }
    }
    return;
  }
}

// Registrar event listener de click
canvas.addEventListener('click', function(event) {
  handleCanvasClick(event);
});


function isCritical(nave) {
  return nave.hp > 0 && nave.hp <= 33; // 33 ou menos, pronto para explodir no pr√≥ximo tiro
}



function drawNave(nave, image, isCPU = false) {
  if (nave.hp <= 0) return;

  ctx.save();

  // Escolhe sprite: player usa nave.sprite, CPU usa image padr√£o
  let spriteToUse = !isCPU && nave.sprite ? nave.sprite : image;

  let tremorX = 0, tremorY = 0, naveAlpha = 1;
    const isMoving = nave.target !== null;
const idleBob = isMoving ? 0 : Math.sin(performance.now() / 500 + nave.x) * 2.0;
  if (isCritical(nave)) {
    tremorX = (Math.random() - 0.5) * 8;
    tremorY = (Math.random() - 0.5) * 8;
    naveAlpha = 0.5 + 0.5 * Math.sin(performance.now() / 80);
  }




  const fallback = isCPU ? { x: nave.x - 100, y: nave.y - 100 } : { x: nave.x + 100, y: nave.y + 100 };
  const target = nave.target || fallback;
  const dx = target.x - nave.x;
  const dy = target.y - nave.y;
  const desiredAngle = Math.atan2(dy, dx) + Math.PI / 2;
  
  // CORRE√á√ÉO: Se nave.angle j√° foi definido e n√£o h√° target real, manter o √¢ngulo inicial
  // N√£o recalcular baseado no fallback!
  if (nave.angle === undefined || nave.angle === null) {
    nave.angle = desiredAngle;
  } else if (nave.target !== null) {
    // S√≥ interpolar se houver um target REAL (n√£o fallback)
    nave.angle += (desiredAngle - nave.angle) * 0.15;
  }
  // Caso contr√°rio, manter nave.angle fixo (n√£o recalcular com fallback)

  ctx.translate(nave.x + tremorX, nave.y + tremorY + idleBob);
  ctx.rotate(nave.angle);
  ctx.globalAlpha = naveAlpha;

  // Se tint vermelho, usar sprite vermelho pr√©-carregado
  if (nave.tint === 'red') {
    if (nave.tipo === 1 && redSprites.alcance.complete) {
      spriteToUse = redSprites.alcance;
    } else if (nave.tipo === 2 && redSprites.protecao.complete) {
      spriteToUse = redSprites.protecao;
    } else if (nave.tipo === 3 && redSprites.basic.complete) {
      spriteToUse = redSprites.basic;
    }
  }
  
  // Desenhar a nave
  ctx.drawImage(spriteToUse, -NAVY_SIZE / 2, -NAVY_SIZE / 2, NAVY_SIZE, NAVY_SIZE);
  
  ctx.globalAlpha = 1;
  ctx.restore();

  // Indica√ß√£o visual de nave selecionada (compara√ß√£o direta de objeto)
  if (!isCPU && selectedNave === nave) {
    const pulse = 0.7 + 0.3 * Math.sin(selectPulseTime * 2);
    ctx.save();
    ctx.beginPath();
    ctx.arc(nave.x, nave.y, NAVY_SIZE * (1 + 0.11 * pulse), 0, Math.PI * 2);
    ctx.globalAlpha = 0.4 + 0.3 * pulse;
    ctx.strokeStyle = "#0ff";
    ctx.lineWidth = 5 + 4 * pulse;
    ctx.shadowColor = "#0ff";
    ctx.shadowBlur = 18 + 14 * pulse;
    ctx.stroke();
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  if (!isCPU && nave.target && nave.shot) {
    ctx.save();
    ctx.font = "bold 14px sans-serif";
    ctx.textAlign = "center";
    ctx.fillStyle = "#ff0";
    ctx.strokeStyle = "#222";
    ctx.lineWidth = 3;
    ctx.strokeText("READY", nave.x, nave.y - NAVY_SIZE);
    ctx.fillText("READY", nave.x, nave.y - NAVY_SIZE);
    ctx.restore();
  }

  ctx.fillStyle = "red";
ctx.fillRect(nave.x - 15, nave.y - NAVY_SIZE / 2 - 10, 30, 5);

let maxHP = nave.tipo === 1 ? 50 : nave.tipo === 2 ? 100 : 75;
ctx.fillStyle = "lime";
ctx.fillRect(nave.x - 15, nave.y - NAVY_SIZE / 2 - 10, 30 * (nave.hp / maxHP), 5);



}


// Supondo que voc√™ j√° tem:
const startBtn = document.getElementById("startBtn");
const startModal = document.getElementById("startModal");
const galaxyBg = document.getElementById("galaxyBg");
const thorspaceTitle = document.getElementById("thorspace-title");
const playerNameInput = document.getElementById("playerNameInput");

// Fun√ß√£o √∫nica para checar se sele√ß√£o est√° travada
function isSelectionLocked() {
  // matchPhase pode ser currentPhase ou match.phase dependendo do contexto
  const phase = (typeof match !== 'undefined' && match && match.phase) ? match.phase : (typeof currentPhase !== 'undefined' ? currentPhase : null);
  const locked = (phase !== 'select') || (PVP.battleStarted === true) || (PVP.localTurnSubmitted === true) || (PVP.waitingOpponent === true);
  if (locked) {
    console.log('[INPUT] bloqueado', { phase, battleStarted: PVP.battleStarted, localTurnSubmitted: PVP.localTurnSubmitted, waitingOpponent: PVP.waitingOpponent });
  }
  return locked;
}


function moveTowards(nave) {
  if (!nave.target || nave.hp <= 0) return;
  
  const dx = nave.target.x - nave.x;
  const dy = nave.target.y - nave.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  
  if (dist < SPEED) {
    nave.x = nave.target.x;
    nave.y = nave.target.y;
    nave.target = null;
  } else {
    nave.x += SPEED * dx / dist;
    nave.y += SPEED * dy / dist;
  }
  nave.x = Math.max(NAVY_SIZE / 2, Math.min(canvas.width - NAVY_SIZE / 2, nave.x));
  nave.y = Math.max(NAVY_SIZE / 2, Math.min(canvas.height - NAVY_SIZE / 2, nave.y));
}

function generateCpuOrders() {
  // Em modo PVP real, n√£o gerar ordens autom√°ticas de CPU
  if (multiplayerMode) {
    console.log('[PVP] Modo PVP ativo - CPU desabilitada, a√ß√µes vem do Supabase');
    return;
  }
  
  console.log('[SOLO] Gerando ordens da CPU');
  cpuNaves.forEach((n, i) => {
    if (n.hp <= 0) return;

    // Gera um destino aleat√≥rio pr√≥ximo
    const angle = Math.random() * Math.PI * 2;
    const distance = 80 + Math.random() * 120;
    const nx = n.x + Math.cos(angle) * distance;
    const ny = n.y + Math.sin(angle) * distance;

    // Limita dentro da tela
    n.target = {
      x: Math.max(NAVY_SIZE/2, Math.min(800 - NAVY_SIZE/2, nx)),
      y: Math.max(NAVY_SIZE/2, Math.min(600 - NAVY_SIZE/2, ny))
    };

    // Mira em uma nave do player ainda viva (simples: escolhe a primeira viva)
    let targetNave = playerNaves.find(pn => pn.hp > 0);
    if (targetNave) {
      n.shot = { x: targetNave.x, y: targetNave.y };
    }
  });
}



function applyScreenShake() {
  if (screenShake > 0) {
    shakeX = (Math.random() - 0.5) * screenShake * 4;
    shakeY = (Math.random() - 0.5) * screenShake * 4;
    screenShake--;
  } else {
    shakeX = 0;
    shakeY = 0;
  }
}


function areNavesColliding(n1, n2) {
  if (n1.hp <= 0 || n2.hp <= 0) return false;
  const dx = n1.x - n2.x;
  const dy = n1.y - n2.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  return dist < NAVY_SIZE; // Troque NAVY_SIZE para ajustar a "sensibilidade" da colis√£o
}

function checkNaveCollisions() {
  let alreadyExploded = new Set();

  // Player vs Player (colidiu duas naves suas: -25 pontos por colis√£o)
  for (let i = 0; i < playerNaves.length; i++) {
    for (let j = i + 1; j < playerNaves.length; j++) {
      const id = "p" + i + "p" + j;
      if (!alreadyExploded.has(id) && areNavesColliding(playerNaves[i], playerNaves[j])) {
        if (playerNaves[i].hp > 0 && playerNaves[j].hp > 0) {
          playerDestroyed += 2;
          playerScore -= 25;               // -25 pontos por colis√£o de DUAS naves SUAS
          collisionPlayerSolo++;           // ADICIONE ESTA LINHA: conta quantas colis√µes pr√≥prias
          playerNaves[i].hp = 0;
          playerNaves[j].hp = 0;
          
          // ‚úÖ XP: Colis√£o com nave aliada
          registerXPEvent('FRIENDLY_COLLISION');
          roundCollisionLosses += 2; // Contar separadamente (n√£o soma em roundLosses)
          
          explosions.push({ x: playerNaves[i].x, y: playerNaves[i].y, radius: 1, big: true, flash: 8 });
          explosions.push({ x: playerNaves[j].x, y: playerNaves[j].y, radius: 1, big: true, flash: 8 });
          spawnExplosionParticles(playerNaves[i].x, playerNaves[i].y, "#0ff");
          spawnExplosionParticles(playerNaves[j].x, playerNaves[j].y, "#0ff");
          wrecks.push({ x: playerNaves[i].x, y: playerNaves[i].y });
          wrecks.push({ x: playerNaves[j].x, y: playerNaves[j].y });
          sfxExplode.play();
          screenShake = 10;
          alreadyExploded.add(id);
        }
      }
    }
  }

  // CPU vs CPU (colidiu sozinho: +25 pontos pra voc√™ por colis√£o deles)
  for (let i = 0; i < cpuNaves.length; i++) {
    for (let j = i + 1; j < cpuNaves.length; j++) {
      const id = "c" + i + "c" + j;
      if (!alreadyExploded.has(id) && areNavesColliding(cpuNaves[i], cpuNaves[j])) {
        if (cpuNaves[i].hp > 0 && cpuNaves[j].hp > 0) {
          cpuDestroyed += 2;
          playerScore += 25;               // +25 pontos por colis√£o de DUAS naves CPU
          collisionCpuSolo++;              // ADICIONE ESTA LINHA: conta quantas colis√µes CPU x CPU
          cpuNaves[i].hp = 0;
          cpuNaves[j].hp = 0;
          explosions.push({ x: cpuNaves[i].x, y: cpuNaves[i].y, radius: 1, big: true, flash: 8 });
          explosions.push({ x: cpuNaves[j].x, y: cpuNaves[j].y, radius: 1, big: true, flash: 8 });
          spawnExplosionParticles(cpuNaves[i].x, cpuNaves[i].y, "#ff6600");
          spawnExplosionParticles(cpuNaves[j].x, cpuNaves[j].y, "#ff6600");
          wrecks.push({ x: cpuNaves[i].x, y: cpuNaves[i].y });
          wrecks.push({ x: cpuNaves[j].x, y: cpuNaves[j].y });
          sfxExplode.play();
          screenShake = 10;
          alreadyExploded.add(id);
        }
      }
    }
  }

  // Player vs CPU (cada um perde uma nave; score est√° no updateProjectiles)
  for (let i = 0; i < playerNaves.length; i++) {
    for (let j = 0; j < cpuNaves.length; j++) {
      const id = "p" + i + "c" + j;
      if (!alreadyExploded.has(id) && areNavesColliding(playerNaves[i], cpuNaves[j])) {
        if (playerNaves[i].hp > 0 && cpuNaves[j].hp > 0) {
          playerNaves[i].hp = 0;
          cpuNaves[j].hp = 0;
          playerDestroyed += 1;
          cpuDestroyed += 1;
          // N√ÉO soma score aqui, pois updateProjectiles j√° faz isso!
          
          // ‚úÖ XP: Colis√£o com nave inimiga
          registerXPEvent('ENEMY_COLLISION');
          roundKills++;
          roundCollisionLosses++; // Contar separadamente
          
          explosions.push({ x: playerNaves[i].x, y: playerNaves[i].y, radius: 1, big: true, flash: 8 });
          explosions.push({ x: cpuNaves[j].x, y: cpuNaves[j].y, radius: 1, big: true, flash: 8 });
          spawnExplosionParticles(playerNaves[i].x, playerNaves[i].y, "#0ff");
          spawnExplosionParticles(cpuNaves[j].x, cpuNaves[j].y, "#ff6600");
          wrecks.push({ x: playerNaves[i].x, y: playerNaves[i].y });
          wrecks.push({ x: cpuNaves[j].x, y: cpuNaves[j].y });
          sfxExplode.play();
          screenShake = 10;
          alreadyExploded.add(id);
        }
      }
    }
  }
}



function buildScoreDetails() {
  console.log('[buildScoreDetails] üìä xpEvents:', JSON.parse(JSON.stringify(xpEvents)));
  console.log('[buildScoreDetails] üìä xpTotalMatch:', xpTotalMatch);
  
  // ‚úÖ USAR EVENTOS DE XP OFICIAIS
  // Filtrar apenas eventos que realmente ocorreram (n√£o exibir eventos com XP 0 ou que n√£o aconteceram)
  const activeEvents = xpEvents.filter(event => event.xp !== 0);
  
  console.log('[buildScoreDetails] üìä activeEvents ap√≥s filter:', JSON.parse(JSON.stringify(activeEvents)));
  
  if (activeEvents.length === 0) {
    return `
      <div class="score-grid">
        <div class="score-hex inactive">
          <div class="hex-outline"></div>
          <div class="hex-title">Nenhum evento</div>
          <div class="hex-points">0</div>
        </div>
      </div>
    `;
  }
  
  // Agrupar eventos por tipo para evitar m√∫ltiplas entradas do mesmo evento
  const eventGroups = {};
  activeEvents.forEach(event => {
    if (!eventGroups[event.key]) {
      eventGroups[event.key] = {
        name: event.name,
        xp: 0,
        count: 0
      };
    }
    eventGroups[event.key].xp += event.xp;
    eventGroups[event.key].count++;
  });
  
  console.log('[buildScoreDetails] üìä eventGroups:', JSON.parse(JSON.stringify(eventGroups)));
  
  // Converter grupos em array de items (SEM mostrar o multiplicador)
  const items = Object.values(eventGroups).map(group => ({
    title: group.name, // Remover o "(5x)" - apenas mostrar o nome
    value: group.xp,
    active: true
  }));
  
  console.log('[buildScoreDetails] üìä items finais:', JSON.parse(JSON.stringify(items)));
  
  // Ordenar: positivos primeiro, depois negativos
  items.sort((a, b) => b.value - a.value);
  
  const html = `
    <div class="score-grid">
      ${items.map(it => `
        <div class="score-hex active">
          <div class="hex-outline"></div>
          <div class="hex-title">${it.title}</div>
          <div class="hex-points">${formatPoints(it.value)}</div>
        </div>
      `).join("")}
    </div>
  `;
  return html;
}

function formatPoints(v){
  if (v === 0) return "0";
  if (v > 0) return `+${v}`;
  return `${v}`; // negativo j√° vem com "-"
}


function getEdgePoint(from, to, canvasWidth = canvas.width, canvasHeight = canvas.height) {
  const dx = to.x - from.x;
  const dy = to.y - from.y;
  if (dx === 0 && dy === 0) return { x: from.x, y: from.y };

  // Fatores de interse√ß√£o com cada borda (esq, dir, cima, baixo)
  let tValues = [];
  // Esquerda
  if (dx !== 0) {
    let t = (0 - from.x) / dx;
    let y = from.y + t * dy;
    if (t > 0 && y >= 0 && y <= canvasHeight) tValues.push(t);
  }
  // Direita
  if (dx !== 0) {
    let t = (canvasWidth - from.x) / dx;
    let y = from.y + t * dy;
    if (t > 0 && y >= 0 && y <= canvasHeight) tValues.push(t);
  }
  // Topo
  if (dy !== 0) {
    let t = (0 - from.y) / dy;
    let x = from.x + t * dx;
    if (t > 0 && x >= 0 && x <= canvasWidth) tValues.push(t);
  }
  // Base
  if (dy !== 0) {
    let t = (canvasHeight - from.y) / dy;
    let x = from.x + t * dx;
    if (t > 0 && x >= 0 && x <= canvasWidth) tValues.push(t);
  }

  // O menor t positivo te leva at√© a primeira borda
  let tMin = Math.min(...tValues);
  return {
    x: from.x + dx * tMin,
    y: from.y + dy * tMin
  };
}



function fireProjectiles() {
  const PROJECTILE_SPEED = 6; // antes estava super lento
  
  console.log('[COMBAT] üí• fireProjectiles chamada');
  console.log('[COMBAT] playerNaves:', playerNaves.map(n => ({ hp: n.hp, shot: n.shot })));
  console.log('[COMBAT] cpuNaves:', cpuNaves.map(n => ({ hp: n.hp, shot: n.shot })));

  playerNaves.forEach((n, idx) => {
    if (n.shot && n.hp > 0) {
      console.log('[COMBAT] Player nave #' + idx + ' disparando!');
      sfxShot.play();
      const end = getEdgePoint({ x: n.x, y: n.y }, n.shot);
      const dist = Math.sqrt((end.x - n.x) ** 2 + (end.y - n.y) ** 2);
      const dx = (end.x - n.x) / dist * PROJECTILE_SPEED;
      const dy = (end.y - n.y) / dist * PROJECTILE_SPEED;
      projectiles.push({
        x: n.x,
        y: n.y,
        prevX: n.x,
        prevY: n.y,
        dx,
        dy,
        target: "cpu"
      });
      
      // Broadcast tiro em modo multiplayer
      if (multiplayerMode) {
        broadcastShot(n.x, n.y, dx, dy);
      }
    }
  });

  cpuNaves.forEach((n, idx) => {
    if (n.shot && n.hp > 0) {
      console.log('[COMBAT] ' + (multiplayerMode ? 'Oponente' : 'CPU') + ' nave #' + idx + ' disparando!');
      sfxShot.play();
      const end = getEdgePoint({ x: n.x, y: n.y }, n.shot);
      const dist = Math.sqrt((end.x - n.x) ** 2 + (end.y - n.y) ** 2);
      const dx = (end.x - n.x) / dist * PROJECTILE_SPEED;
      const dy = (end.y - n.y) / dist * PROJECTILE_SPEED;
      projectiles.push({
        x: n.x,
        y: n.y,
        prevX: n.x,
        prevY: n.y,
        dx,
        dy,
        target: "player"
      });
    }
  });
  
  console.log('[COMBAT] Total proj√©teis criados:', projectiles.length);
}





/**
 * SWEPT COLLISION DETECTION (Raycast)
 * Testa se o segmento de linha (x1,y1) ‚Üí (x2,y2) intersecta um c√≠rculo.
 * Usado para detectar colis√µes de proj√©teis que movem r√°pido demais
 * e poderiam "pular" frames atravessando naves sem colidir.
 * 
 * Funcionamento:
 * - Testa a trajet√≥ria completa do proj√©til entre frames
 * - Garante que nenhum tiro atravesse uma nave sem registrar hit
 * - Usa equa√ß√£o quadr√°tica para resolver interse√ß√£o linha-c√≠rculo
 * 
 * @param {number} x1, y1 - Posi√ß√£o anterior do proj√©til
 * @param {number} x2, y2 - Posi√ß√£o atual do proj√©til
 * @param {number} cx, cy - Centro da nave (alvo)
 * @param {number} r - Raio de colis√£o da nave
 * @returns {boolean} true se h√° interse√ß√£o
 */
function segmentIntersectsCircle(x1, y1, x2, y2, cx, cy, r) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  const fx = x1 - cx;
  const fy = y1 - cy;

  const a = dx * dx + dy * dy;
  const b = 2 * (fx * dx + fy * dy);
  const c = fx * fx + fy * fy - r * r;
  
  let discriminant = b * b - 4 * a * c;
  
  // Se discriminante < 0, a linha n√£o intersecta o c√≠rculo
  if (discriminant < 0) return false;

  discriminant = Math.sqrt(discriminant);
  const t1 = (-b - discriminant) / (2 * a);
  const t2 = (-b + discriminant) / (2 * a);

  // Se algum t entre 0 e 1, h√° interse√ß√£o no segmento
  // Tamb√©m verificar se o segmento come√ßa ou termina dentro do c√≠rculo
  if ((t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1)) return true;
  
  // Verificar se o segmento atravessa completamente o c√≠rculo
  if (t1 < 0 && t2 > 1) return true;
  
  return false;
}


// Substitua toda a fun√ß√£o updateProjectiles pelo bloco abaixo
function updateProjectiles() {
  for (let i = projectiles.length - 1; i >= 0; i--) {
    const p = projectiles[i];
    // Salvar posi√ß√£o anterior ANTES de mover
    p.prevX = p.x;
    p.prevY = p.y;
    // Aplicar movimento
    p.x += p.dx;
    p.y += p.dy;
    let hit = false;

    // Checa colis√£o com naves usando swept collision (raycast)
    const targets = p.target === "cpu" ? cpuNaves : playerNaves;
    for (let t of targets) {
      if (t.hp <= 0) continue;
      if (segmentIntersectsCircle(p.prevX, p.prevY, p.x, p.y, t.x, t.y, (NAVY_SIZE * 0.6))) {
        console.log(`[HP-SYNC] üéØ HIT! Nave tipo=${t.tipo}, HP ANTES=${t.hp}, DANO=33`);
        t.hp -= 33;
        // Garantir que HP n√£o fique negativo
        if (t.hp < 0) t.hp = 0;
        console.log(`[HP-SYNC] üíî HP DEPOIS=${t.hp}${t.hp <= 0 ? ' (DESTRU√çDA)' : ''}`);
        
        sfxHit.play();
        explosions.push({ x: t.x, y: t.y, radius: 1 });

        if (t.hp <= 0) {
          sfxExplode.play();
          wrecks.push({ x: t.x, y: t.y });
          spawnExplosionParticles(
            t.x, t.y,
            (targets === cpuNaves) ? "#ff6600" : "#0ff"
          );
          screenShake = 10;

          // Atualiza o placar e SCORE
          if (targets === cpuNaves) {
            cpuDestroyed++;        // Incrementa kills do oponente (naves do CPU destru√≠das)
            playerScore += 100;     // +100 por abater nave do CPU
            
            // ‚úÖ XP: Nave inimiga destru√≠da
            roundKills++;
            registerXPEvent('DESTROY_ENEMY_SHIP');
            
            // ‚úÖ XP: Clutch Kill (√∫ltima nave do jogador destruindo inimigo)
            const aliveFriendly = playerNaves.filter(n => n.hp > 0).length;
            if (aliveFriendly === 1) {
              registerXPEvent('CLUTCH_KILL');
            }
          } else {
            playerDestroyed++;      // Incrementa minhas perdas (naves do player destru√≠das)
            navesPerdidas++;        // Contador espec√≠fico para c√°lculo de score
            playerScore -= 50;      // -50 por perder nave para o CPU
            
            // ‚úÖ XP: Apenas contar perdas (processar no final do round)
            roundLosses++;
          }
        } else {
          // ‚úÖ XP: Tracking de streak de acertos (3 hits consecutivos na mesma nave)
          if (targets === cpuNaves) {
            const targetIndex = cpuNaves.indexOf(t);
            if (targetIndex >= 0) {
              roundHitStreaks[targetIndex] = (roundHitStreaks[targetIndex] || 0) + 1;
              
              // Precis√£o absoluta: 3 acertos consecutivos sem errar
              if (roundHitStreaks[targetIndex] === 3) {
                registerXPEvent('PRECISION_HIT_STREAK');
                roundHitStreaks[targetIndex] = 0; // Reset para evitar duplicatas
              }
            }
          }
        }

        projectiles.splice(i, 1);
        hit = true;
        break;
      }
    }
    // Remove s√≥ se realmente saiu da tela (borda do canvas!)
    if (!hit && (p.x < 0 || p.x > canvas.width || p.y < 0 || p.y > canvas.height)) {
      projectiles.splice(i, 1);
    }
  }
}




function updateExplosions() {
  for (let i = explosions.length - 1; i >= 0; i--) {
    explosions[i].radius += explosions[i].big ? 2.5 : 1.5;
    if (explosions[i].radius > (explosions[i].big ? 40 : 15)) explosions.splice(i, 1);
  }
}


function updateGame() {
  updateParticles(ctx);
  
  // Sincroniza√ß√£o multiplayer - APENAS verificar conex√£o
  // A) N√ÉO sincronizar movimento em tempo real
  if (multiplayerMode) {
    checkRemoteConnection();
  }

// --- Tela READY/GO! ---
  if (showReadyGo) {
    // Fade in/out igual ao Round X
    if (readyGoStep === 0) { // READY?
      if (readyGoAlpha < 1) readyGoAlpha += 0.07;
      else readyGoTimer++;
      if (readyGoTimer > 60) { // 1s (60 frames)
        readyGoStep = 1;
        readyGoText = "Go!";
        readyGoTimer = 0;
        readyGoAlpha = 0;
      }
    } else if (readyGoStep === 1) { // GO!
      if (readyGoAlpha < 1) readyGoAlpha += 0.15;
      else readyGoTimer++;
      if (readyGoTimer > 20) { // 0.33s
        readyGoStep = 2;
        readyGoAlpha -= 0.13;
      }
    } else if (readyGoStep === 2) {
      readyGoAlpha -= 0.13;
  if (readyGoAlpha <= 0) {
  readyGoAlpha = 0;
  showReadyGo = false;
  planningTimer = 10;
  lastTime = Date.now();
  phase = "selectMove";
  isInteracting = false; // Resetar interaction lock
  document.getElementById("legendArea").textContent = t('clickShipToMove');
  document.getElementById("hudTop").style.display = "block"; // <-- Adicione aqui!
  
  // Aplicar estado pendente se houver
  if (pendingRemoteState) {
    console.log('[REALTIME] üì• Aplicando estado pendente ap√≥s Ready/Go');
    const pending = pendingRemoteState;
    pendingRemoteState = null;
    applyMatchUpdate(pending, currentPhase, currentTurnNumber, turnUserId, matchData?.turn_deadline_at, matchData?.turn_resolved_at);
  }
}

    }
    return; // Pausa todo o resto enquanto exibe Ready/Go!
  }

  if (winner) return;

  if (phase === "roundText") {
     document.getElementById("hudTop").style.display = "none";
    // Fade in/out do texto "Round X"
    if (roundTextFadeIn) {
      roundTextAlpha += 0.05;
      if (roundTextAlpha >= 1) {
        roundTextAlpha = 1;
        roundTextFadeIn = false;
      }
    } else {
      roundTextTimer++;
      if (roundTextTimer > ROUND_TEXT_DISPLAY) {
        roundTextAlpha -= 0.05;
        if (roundTextAlpha <= 0) {
          roundTextAlpha = 0;
          showingRoundText = false;
          resetTurn();
        }
      }
    }
    return;
  }

  if (phase === "wait") {
    // GUARD: Se jogo terminou, n√£o processar mais nada
    if (!gameActive || winner) {
      console.log('[GAME] ‚ö†Ô∏è Jogo terminado, ignorando phase=wait');
      return;
    }
    
    playerNaves.forEach(moveTowards);
    cpuNaves.forEach(moveTowards);
    
    checkNaveCollisions();
    updateProjectiles();
    updateExplosions();
    
    // IMPORTANTE: Aguardar TODAS as anima√ß√µes terminarem antes de verificar fim de round
    // - projectiles.length === 0: todos os tiros chegaram ao destino
    // - explosions.length === 0: todas as explos√µes terminaram
    if (projectiles.length === 0 && explosions.length === 0) {
      // ‚úÖ XP: Processar eventos de round
      processRoundXPEvents();
      
      // Sincronizar HP ANTES de verificar vit√≥ria
      if (multiplayerMode) {
        syncShipsHP();
      }
      
      const gameEnded = checkWinCondition();
      if (gameEnded) {
        // Jogo terminou, n√£o avan√ßar para pr√≥ximo round
        return;
      }
      
      // Resetar targets e shots para pr√≥ximo turno
      playerNaves.forEach(n => {
        n.target = null;
        n.shot = null;
      });
      cpuNaves.forEach(n => {
        n.target = null;
        n.shot = null;
      });
      
      if (!winner) {
        if (multiplayerMode) {
          // Em multiplayer, voltar para sele√ß√£o (pr√≥ximo turno via Realtime)
          phase = "selectMove";
          isInteracting = false; // Garantir que n√£o est√° mais interagindo
          
          console.log('[TURN] Anima√ß√µes conclu√≠das, iniciando pr√≥ximo turno...');
          console.log('[TURN] currentTurnNumber:', currentTurnNumber);
          document.getElementById("legendArea").textContent = t('nextTurn');
          
          // Resetar flag de a√ß√£o enviada
          myActionSubmitted = false;
          
          // Iniciar nova janela de turno
          if (matchData && matchData.turn_deadline_at) {
            console.log('[TURN] Iniciando nova janela com deadline:', matchData.turn_deadline_at);
            startTurnWindow(matchData.turn_deadline_at);
          } else {
            console.warn('[TURN] ‚ö†Ô∏è Sem deadline para novo turno!');
          }
          
          // Aplicar estado pendente se houver
          if (pendingRemoteState) {
            console.log('[REALTIME] üì• Aplicando estado pendente ap√≥s fim de turno');
            const pending = pendingRemoteState;
            pendingRemoteState = null;
            applyMatchUpdate(pending, currentPhase, currentTurnNumber, turnUserId, matchData?.turn_deadline_at, matchData?.turn_resolved_at);
          }
        } else {
          // Modo solo: Round text
          phase = "roundText";
          showingRoundText = true;
          roundTextAlpha = 0;
          roundTextFadeIn = true;
          roundTextTimer = 0;
          round++;
        }
      } else {
        resetTurn();
      }
    }
  }

  // Adicione esta parte para permitir planejamento quando n√£o est√° mostrando roundText
  // IMPORTANTE: N√ÉO usar planningTimer no modo multiplayer (use timer do Supabase)
  if ((phase === "selectMove" || phase === "selectShot") && !showingRoundText && !multiplayerMode) {
    const now = Date.now();
    if (now - lastTime >= 1000) {
  planningTimer--;
  lastTime = now;
  if (planningTimer <= 0) {
    phase = "wait";
    selectedNave = null;
    document.getElementById("legendArea").textContent = t('attentionCommander');
    generateCpuOrders();
    fireProjectiles();
  }
}

    // ATUALIZA O TIMER NO HUD:
    const timerSpan = document.getElementById("timerText");
    timerSpan.textContent = planningTimer.toString().padStart(2, "0");
    timerSpan.style.color = (planningTimer > 3) ? "#14ffff" : "#ff4242";
    timerSpan.style.textShadow = (planningTimer > 3) 
      ? "0 0 14px #0ff8"
      : "0 0 18px #ff424299";
  }
}


function resetTurn() {
   cpuDestroyedAntesDoRound = cpuDestroyed; // Salva quantas j√° estavam destru√≠das antes deste round
  playerNaves.forEach(n => { n.shot = null; n.target = null; });
  cpuNaves.forEach(n => { n.shot = null; n.target = null; });
  projectiles = [];
  explosions = [];
  selectedNave = null;
  
  // ‚úÖ XP: Resetar tracking de round
  resetRoundXPTracking();

  // 3) Garantir que fleetSlots/fleetLocked n√£o s√£o resetados por resets/snapshots
  console.log('[ROUND] resetRound: fleetLocked=', PVP.fleetLocked, 'fleetSlots=', PVP.fleetSlots);

if (!winner) {
  // IN√çCIO DO READY/GO!
  showReadyGo = true;
  readyGoText = "Ready?";
  readyGoAlpha = 0;
  readyGoStep = 0;
  readyGoTimer = 0;
  phase = "pauseReadyGo"; // nova fase pausa!
}

const timerSpan = document.getElementById("timerText");
timerSpan.textContent = planningTimer.toString().padStart(2, "0");
timerSpan.style.color = "#14ffff";
timerSpan.style.textShadow = "0 0 14px #0ff8";
  document.getElementById("hudTop").style.display = "none"; // <-- Adicione aqui!



}


function checkWinCondition() {
  // Calcular perdas totais (combate + autocolis√£o)
  const myLost = getMyLost();
  const oppLost = getOppLost();
  
  console.log('[WIN] checkWinCondition chamada:');
  console.log('[WIN]   - myLost:', myLost, '(playerNaves hp:', playerNaves.map(n => n.hp), ')');
  console.log('[WIN]   - oppLost:', oppLost, '(cpuNaves hp:', cpuNaves.map(n => n.hp), ')');

  // Condi√ß√£o de fim de jogo: 3 naves destru√≠das de qualquer lado
  if (myLost >= 3 || oppLost >= 3) {
    console.log('[WIN] üèÅ Jogo terminado! myLost=' + myLost + ', oppLost=' + oppLost);
    
    // Parar o jogo
    gameActive = false;
    phase = 'finished';

    // Determinar vencedor baseado em kills
    let localWinner;
    if (oppLost > myLost) {
      localWinner = "VICTORY"; // Eu ganhei
      winner = "VICTORY"; // Correto para a tela
      console.log('[WIN] üéâ VIT√ìRIA LOCAL (oppLost > myLost)');
      
      // ‚úÖ XP: Processar eventos de vit√≥ria
      processMatchEndXPEvents('win');
      applyMatchXP();
      
      console.log("[THOR.HTML] üöÄ Antes de chamar showVictoryScreen()");
      showVictoryScreen();
      console.log("[THOR.HTML] üîô Voltou de showVictoryScreen()");
    }
    else if (oppLost < myLost) {
      localWinner = "DEFEAT"; // Eu perdi
      winner = "DEFEAT"; // Correto para a tela
      console.log('[WIN] üò¢ DERROTA LOCAL (oppLost < myLost)');
      
      // ‚úÖ XP: Processar eventos de derrota
      console.log('[WIN] üîç ANTES processMatchEndXPEvents(defeat) - xpTotalMatch:', xpTotalMatch);
      processMatchEndXPEvents('defeat');
      console.log('[WIN] üîç DEPOIS processMatchEndXPEvents(defeat) - xpTotalMatch:', xpTotalMatch);
      applyMatchXP();
      
      showDefeatScreen();
    }
    else {
      localWinner = "DRAW";
      winner = "Empate!";
      console.log('[WIN] ü§ù EMPATE LOCAL (oppLost == myLost)');
      
      // ‚úÖ XP: Processar eventos de empate
      processMatchEndXPEvents('draw');
      applyMatchXP();
      
      showDrawScreen();
    }

    document.getElementById('gameCanvas').style.display = "none";
    
    console.log("[THOR.HTML] ‚úÖ Ap√≥s showVictoryScreen/Defeat/Draw, antes de enviar THOR:GAME_OVER");
    console.log("[THOR.HTML] gameOverSent atual:", gameOverSent);
    console.log("[THOR.HTML] xpTotalMatch atual:", xpTotalMatch);
    
    // üéØ SALVAR XP FINAL PARA O CHAT
    finalXpForChat = xpTotalMatch;
    console.log("[THOR.HTML] üíæ finalXpForChat salvo:", finalXpForChat);
    
    // Em multiplayer, atualizar match no banco com vencedor
    if (multiplayerMode && supabaseClient && matchData) {
      updateMatchWinner(localWinner, myLost, oppLost).catch(err => {
        console.error('[WIN] Erro ao atualizar vencedor:', err);
      });
    }

    // Enviar GAME_OVER uma √∫nica vez
    console.log("[THOR.HTML] Verificando condi√ß√µes para enviar THOR:GAME_OVER...");
    console.log("[THOR.HTML]   - !gameOverSent:", !gameOverSent);
    console.log("[THOR.HTML]   - window.parent exists:", !!(window.parent));
    console.log("[THOR.HTML]   - window.parent !== window:", window.parent !== window);
    if (!gameOverSent && window.parent && window.parent !== window) {
      gameOverSent = true;
      console.log("[THOR.HTML] Preparando para enviar THOR:GAME_OVER");
      console.log("[THOR.HTML] xpTotalMatch:", xpTotalMatch);
      console.log("[THOR.HTML] matchId:", localStorage.getItem("thor_match_id"));
      console.log("[THOR.HTML] opponentName:", localStorage.getItem("thor_match_opponent_name"));
      try {
        window.parent.postMessage({
          type: "THOR:GAME_OVER",
          payload: {
            myLost,
            oppLost,
            myKills: oppLost,
            oppKills: myLost,
            xpGained: xpTotalMatch, // ‚úÖ XP real calculado no thor.html
            matchId: localStorage.getItem("thor_match_id"),
            opponentName: localStorage.getItem("thor_match_opponent_name"),
          }
        }, window.location.origin);
        console.log("[THOR.HTML] THOR:GAME_OVER enviado com sucesso!", { myLost, oppLost, myKills: oppLost, oppKills: myLost, xpGained: xpTotalMatch });
      } catch (err) {
        console.error("[THOR.HTML] Error sending THOR:GAME_OVER:", err);
      }
    } else {
      console.warn("[THOR.HTML] THOR:GAME_OVER N√ÉO enviado. gameOverSent:", gameOverSent, "hasParent:", !!(window.parent && window.parent !== window));
    }

    return true; // Indica que o jogo terminou
  }

  return false; // Jogo continua
}

// Atualizar match no banco com vencedor
async function updateMatchWinner(localWinner, myLost, oppLost) {
  try {
    console.log('[WIN] ========================================');
    console.log('[WIN] Atualizando match com vencedor');
    console.log('[WIN] localWinner:', localWinner);
    console.log('[WIN] myTeam:', myTeam);
    console.log('[WIN] myLost:', myLost, 'oppLost:', oppLost);
    
    // Determinar vencedor global (player1 ou player2)
    let winner_id = null;
    if (localWinner === 'VICTORY') {
      winner_id = myUserId; // Eu ganhei
    } else if (localWinner === 'DEFEAT') {
      winner_id = opponentUserId; // Oponente ganhou
    }
    // Se DRAW, winner_id fica null
    
    console.log('[WIN] winner_id:', winner_id);
    
    // Atualizar match
    const { error } = await supabaseClient
      .from('matches')
      .update({
        phase: 'finished',
        winner_id: winner_id,
        finished_at: new Date().toISOString()
      })
      .eq('id', matchData.id);
    
    if (error) {
      console.error('[WIN] Erro ao atualizar match:', error);
      return;
    }
    
    console.log('[WIN] ‚úÖ Match atualizado com vencedor');
  } catch (err) {
    console.error('[WIN] Exce√ß√£o ao atualizar vencedor:', err);
  }
}

function fillEndScoreUI(hideDetails = false, hideTotal = false) {
  updateScoreBoard();

  document.querySelectorAll(".score-details").forEach(el => {
    if (hideDetails) {
      el.style.display = 'none';
    } else {
      el.style.display = 'block';
      el.innerHTML = buildScoreDetails();
    }
  });

  // ‚úÖ EXIBIR XP TOTAL (n√£o Score)
  document.querySelectorAll(".score-total").forEach(el => {
    if (hideTotal) {
      el.style.display = 'none';
    } else {
      el.style.display = 'block';
      const displayValue = xpTotalMatch === 0 ? '0' : (xpTotalMatch > 0 ? `+${xpTotalMatch}` : `${xpTotalMatch}`);
      // Exibe TOTAL XP normalmente
      el.textContent = `TOTAL XP: ${displayValue}`;
      // Se for modo pr√°tica, exibe aviso logo abaixo
      if (!multiplayerMode) {
        // Cria ou seleciona o elemento de aviso
        let warning = el.nextElementSibling;
        if (!warning || !warning.classList.contains('practice-xp-warning')) {
          warning = document.createElement('div');
          warning.className = 'practice-xp-warning';
          warning.style.marginTop = '8px';
          warning.style.fontSize = '15px';
          warning.style.color = '#FFD34F';
          warning.style.textShadow = '0 0 8px #000, 0 0 12px #FFD34F88';
          warning.style.fontFamily = "'Orbitron', sans-serif";
          warning.style.letterSpacing = '1px';
          warning.style.textAlign = 'center';
          el.parentNode.insertBefore(warning, el.nextSibling);
        }
        warning.textContent = `[ PRACTICE ] ` + t('practiceXpWarning');
        warning.style.display = 'block';
      } else {
        // Oculta o aviso se n√£o for pr√°tica
        let warning = el.nextElementSibling;
        if (warning && warning.classList.contains('practice-xp-warning')) {
          warning.style.display = 'none';
        }
      }
    }
  });

  updateHeaderScore(); // ‚úÖ ADICIONE ESTA LINHA

  // --- HUD vertical fix: always reserve space ---
  const hud = document.getElementById('hudTop');
  if (hud) {
    if (hideDetails && hideTotal) {
      hud.style.visibility = 'hidden';
      hud.style.opacity = '0';
    } else {
      hud.style.display = 'flex';
      hud.style.visibility = 'visible';
      hud.style.opacity = '1';
    }
  }
}


function showVictoryScreen() {
  if (window.resultScreenShown) return;
  window.resultScreenShown = true;
  if (document.getElementById("modeSelectionScreen").style.display === "flex") return;

  if ((cpuDestroyed - cpuDestroyedAntesDoRound) === 3) {
    playerScore += 200;
    bonusAllAtOnce = true;
  }
  if (playerNaves.every(n => n.hp > 0)) {
    playerScore += 250;
    bonusNoLoss = true;
  }

  showOnly('victoryScreen');
  
  // Atualizar textos traduzidos
  const victoryTextEl = document.getElementById('victoryText');
  const victoryBtnEl = document.getElementById('restartVictory');
  if (victoryTextEl) victoryTextEl.textContent = t('victory');
  if (victoryBtnEl) victoryBtnEl.textContent = t('returnToLobby');
  
  fillEndScoreUI(); // ‚úÖ aqui j√° vai atualizar o header tamb√©m
  
  // N√ÉO finalizar match aqui - ser√° feito via THOR:GAME_OVER
  
  // envia o score ao parent uma vez quando a tela de resultado aparece
  try {
    if (!scoreMessageSent && window.parent && window.parent !== window) {
      window.parent.postMessage({ type: "THOR:SCORE_UPDATE", payload: { score: clampScore() } }, window.location.origin);
      scoreMessageSent = true;
    }
  } catch (e) { console.warn('Erro ao enviar THOR:SCORE_UPDATE', e); }
  
  console.log("[THOR.HTML] üéØ showVictoryScreen() CONCLU√çDA, retornando para checkWinCondition");
}

function showDefeatScreen() {
  if (window.resultScreenShown) return;
  window.resultScreenShown = true;
  if (document.getElementById("modeSelectionScreen").style.display === "flex") return;

  showOnly('defeatScreen');
  
  // Atualizar textos traduzidos
  const defeatTextEl = document.getElementById('defeatText');
  const defeatBtnEl = document.getElementById('restartDefeat');
  if (defeatTextEl) defeatTextEl.textContent = t('defeat');
  if (defeatBtnEl) defeatBtnEl.textContent = t('returnToLobby');
  
  // ‚úÖ Ocultar score details e total XP na derrota
  fillEndScoreUI(true, true);
  
  // N√ÉO finalizar match aqui - ser√° feito via THOR:GAME_OVER
  
  try {
    if (!scoreMessageSent && window.parent && window.parent !== window) {
      window.parent.postMessage({ type: "THOR:SCORE_UPDATE", payload: { score: clampScore() } }, window.location.origin);
      scoreMessageSent = true;
    }
  } catch (e) { console.warn('Erro ao enviar THOR:SCORE_UPDATE', e); }
}

function showDrawScreen() {
  if (window.resultScreenShown) return;
  window.resultScreenShown = true;
  if (document.getElementById("modeSelectionScreen").style.display === "flex") return;

  showOnly('drawScreen');
  
  // Atualizar textos traduzidos
  const drawTextEl = document.getElementById('drawText');
  const drawBtnEl = document.getElementById('restartDraw');
  if (drawTextEl) drawTextEl.textContent = t('draw');
  if (drawBtnEl) drawBtnEl.textContent = t('returnToLobby');
  
  fillEndScoreUI();
  
  // N√ÉO finalizar match aqui - ser√° feito via THOR:GAME_OVER
  
  try {
    if (!scoreMessageSent && window.parent && window.parent !== window) {
      window.parent.postMessage({ type: "THOR:SCORE_UPDATE", payload: { score: clampScore() } }, window.location.origin);
      scoreMessageSent = true;
    }
  } catch (e) { console.warn('Erro ao enviar THOR:SCORE_UPDATE', e); }
}

/**
 * Finaliza partida multiplayer e envia para o parent processar
 */
function finalizeMultiplayerMatch(result) {
  try {
    const matchSource = localStorage.getItem("thor_match_source");
    const matchId = localStorage.getItem("thor_match_id");
    const opponentName = localStorage.getItem("thor_match_opponent_name");

    // S√≥ finalizar se for multiplayer
    if (matchSource !== "multiplayer" || !matchId || !opponentName) {
      return;
    }

    const myScore = clampScore();
    // Para bot, simular um score (pode ser 0 ou aleat√≥rio)
    const opponentScore = Math.floor(Math.random() * myScore * 0.8);

    // Enviar estat√≠sticas de naves destru√≠das
    const myKills = cpuDestroyed;       // Naves do oponente que eu destru√≠ (correto)
    const oppKills = playerDestroyed;   // Minhas naves destru√≠das (correto)

    // Determinar resultado com base em kills
    let finalResult = result;
    if (myKills > oppKills) {
      finalResult = 'win';
    } else if (myKills < oppKills) {
      finalResult = 'loss';
    } else {
      finalResult = 'draw';
    }

    // Enviar ao parent para processar
    if (window.parent && window.parent !== window) {
      window.parent.postMessage({
        type: "THOR:FINALIZE_MATCH",
        payload: {
          matchId,
          opponentName,
          myScore,
          opponentScore,
          myKills,
          oppKills,
          result: finalResult, // 'win' | 'loss' | 'draw' calculado por kills
        }
      }, window.location.origin);
    }

    console.log("Match finalization requested:", { matchId, result, myScore, myKills });
  } catch (err) {
    console.error("Error requesting match finalization:", err);
  }
}



function restartGame() {
  window._gameLoopStarted = false; 
  // Reseta contadores e status do placar e b√¥nus
  collisionCpuSolo = 0;
  collisionPlayerSolo = 0;
  navesPerdidas = 0;
  bonusAllAtOnce = false;
  bonusNoLoss = false;
  playerDestroyed = 0;
  cpuDestroyed = 0;
  winner = null;
  gameOverSent = false; // Resetar flag de game over
  gameActive = true; // Reativar o jogo

 // Esconde o canvas do jogo e o HUD superior
  document.getElementById("gameCanvas").style.display = "none";
  document.getElementById("hudTop").style.display = "none";

  // Esconde SVG do contorno do jogo (se quiser)
  document.querySelector("svg").style.visibility = "hidden";
  // Esconde tudo do jogo
  document.getElementById("gameCanvas").style.display = "none";
  document.getElementById("gameContour").style.visibility = "hidden";
  document.getElementById("hudTop").style.display = "none";

  // Mostra apenas a sele√ß√£o de naves
  document.getElementById("naveSelectScreen").style.display = "flex";
  document.getElementById("thorspace-logo").style.display = "none";
  document.getElementById("startContainer").style.display = "none";
  document.getElementById("modeSelectionScreen").style.display = "none";

  // Reseta sele√ß√£o de naves
  selectedNaves = [];
  updatePreviews();
  
  // Iniciar timer de sele√ß√£o se estiver em multiplayer
  if (multiplayerMode && currentPhase === 'select') {
    PVP.hasSavedSelection = false;
    startSelectionTimer();
    console.log('[PVP] ‚è±Ô∏è Timer de sele√ß√£o de 15s iniciado');
  }

  // Reseta vari√°veis de rodada e estado (mant√©m os dados prontos para pr√≥xima partida)
  wrecks = [];
  explosions = [];
  projectiles = [];
  selectedNave = null;
  planningTimer = 10;
  lastTime = Date.now();
  round = 1;
  phase = "roundText";
  showingRoundText = true;
  roundTextAlpha = 0;
  roundTextFadeIn = true;
  roundTextTimer = 0;
}



function showVictoryModal() {
  const victoryTitle = document.getElementById("victoryTitle");
  if (winner === "VICTORY") {
    victoryTitle.textContent = playerName + " " + t('won');
  } else {
    victoryTitle.textContent = winner;
  }
  document.getElementById("victoryModal").style.display = "flex";
  document.getElementById("gameCanvas").style.pointerEvents = "none";
}

function hideVictoryModal() {
  document.getElementById("victoryModal").style.display = "none";
  document.getElementById("gameCanvas").style.pointerEvents = "auto";
}

function getCenter(naves) {
  const vivos = naves.filter(n => n.hp > 0);
  if (vivos.length === 0) return { x: 400, y: 300 };
  const x = vivos.reduce((sum, n) => sum + n.x, 0) / vivos.length;
  const y = vivos.reduce((sum, n) => sum + n.y, 0) / vivos.length;
  return { x, y };
}

let MAX_MOVEMENT_RADIUS = 300;


function drawGame() {
  applyScreenShake();
ctx.save();
ctx.translate(shakeX, shakeY);

  // Limpar e desenhar fundo preto como fallback
  ctx.fillStyle = '#111';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  drawParticles(ctx);

  // Fundo gal√°xia
  if (backgroundGalaxy.complete) {
    ctx.drawImage(backgroundGalaxy, 0, 0, canvas.width, canvas.height);
  }

  // Desenhar destro√ßos (wrecks) ANTES das naves para ficarem atr√°s
  wrecks.forEach(w => {
    ctx.strokeStyle = "#999";
    ctx.beginPath();
    ctx.moveTo(w.x - 10, w.y - 10);
    ctx.lineTo(w.x + 10, w.y + 10);
    ctx.moveTo(w.x + 10, w.y - 10);
    ctx.lineTo(w.x - 10, w.y + 10);
    ctx.stroke();
  });

  // --- DESENHA APENAS NAVES VIVAS ---
  playerNaves.forEach(n => {
    if (n.hp > 0) drawNave(n, spritePlayer, false);
  });
  cpuNaves.forEach(n => {
    if (n.hp > 0) drawNave(n, n.sprite, true);
  });

  // Efeitos visuais para nave selecionada
  if (selectedNave !== null && selectedNave.hp > 0) {
    const nave = selectedNave; // selectedNave j√° √© o objeto da nave
    
      if (!nave.target) {
        ctx.beginPath();
        ctx.arc(nave.x, nave.y, nave.alcance, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(0,255,255,0.07)";
        ctx.fill();
        ctx.strokeStyle = "#0ff";
        ctx.setLineDash([4, 4]);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      ctx.beginPath();
      ctx.moveTo(nave.x, nave.y);
      ctx.lineTo(mouseX, mouseY);
      ctx.strokeStyle = nave.target ? "#f00" : "#0ff";
      ctx.setLineDash([4, 4]);
      ctx.stroke();
      ctx.setLineDash([]);

// Se for fase de movimento: dois c√≠rculos conc√™ntricos (solo ou multiplayer)
if (phase === "selectMove" || (phase === "select" && !nave.target)) {
    ctx.save();
    // C√≠rculo externo
    ctx.beginPath();
    ctx.arc(mouseX, mouseY, 14, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(0,255,255,0.13)";
    ctx.fill();
    ctx.strokeStyle = "#0ff";
    ctx.lineWidth = 2;
    ctx.stroke();

    // C√≠rculo interno
    ctx.beginPath();
    ctx.arc(mouseX, mouseY, 7, 0, Math.PI * 2);
    ctx.strokeStyle = "#0ff";
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.restore();
}

// Se for fase de tiro: alvo de mira estilizado (solo ou multiplayer com target j√° definido)
if (phase === "selectShot" || (phase === "select" && nave.target)) {
    ctx.save();
    // C√≠rculo externo
    ctx.beginPath();
    ctx.arc(mouseX, mouseY, 18, 0, Math.PI * 2);
    ctx.strokeStyle = "#f00";
    ctx.lineWidth = 3;
    ctx.stroke();

    // C√≠rculo interno
    ctx.beginPath();
    ctx.arc(mouseX, mouseY, 7, 0, Math.PI * 2);
    ctx.strokeStyle = "#f00";
    ctx.lineWidth = 2;
    ctx.stroke();

    // Desenhar o alvo (crosshair)
    ctx.strokeStyle = "#f00";
    ctx.lineWidth = 2;
    // Linha vertical
    ctx.beginPath();
    ctx.moveTo(mouseX, mouseY - 10);
    ctx.lineTo(mouseX, mouseY + 10);
    ctx.stroke();
    // Linha horizontal
    ctx.beginPath();
    ctx.moveTo(mouseX - 10, mouseY);
    ctx.lineTo(mouseX + 10, mouseY);
    ctx.stroke();
    ctx.restore();
}
  }

  ctx.fillStyle = "#fff";
projectiles.forEach(p => {
  ctx.save();
  // Cor: ciano para player, vermelho para cpu
  const isCpu = p.target === "player";
  const mainColor = isCpu ? "#ff3a34" : "#0ff";
  const tailColor = isCpu ? "rgba(255,40,40,0.08)" : "rgba(20,255,255,0.04)";
  const gradColor1 = isCpu ? "rgba(255,60,60,0.18)" : "rgba(0,255,255,0.18)";
  const gradColor2 = isCpu ? "rgba(255,100,100,1)" : "rgba(80,255,255,1)";

  // Cauda mais curta
  let grad = ctx.createLinearGradient(
    p.x - p.dx * 9, p.y - p.dy * 9,
    p.x, p.y
  );
  grad.addColorStop(0, tailColor);
  grad.addColorStop(0.6, gradColor1);
  grad.addColorStop(1, gradColor2);

  ctx.strokeStyle = grad;
  ctx.shadowColor = mainColor;
  ctx.shadowBlur = 8;
  ctx.lineWidth = 4;

  // Tremidinha animada
  let t = performance.now() / 140;
  let sway = Math.sin(t + p.x * 0.1 + p.y * 0.03) * 1.3;

  ctx.beginPath();
  ctx.moveTo(p.x - p.dx * 9 + sway, p.y - p.dy * 9 - sway);
  ctx.lineTo(p.x, p.y);
  ctx.stroke();

  // Ponta do laser (brilho circular)
  ctx.shadowBlur = 14;
  ctx.beginPath();
  ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
  ctx.fillStyle = mainColor;
  ctx.globalAlpha = 0.45;
  ctx.fill();

  ctx.restore();


});



 explosions.forEach(e => {
  // Flash branco inicial
  if (e.flash && e.flash > 0) {
    ctx.save();
    ctx.globalAlpha = e.flash / 8;
    ctx.beginPath();
    ctx.arc(e.x, e.y, (e.big ? 50 : 18) + 12 * e.flash, 0, Math.PI * 2);
    ctx.fillStyle = "#fff";
    ctx.fill();
    ctx.restore();
    e.flash--;
  }
  // Explos√£o principal (amarela/laranja maior)
  ctx.save();
  ctx.beginPath();
  ctx.arc(e.x, e.y, e.big ? e.radius * 2 : e.radius, 0, Math.PI * 2);
  ctx.fillStyle = e.big ? "orange" : "orange";
  ctx.globalAlpha = 0.9;
  ctx.fill();
  ctx.restore();
});


if (winner) {
    ctx.save();
    ctx.font = "bold 60px Orbitron, sans-serif";
    ctx.textAlign = "center";
    ctx.fillStyle = "#fff";
    ctx.strokeStyle = "#0ff";
    ctx.lineWidth = 4;
    ctx.strokeText(winner, canvas.width / 2, canvas.height / 2);
    ctx.fillText(winner, canvas.width / 2, canvas.height / 2);
    ctx.restore();
}
function drawFuturisticTimerIcon(ctx, x, y, color="#14ffff") {
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = 3.5;
  ctx.shadowColor = color;
  ctx.shadowBlur = 16;

  // Corpo do timer (um c√≠rculo com tra√ßo no topo)
  ctx.beginPath();
  ctx.arc(x, y, 17, 0.35*Math.PI, 1.65*Math.PI, false); // arco inferior
  ctx.stroke();

  ctx.beginPath();
  ctx.arc(x, y, 17, 1.75*Math.PI, 0.25*Math.PI, false); // arco superior
  ctx.stroke();

  // Tra√ßo centralizado no topo (como se fosse um rel√≥gio digital)
  ctx.beginPath();
  ctx.moveTo(x, y-17);
  ctx.lineTo(x, y-9);
  ctx.stroke();

  // Linhas laterais, para look mais digital
  ctx.beginPath();
  ctx.moveTo(x-10, y+14);
  ctx.lineTo(x-6, y+6);
  ctx.moveTo(x+10, y+14);
  ctx.lineTo(x+6, y+6);
  ctx.stroke();

  // Circulo central (ponteiro digital)
  ctx.beginPath();
  ctx.arc(x, y, 4, 0, 2*Math.PI);
  ctx.fillStyle = color;
  ctx.globalAlpha = 0.7;
  ctx.fill();

  ctx.shadowBlur = 0;
  ctx.restore();
}


  // --- Round X texto por cima de tudo, com fade ---
  if (showingRoundText) {
    ctx.save();
    ctx.globalAlpha = roundTextAlpha;
    ctx.font = "bold 60px Orbitron, sans-serif";
    ctx.textAlign = "center";
    ctx.fillStyle = "#fff";
    ctx.strokeStyle = "#0ff";
    ctx.lineWidth = 4;
    ctx.strokeText("Round " + round, canvas.width/2, canvas.height/2);
    ctx.fillText("Round " + round, canvas.width/2, canvas.height/2);
    ctx.globalAlpha = 1.0;
    ctx.restore();
  }
   // --- Ready?/Go! texto central com fade ---
  if (showReadyGo) {
    ctx.save();
    ctx.globalAlpha = readyGoAlpha;
    ctx.font = "bold 60px Orbitron, sans-serif";
    ctx.textAlign = "center";
    ctx.fillStyle = "#fff";
    ctx.strokeStyle = "#0ff";
    ctx.lineWidth = 4;
    ctx.strokeText(readyGoText, canvas.width / 2, canvas.height / 2);
    ctx.fillText(readyGoText, canvas.width / 2, canvas.height / 2);
    ctx.globalAlpha = 1.0;
    ctx.restore();
  }
  ctx.restore();

  // Atualiza part√≠culas
for (let i = particles.length - 1; i >= 0; i--) {
  let p = particles[i];
  p.x += p.dx;
  p.y += p.dy;
  p.dx *= 0.98; // desacelera√ß√£o leve
  p.dy *= 0.98;
  p.life--;
  if (p.life < 0) particles.splice(i, 1);
}

// Desenha part√≠culas
particles.forEach(p => {
  ctx.save();
  ctx.globalAlpha = Math.max(0, p.life / p.maxLife);
  ctx.fillStyle = p.color;
  ctx.beginPath();
  ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
  ctx.shadowColor = p.color;
  ctx.shadowBlur = 16;
  ctx.fill();
  ctx.restore();
});


}

function drawMinimalistTimerIcon(ctx, x, y, radius, color, timer) {
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = 3.5;
  ctx.shadowColor = color;
  ctx.shadowBlur = 14;

  // C√≠rculo externo
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, 2 * Math.PI);
  ctx.stroke();

  // Bolinha central
  ctx.beginPath();
  ctx.arc(x, y, 4, 0, 2 * Math.PI);
  ctx.fillStyle = color;
  ctx.globalAlpha = 0.8;
  ctx.fill();

  ctx.globalAlpha = 1;

  // Ponteiro girat√≥rio (gira conforme o tempo)
  // Rotaciona em fun√ß√£o dos segundos restantes (quanto menor, mais adiantado)
const angle = (-Math.PI / 2) - (2 * Math.PI * ((timer % 10) / 10)); // gira hor√°rio

  const pointerLength = radius - 4;
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(x + pointerLength * Math.cos(angle), y + pointerLength * Math.sin(angle));
  ctx.strokeStyle = color;
  ctx.lineWidth = 2.4;
  ctx.shadowBlur = 18;
  ctx.stroke();

  ctx.restore();
}

let selectPulseTime = 0;

function gameLoop() {
  if (!gameActive) return;
  selectPulseTime += 0.07; // quanto menor, mais lento o pulso
  updateGame();
  drawGame();
  requestAnimationFrame(gameLoop);
}



let spritesLoaded = 0;
let canStartGame = false;

function tryStartGame() {
  spritesLoaded++;
  if (spritesLoaded === 2 && canStartGame) {
    console.log("üéÆ Sprites carregadas, iniciando gameLoop()");
    gameLoop();
  }
}

spritePlayer.onload = tryStartGame;
spriteCPU.onload = tryStartGame;

setTimeout(() => {
  if (spritesLoaded < 2 && canStartGame) {
    console.warn("‚è≥ Sprites n√£o carregadas a tempo, iniciando mesmo assim.");
    gameLoop();
  }
}, 1200);




var playerName = "Jogador";
// evita envio duplicado do score ao parent
var scoreMessageSent = false;


function updateScoreBoard() {
  const player = (typeof playerName === 'string' && playerName.length > 0) ? playerName : "Jogador";
  let opponent = localStorage.getItem("thor_match_opponent_name") || "CPU";
  
  // Em modo PVP, usar o nome do oponente real
  if (multiplayerMode && opponentUsername) {
    opponent = opponentUsername;
  }
  
  document.querySelectorAll('.score-board').forEach(sb => {
    // Se for PVP, mostrar com cores dos times
    if (multiplayerMode) {
      const myColor = myTeam === 'blue' ? '#00d4ff' : '#ff4444';
      const oppColor = myTeam === 'blue' ? '#ff4444' : '#00d4ff';
      const myKills = getOppLost();
      const myDeaths = getMyLost();
      sb.innerHTML = `<span style="color: ${myColor};">${player}</span> ${myKills} x ${myDeaths} <span style="color: ${oppColor};">${opponent}</span>`;
    } else {
      sb.innerHTML = `${player} ${cpuDestroyed} x ${playerDestroyed} ${opponent}`;
    }
  });
}

function updateHeaderScore() {
  // Se estamos em iframe, n√£o fazer nada aqui (header √© do Next.js)
  if (window.self !== window.top) return;
  const el = document.getElementById("userHeaderPts");
  if (!el) return;
  el.textContent = `${clampScore()}pts`;
  // sincroniza com o header centralizado
  try { createOrUpdateHeader(playerName, playerScore); } catch (e) { /* silent */ }
}
  
// Faz o update centralizado do header quando o score muda
function refreshHeaderFromState() {
  // Se estamos em iframe, n√£o fazer nada aqui
  if (window.self !== window.top) return;
  createOrUpdateHeader(playerName, playerScore);
}

// Cria ou atualiza o header √∫nico usado pelo jogo (nome, score, logout)
function createOrUpdateHeader(name, score) {
  // se estamos embedados em um iframe, n√£o criar/mostrar o header antigo
  // SEMPRE retornar quando em iframe, pois o header vem do Next.js
  if (window.self !== window.top) return;
  let header = document.getElementById('userHeader');
  if (!header) {
    header = document.createElement('div');
    header.id = 'userHeader';
    header.className = 'user-header';
    header.style.position = 'fixed';
    header.style.top = '20px';
    header.style.right = '12px';
    header.style.zIndex = 9000;
    header.style.display = 'flex';
    header.style.alignItems = 'center';
    header.style.gap = '13px';

    const img = document.createElement('img');
    img.src = 'images/nave_normal.png';
    img.className = 'user-header-ship';
    img.alt = 'Nave';
    header.appendChild(img);

    const nameSpan = document.createElement('span');
    nameSpan.id = 'userHeaderName';
    nameSpan.className = 'user-header-name';
    header.appendChild(nameSpan);

    const ptsSpan = document.createElement('span');
    ptsSpan.id = 'userHeaderPts';
    ptsSpan.className = 'user-header-pts';
    header.appendChild(ptsSpan);

    const btn = document.createElement('button');
    btn.id = 'userLogoutBtn';
    btn.className = 'user-logout-btn';
    btn.textContent = t('logout');
    header.appendChild(btn);

    document.body.appendChild(header);
  }

  const nameEl = document.getElementById('userHeaderName');
  const ptsEl = document.getElementById('userHeaderPts');
  if (nameEl) nameEl.textContent = name || '';
  if (ptsEl) ptsEl.textContent = `${clampScore(typeof score === 'undefined' ? undefined : score)}pts`;

  // garante que o header seja vis√≠vel ap√≥s qualquer atualiza√ß√£o
  try { header.style.display = 'flex'; } catch (e) { /* silent */ }

  // garante que exista apenas um header (remove duplicados acidentais)
  const headers = document.querySelectorAll('#userHeader');
  if (headers.length > 1) {
    headers.forEach((h, idx) => { if (idx > 0) h.remove(); });
  }

  // attach logout to send postMessage to parent (non-destructive)
  const logoutBtn = document.getElementById('userLogoutBtn');
  if (logoutBtn && !logoutBtn._bound) {
    logoutBtn.addEventListener('click', () => {
      try {
        if (window.parent && window.parent !== window) {
          window.parent.postMessage({ type: 'THOR:LOGOUT' }, window.location.origin);
        }
      } catch (e) {
        console.warn('Erro ao enviar THOR:LOGOUT', e);
      }
    });
    logoutBtn._bound = true;
  }
}

function showHeader() {
  // Se estamos em iframe, n√£o fazer nada aqui
  if (window.self !== window.top) return;
  const h = document.getElementById('userHeader');
  if (h) h.style.display = 'flex';
}

function setHeaderVisible(visible) {
  // Se estamos em iframe, n√£o fazer nada aqui
  if (window.self !== window.top) return;
  const h = document.getElementById('userHeader');
  if (!h) return;
  h.style.display = visible ? 'flex' : 'none';
}



const naveSources = {
  1: "images/nave_alcance.png",
  2: "images/nave_protecao.png",
  3: "images/spaceschip.png"
};

const naveSourcesRed = {
  1: "images/nave_alcance_red.png",
  2: "images/nave_protecao_red.png",
  3: "images/nave_normal_red.png"
};


let selectedNaves = [];

function selectNave(tipo) {
  // AAA: Bloquear input se inputLocked
  if (inputLocked) {
    console.log('[INPUT] Input bloqueado (inputLocked=true)');
    return;
  }
  if (selectedNaves.length >= 3) return;

  selectedNaves.push(tipo);
  updatePreviews();
}


function removeNave(index) {
  if (isSelectionLocked()) return;
  selectedNaves.splice(index, 1);
  updatePreviews();
  // Se remover, destrava sele√ß√£o
  if (selectedNaves.length < 3 && PVP.selectionComplete) {
    PVP.selectionComplete = false;
    console.log('[Selection] unlocked by removal');
  }
}

function updatePreviews() {
  // Escolher fontes baseado no time
  const sources = (multiplayerMode && myTeam === 'red') ? naveSourcesRed : naveSources;
  
  // Reseta todas as imagens de preview
  for (let i = 0; i < 3; i++) {
    const preview = document.getElementById(`preview${i + 1}`);
    preview.src = "images/placeholder_nave.png";
    preview.style.opacity = "0.4";
  }

  // Atualiza com base nas naves atualmente selecionadas
  selectedNaves.forEach((tipo, i) => {
    const preview = document.getElementById(`preview${i + 1}`);
    if (sources[tipo]) {
      preview.src = sources[tipo];
      preview.style.opacity = "1";
    }
  });

  // Mostra o bot√£o somente se houver exatamente 3 selecionadas
  const btn = document.getElementById("startGameBtn");
  const has3Ships = (selectedNaves.length === 3);
  btn.style.display = has3Ships ? "block" : "none";
  
  // Alterar texto do bot√£o no modo multiplayer
  if (multiplayerMode && !PVP.hasSavedSelection) {
    btn.textContent = t('ready');
  } else {
    btn.textContent = t('startGame');
  }
}


function startGameAfterSelection() {
  console.log("‚úÖ startGameAfterSelection chamada!");
  console.log("[GAME] multiplayerMode:", multiplayerMode);
  console.log("[GAME] matchData:", matchData ? "exists" : "null");
  console.log("[GAME] myTeam:", myTeam);

  // reset flag para permitir envio de score na pr√≥xima partida
  scoreMessageSent = false;
  
  // ‚úÖ Resetar flags de finaliza√ß√£o para nova partida
  finalScoreSaved = { myLost: 0, oppLost: 0 }; // Resetar placar salvo
  matchFinalizationProcessed = false;
  statsUpdated = false;
  gameOverSent = false;
  console.log("[GAME] üîÑ Flags resetadas para nova partida");
  
  // ‚úÖ XP: Resetar sistema de XP para nova partida
  resetMatchXP();

  if (selectedNaves.length !== 3) {
    alert("Escolha 3 naves antes de iniciar.");
    return;
  }

  console.log("üõ∞Ô∏è 3 naves selecionadas:", selectedNaves);
  localStorage.setItem("navesSelecionadas", JSON.stringify(selectedNaves));

  if (!playerName || playerName.trim().length === 0) {
    playerName = "Jogador";
  }

  // MODO MULTIPLAYER: Sistema de turnos
  if (multiplayerMode && matchData) {
    console.log('[PVP] ========================================');
    console.log('[PVP] MODO MULTIPLAYER - Salvando sele√ß√£o de naves...');
    console.log('[PVP] Meu time:', myTeam);
    console.log('[PVP] Naves selecionadas:', selectedNaves);
    
    // Guard: evitar salvar m√∫ltiplas vezes
    if (PVP.hasSavedSelection) {
      console.log('[PVP] ‚ö†Ô∏è Sele√ß√£o j√° salva, ignorando');
      return;
    }
    
    PVP.hasSavedSelection = true;
    
    // Cancelar timer se estiver rodando
    cancelSelectionTimer();
    
    // Salvar minhas naves no banco
    saveShipSelection().then(success => {
      if (!success) {
        alert('Erro ao salvar sele√ß√£o de naves');
        PVP.hasSavedSelection = false; // permitir retry
        // Reabilitar bot√£o
        const btn = document.getElementById('startGameBtn');
        if (btn) {
          btn.disabled = false;
          btn.textContent = t('ready');
        }
        return;
      }
      
      console.log('[PVP] ‚úÖ Sele√ß√£o salva com sucesso');
      
      // (H) Feedback visual: desabilitar bot√£o e mostrar aguardando
      const btn = document.getElementById('startGameBtn');
      if (btn) {
        btn.disabled = true;
        btn.textContent = t('waitingSync');
        btn.style.opacity = '0.6';
      }
      
      // Aguardar Realtime ou fallback REST chamar startBattleFromSelection
    });
    
    console.log('[PVP] ========================================');
    return;
  }

  // Modo solo/practice normal
  console.log("[SOLO] ========================================");
  console.log("[SOLO] Modo SOLO/PRACTICE - Inicializando CPU");
  console.log("[SOLO] ========================================");
  
  document.getElementById("naveSelectScreen").style.display = "none";

  // Aplica as naves escolhidas
  applyPlayerNavesFromSelection(selectedNaves);
  
  // Inicializar CPU apenas para modo solo
  initCpuNaves();

  // Mostra o canvas e o HUD do jogo
  galaxyBg.style.opacity = "0.18";
  document.getElementById("gameCanvas").style.display = "block";
  var hudTop = document.getElementById("hudTop");
  var timerText = document.getElementById("timerText");
  var legendArea = document.getElementById("legendArea");
  if (hudTop && timerText && legendArea) {
    showGameHUD('10', 'Round 1 - Prepare-se para a batalha');
  }
  document.getElementById("gameContour").style.visibility = "visible";

  // Mostrar banner de matchup
  const matchupBanner = document.getElementById("matchupBanner");
  const playerNameDisplay = document.getElementById("playerNameDisplay");
  const opponentNameDisplay = document.getElementById("opponentNameDisplay");
  
  if (matchupBanner && playerNameDisplay && opponentNameDisplay) {
    const currentPlayerName = playerName || localStorage.getItem("thor_username") || "Player";
    playerNameDisplay.textContent = currentPlayerName;
    
    // Usar vari√°vel global opponentUsername (multiplayer) ou buscar do localStorage, ou "CPU"
    let displayOpponentName = "CPU";
    
    if (multiplayerMode && opponentUsername) {
      // Modo multiplayer com nome do oponente carregado
      displayOpponentName = opponentUsername;
      opponentNameDisplay.style.color = "#FF4444"; // Vermelho para jogador real
      console.log('[MATCHUP] Multiplayer - Oponente:', displayOpponentName);
    } else {
      const storedOpponentName = localStorage.getItem("thor_match_opponent_name");
      if (storedOpponentName) {
        displayOpponentName = storedOpponentName;
        opponentNameDisplay.style.color = "#FF4444"; // Vermelho para jogador real
        console.log('[MATCHUP] Multiplayer (localStorage) - Oponente:', displayOpponentName);
      } else {
        opponentNameDisplay.style.color = "#FFA500"; // Laranja para CPU
        console.log('[MATCHUP] Practice mode - Oponente: CPU');
      }
    }
    
    opponentNameDisplay.textContent = displayOpponentName;
    matchupBanner.style.display = "block";
    matchupBanner.style.visibility = "visible";
    matchupBanner.style.opacity = "1";
    
    // Log para debug
    console.log('[MATCHUP] Banner exibido:', currentPlayerName, 'vs', displayOpponentName);
    console.log('[MATCHUP] Banner display:', matchupBanner.style.display);
    console.log('[MATCHUP] Banner computed:', window.getComputedStyle(matchupBanner).display);
    
    // For√ßar ap√≥s um delay para garantir que outras fun√ß√µes n√£o escondam
    setTimeout(() => {
      if (matchupBanner.style.display === "none") {
        console.warn('[MATCHUP] ‚ö†Ô∏è Banner foi escondido! For√ßando exibi√ß√£o novamente...');
        matchupBanner.style.display = "block";
      }
    }, 100);
  }

  canStartGame = true;

// Chama o gameLoop s√≥ se ainda n√£o estiver rodando
if (!window._gameLoopStarted) {
  window._gameLoopStarted = true;
  gameActive = true;
  if (spritesLoaded === 2) {
    console.log("üöÄ Sprites j√° carregadas, iniciando gameLoop!");
    gameLoop();
  } else {
    console.log("‚è≥ Aguardando sprites carregarem para iniciar gameLoop...");
    // Voc√™ pode aguardar o carregamento dos sprites aqui se quiser
  }
}
} // ‚úÖ FECHA startGameAfterSelection AQUI



// üîì Deixa as fun√ß√µes acess√≠veis pelo HTML inline (onclick)
window.selectNave = selectNave;
window.removeNave = removeNave;
window.startGameAfterSelection = startGameAfterSelection;

// No handler de snapshot/sync do servidor:
function applyServerSnapshot(newShips) {
  if (typeof ships !== 'undefined' && Array.isArray(ships)) {
    const merged = mergeShipsPreservingFlags(ships, newShips);
    ships = merged;
    console.log('[SYNC] merge snapshot preserving ready/selected');
  } else {
    ships = newShips;
    console.log('[SYNC] initial snapshot');
  }
  updatePreviews();
}

// Fun√ß√£o para desbloquear sele√ß√£o explicitamente
function unlockSelection() {
  PVP.selectionComplete = false;
  selectedNaves = [];
  updatePreviews();
  console.log('[Selection] unlocked by explicit action');
}


let assetsToLoad = 6;
let assetsLoaded = 0;

const preloadAssets = [
  "images/spaceschip.png",
  "images/nave_alcance.png",
  "images/nave_protecao.png",
  "sounds/sfx-hit.mp3",
  "sounds/sfx-shot.mp3",
  "sounds/sfx-explode.mp3"
];

assetsToLoad = preloadAssets.length;

function assetLoaded() {
  assetsLoaded++;
  const percent = Math.floor((assetsLoaded / assetsToLoad) * 100);
  document.getElementById("loadingBar").style.width = percent + "%";

  if (assetsLoaded >= assetsToLoad) {
    setTimeout(() => {
      if (!isEmbedded) showOnly("startContainer"); // Mostra s√≥ a tela de login quando n√£o embedado
    }, 500);
  }
}



preloadAssets.forEach(src => {
  if (src.endsWith(".mp3")) {
    const audio = new Audio();
    audio.src = src;
    audio.addEventListener("canplaythrough", assetLoaded, { once: true });
    audio.addEventListener("error", assetLoaded, { once: true }); // prote√ß√£o extra
  } else {
    const img = new Image();
    img.src = src;
    img.onload = assetLoaded;
    img.onerror = assetLoaded; // prote√ß√£o extra
  }
});

// Caso algo falhe por qualquer motivo, for√ßa o loading a sumir em 5 segundos
setTimeout(() => {
  if (assetsLoaded < assetsToLoad) {
    if (!isEmbedded) showOnly("startContainer");
  }
}, 5000);



window.addEventListener("DOMContentLoaded", () => {
  const startBtn = document.getElementById("startBtn");
  const playerNameInput = document.getElementById("playerNameInput");

startBtn.onclick = () => {
  playerName = playerNameInput.value.trim();
  if (playerName.length === 0) {
    playerNameInput.focus();
    playerNameInput.style.borderColor = "#f00";
    return;
  }
  
  // Sempre ap√≥s login do usu√°rio (mas s√≥ se n√£o estiver em iframe)
  if (!isEmbedded) {
    createOrUpdateHeader(playerName, playerScore);
  }

  document.getElementById("startContainer").style.display = "none";
  document.getElementById("thorspace-logo").style.display = "none"; // Esconde logo se ainda estiver vis√≠vel
showOnly("modeSelectionScreen");

};

  // Se estiver embedado, ouvir THOR:INIT do parent para inicializar username e mode
  if (isEmbedded) {
    window.addEventListener('message', async (event) => {
      if (event.origin !== window.location.origin) return;
      const msg = event.data;
      if (!msg || typeof msg !== 'object') return;
      if (msg.type === 'THOR:INIT') {
        const payload = msg.payload || {};
        const initName = String(payload.username || '').trim();
        const initMode = String(payload.mode || 'practice');
        const userId = payload.userId;
        const matchId = payload.matchId;

        console.log('[MP INIT PAYLOAD]', {
          payload,
          userId,
          username: initName,
          mode: initMode,
          matchId
        });

        // Armazenar dados do jogador ANTES de qualquer inicializa√ß√£o
        if (userId && initName) {
          window.THOR_PLAYER = { userId, username: initName, matchId };
          console.log('[THOR] Jogador autenticado via postMessage:', window.THOR_PLAYER);
        } else {
          console.error('[THOR] ‚ùå ATEN√á√ÉO: userId ou username n√£o recebidos!', { userId, initName });
        }

        if (initName) {
          playerName = initName;
          // N√£o criar header aqui pois j√° vem do Next.js quando embedado
          if (!isEmbedded) {
            createOrUpdateHeader(playerName, playerScore);
          }
        }

        // Checar se h√° matchId na URL para modo PVP real
        const urlParams = getUrlParams();
        
        console.log('[MP BOOT]', {
          href: location.href,
          search: location.search,
          urlParams,
          mode: urlParams.mode,
          matchId: urlParams.matchId,
          THOR_PLAYER: window.THOR_PLAYER
        });
        
        if (urlParams.mode === 'multiplayer' && urlParams.matchId) {
          console.log('[PVP] Detectado matchId na URL:', urlParams.matchId);
          
          // AGUARDAR um pouco para garantir que o Supabase client est√° dispon√≠vel
          setTimeout(async () => {
            try {
              console.log('[MP] Iniciando initMultiplayerMode...');
              const success = await initMultiplayerMode(urlParams.matchId);
              
              if (success) {
                console.log('[PVP] ‚úÖ Multiplayer inicializado com sucesso');
                // Ir para sele√ß√£o de naves
                showOnly('naveSelectScreen');
                selectedNaves = [];
                updatePreviews();
                // AAA: Garantir fase interativa e timer no round 1
                phase = 'select';
                currentPhase = 'select';
                ensurePvpInteractivePhase('initMultiplayerMode');
              } else {
                console.error('[PVP] ‚ùå FALHA ao inicializar multiplayer - initMultiplayerMode retornou false');
                alert('Erro ao inicializar multiplayer: Falha na inicializa√ß√£o (verifique console)');
              }
            } catch (err) {
              console.error('[MP INIT ERROR] ‚ùå‚ùå‚ùå EXCE√á√ÉO CAPTURADA ‚ùå‚ùå‚ùå');
              console.error('[MP INIT ERROR] Tipo:', typeof err);
              console.error('[MP INIT ERROR] Mensagem:', err.message || 'sem mensagem');
              console.error('[MP INIT ERROR] Code:', err.code || 'sem code');
              console.error('[MP INIT ERROR] Details:', err.details || 'sem details');
              console.error('[MP INIT ERROR] Stack:', err.stack);
              console.error('[MP INIT ERROR] Objeto completo:', err);
              console.log('[MP CONTEXT]', {
                href: location.href,
                search: location.search,
                mode: urlParams.mode,
                matchId: urlParams.matchId,
                THOR_PLAYER: window.THOR_PLAYER
              });
              
              const errorMsg = err.message || err.toString() || 'Erro desconhecido';
              alert(`Erro MP: ${errorMsg}\n\nVerifique o console para detalhes completos.`);
            }
          }, 100);
        } else if (initMode === 'multiplayer') {
          // Multiplayer sem matchId (n√£o deveria acontecer)
          console.error('[PVP] Mode=multiplayer mas sem matchId na URL');
          showOnly('naveSelectScreen');
          selectedNaves = [];
          updatePreviews();
        } else {
          // Modo solo (practice)
          console.log('[SOLO] Modo pr√°tica');
          showOnly('naveSelectScreen');
          selectedNaves = [];
          updatePreviews();
        }
      }
    });
  }

  // Registra o clique do bot√£o de logout do header para apenas enviar mensagem ao parent
  const logoutBtn = document.getElementById('userLogoutBtn');
  if (logoutBtn && !logoutBtn._bound) {
    logoutBtn.addEventListener('click', () => {
      try {
        if (window.parent) {
          window.parent.postMessage({ type: "THOR:LOGOUT" }, window.location.origin);
        }
      } catch (e) {
        // silencioso: n√£o redireciona nem faz logout, apenas tenta enviar a mensagem
        console.warn('Erro ao enviar mensagem de logout ao parent', e);
      }
    });
    logoutBtn._bound = true;
  }

// ============================================
// APLICAR TRADU√á√ïES NA INTERFACE
// ============================================
function updateUITranslations() {
  // T√≠tulo da sele√ß√£o
  const titleEl = document.getElementById('selectShipsTitle');
  if (titleEl) titleEl.textContent = t('selectShips');
  
  // Labels de Range e Protection
  document.querySelectorAll('.ship-label-range').forEach(el => {
    el.textContent = t('range');
  });
  document.querySelectorAll('.ship-label-protection').forEach(el => {
    el.textContent = t('protection');
  });
  
  // Descri√ß√µes das naves
  const shipDescs = document.querySelectorAll('.ship-desc-text');
  shipDescs.forEach(el => {
    const shipNum = el.getAttribute('data-ship');
    if (shipNum === '1') el.textContent = t('ship1Desc');
    if (shipNum === '2') el.textContent = t('ship2Desc');
    if (shipNum === '3') el.textContent = t('ship3Desc');
  });
  
  // Bot√£o de iniciar
  const startBtn = document.getElementById('startGameBtn');
  if (startBtn && !multiplayerMode) {
    startBtn.textContent = t('startGame');
  }
}

// Atualizar tradu√ß√µes quando a tela de sele√ß√£o aparecer
const originalShowNaveSelect = showOnly;
window.showOnly = function(screenName) {
  originalShowNaveSelect(screenName);
  if (screenName === 'naveSelectScreen') {
    setTimeout(updateUITranslations, 100);
  }
};


document.getElementById("practiceBtn").onclick = () => {
  document.getElementById("modeSelectionScreen").style.display = "none";
  // garante que usamos o header √∫nico e removemos poss√≠veis duplicatas antigas
  // (mas s√≥ se n√£o estiver em iframe)
  if (!isEmbedded) {
    createOrUpdateHeader(playerName, playerScore);
    document.querySelectorAll('.user-header-pts, .user-header-name').forEach(el => { if (!el.closest('#userHeader')) el.remove(); });
  }
  document.getElementById("naveSelectScreen").style.display = "flex";
  document.getElementById("thorspace-logo").style.display = "none";
  selectedNaves = [];
  updatePreviews();
};


document.getElementById("multiplayerBtn").onclick = () => {
  document.getElementById("modeSelectionScreen").style.display = "none";
  document.getElementById("matchmakingScreen").style.display = "flex";

  // Mostra o nome do player no slot azul
  document.getElementById("playerSlot").textContent = playerName;

  // Inicia a rota√ß√£o vertical dos nomes
  startMatchmakingSlot();

  // Aguarda 6s: (3s de rota√ß√£o + 3s de "Oponente encontrado!")
  setTimeout(() => {
    document.getElementById("matchmakingScreen").style.display = "none";
    // antes de abrir a tela de escolha de naves, garantir header √∫nico
    // (mas s√≥ se n√£o estiver em iframe)
    if (!isEmbedded) {
      createOrUpdateHeader(playerName, playerScore);
      document.querySelectorAll('.user-header-pts, .user-header-name').forEach(el => { if (!el.closest('#userHeader')) el.remove(); });
    }
    document.getElementById("naveSelectScreen").style.display = "flex";
    document.getElementById("thorspace-logo").style.display = "none";

    selectedNaves = [];
    updatePreviews();
  }, 6000);
};



  document.querySelectorAll(".nave-card").forEach(el => {
    el.addEventListener("click", (e) => {
      // AAA: Permitir sele√ß√£o de nave SEMPRE que a tela de sele√ß√£o estiver vis√≠vel
      const naveSelectScreen = document.getElementById('naveSelectScreen');
      if (naveSelectScreen && naveSelectScreen.style.display !== 'none') {
        const tipo = parseInt(el.dataset.nave, 10);
        selectNave(tipo);
        return;
      }
      // Fora da sele√ß√£o de naves, aplicar guardas multiplayer
      if (multiplayerMode) {
        if (!isMyTurn) {
          console.log('[PVP][INPUT][GUARD][CARD] Ignorando clique em nave-card: n√£o √© meu turno.');
          e.stopPropagation();
          return;
        }
        if (typeof phase !== 'undefined' && phase !== 'select') {
          console.log('[PVP][INPUT][GUARD][CARD] Ignorando clique em nave-card: phase != select. phase:', phase);
          e.stopPropagation();
          return;
        }
      }
      const tipo = parseInt(el.dataset.nave, 10);
      selectNave(tipo);
    });
  });
});


function startMatchmakingSlot() {
  const names = ["Jo√£o", "Maria", "Lucas", "Ana", "Rafael", "Thais", "Pedro", "Juliana"];
  const container = document.getElementById("opponentNames");
  const legend = document.getElementById("matchLegend");
  
  // Passo 1: mostra legenda "Procurando oponente..."
  legend.textContent = t('searchingOpponent');

  // Monta nomes verticalmente
  container.innerHTML = "";
  container.classList.add("slot-names");
  names.forEach(n => {
    const el = document.createElement("div");
    el.textContent = n;
    el.style.height = "42px";
    el.style.lineHeight = "42px";
    el.style.fontSize = "22px";
    el.style.textAlign = "center";
    container.appendChild(el);
  });
  container.style.animation = "spinNames 2s cubic-bezier(.73,-0.05,.67,1.03)";

  // Depois de 2s, para a anima√ß√£o e mostra o nome do oponente
  setTimeout(() => {
    container.style.animation = "none";
    const chosen = names[Math.floor(Math.random() * names.length)];
    container.innerHTML = `<div style="height:42px;line-height:42px;font-size:22px;text-align:center;">${chosen}</div>`;

    // Muda legenda por 3 segundos
    legend.textContent = t('opponentFound');

    // Ap√≥s 3s, troca para tela de sele√ß√£o de naves
    setTimeout(() => {
      document.getElementById("matchmakingScreen").style.display = "none";
      document.getElementById("naveSelectScreen").style.display = "flex";
      selectedNaves = [];
      updatePreviews();
      // AAA: Sempre iniciar timer de sele√ß√£o ao abrir naveSelectScreen
      setTimeout(() => {
        if (multiplayerMode && typeof startSelectionTimer === 'function') {
          startSelectionTimer();
        }
        // Re-adiciona handler de clique nas nave-card ap√≥s DOM update
        document.querySelectorAll(".nave-card").forEach(el => {
          el.onclick = null;
          el.addEventListener("click", (e) => {
            const naveSelectScreen = document.getElementById('naveSelectScreen');
            if (naveSelectScreen && naveSelectScreen.style.display !== 'none') {
              const tipo = parseInt(el.dataset.nave, 10);
              selectNave(tipo);
              return;
            }
            if (multiplayerMode) {
              if (!isMyTurn) {
                console.log('[PVP][INPUT][GUARD][CARD] Ignorando clique em nave-card: n√£o √© meu turno.');
                e.stopPropagation();
                return;
              }
              if (typeof phase !== 'undefined' && phase !== 'select') {
                console.log('[PVP][INPUT][GUARD][CARD] Ignorando clique em nave-card: phase != select. phase:', phase);
                e.stopPropagation();
                return;
              }
            }
            const tipo = parseInt(el.dataset.nave, 10);
            selectNave(tipo);
          });
        });
      }, 100);
    }, 3000);
  }, 2000); // Este setTimeout √∫nico √© ok - n√£o √© polling
}

// POLLING REMOVIDO: Realtime substitui necessidade de polling
// Se precisar fallback, implementar somente quando disconnected com intervalo >= 10s


// Cleanup do canal multiplayer ao fechar/sair
window.addEventListener('beforeunload', () => {
  // Parar heartbeat ao sair
  stopHeartbeat();
  
  // Se estiver em partida multiplayer em andamento, aplicar WO
  if (multiplayerMode && matchData && currentPhase !== 'finished') {
    console.log('[WO] Jogador saindo durante partida, aplicando WO via sendBeacon');
    
    // Usar sendBeacon para enviar de forma s√≠ncrona (mais confi√°vel no unload)
    const supabaseUrl = new URLSearchParams(window.location.search).get('supabaseUrl');
    const supabaseKey = new URLSearchParams(window.location.search).get('supabaseKey');
    
    if (supabaseUrl && supabaseKey && matchData.id && opponentUserId) {
      const url = `${supabaseUrl}/rest/v1/matches?id=eq.${matchData.id}`;
      const payload = JSON.stringify({
        phase: 'finished',
        winner_id: opponentUserId,
        wo: true,
        finished_at: new Date().toISOString()
      });
      
      const blob = new Blob([payload], { type: 'application/json' });
      
      // sendBeacon √© s√≠ncrono e confi√°vel para unload
      navigator.sendBeacon(url, blob);
      
      // Tamb√©m tentar com fetch keepalive como fallback
      fetch(url, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          'apikey': supabaseKey,
          'Authorization': `Bearer ${supabaseKey}`,
          'Prefer': 'return=minimal'
        },
        body: payload,
        keepalive: true // Permite requisi√ß√£o continuar ap√≥s p√°gina fechar
      }).catch(() => {}); // Ignorar erros
      
      console.log('[WO] WO aplicado via sendBeacon + fetch keepalive');
    }
  }
  
  // Remover canais ao fechar
  if (supabaseClient) {
    try {
      if (syncChannel) {
        supabaseClient.removeChannel(syncChannel);
        console.log('[PVP] Canal broadcast removido ao fechar');
      }
      if (matchStateChannel) {
        supabaseClient.removeChannel(matchStateChannel);
        console.log('[PVP] Canal de estado removido ao fechar');
      }
    } catch (err) {
      console.error('[PVP] Erro ao remover canais:', err);
    }
  }
});

</script>
</body>
</html>